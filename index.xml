<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vaaandark&#39;s blog</title>
    <link>https://vaaandark.top/</link>
    <description>Recent content on vaaandark&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 27 Dec 2024 20:07:44 +0800</lastBuildDate><atom:link href="https://vaaandark.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>双城记——2024 回顾</title>
      <link>https://vaaandark.top/posts/2024-look-back/</link>
      <pubDate>Fri, 27 Dec 2024 20:07:44 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/2024-look-back/</guid>
      <description>&lt;p&gt;2024 年过得真快，我的本科也过得飞快，已经是十二月末了，再有五六个月我就毕业了，而且我已经打了半年多的工了。相比心态上的转变，生活工作方式和节奏的变化则是真真切切而且无法回避的。&lt;/p&gt;
&lt;p&gt;今年有太多的第一次尝试：第一次在另一座城市生活，第一次实习，第一次转正答辩，第一次获得国家级竞赛一等奖，第一次听音乐会……也做出了太多选择：选择实习去向，选择放弃保研……&lt;/p&gt;
&lt;p&gt;今年去过六个城市，按照时间先后是武汉、上海、宜昌、深圳、香港和成都，在武汉生活和读书，在上海参加了一场超算比赛，在深圳实习，去了香港和重庆旅游。&lt;/p&gt;
&lt;p&gt;在上海的 ASC 超算比赛是轻松加愉快的，我作为编外运维打了酱油，被学长学姐请吃饭，还和高中同学连玩两天，甚至在上海收获了我的实习 offer。等到国际劳动节前夕，我又和室友错峰游了宜昌，在清江峡谷收获了我的微信头像，还见识了三峡大坝的人造伟力。之后我便马不停蹄飞往深圳实习。&lt;/p&gt;
&lt;p&gt;我对实习秋招其实是缺乏准备的，八股也没好好背，题目也没好好刷，所以面试中自己的长板和短板都展现得淋漓尽致。比如我可以跟面试官畅谈操作系统和协程涉及，但遇到数据库直接说我不会。非常感谢腾讯☁️的面试官，可以说是不拘一格降人才了，也可能是非常对胃口（根据之后他做我导师的情况来看）。在经过了一次技术面，一次总监面，一次 hr 面后我进入了腾讯云实习，在云原生的容器团队做分布式相关的工作。&lt;/p&gt;
&lt;p&gt;在这之前我从未在家乡之外的城市生活，生活状态的转换其实没有那么困难。和从初中开始同学的朋友一起来到深圳实习，合租一间两居室，一起交给中介半个月的房租。从一开始一起上班下班，到后来我下班晚早上起不来，我们分别上下班。我周末到处闲逛，探索深圳；他中途暑研，平时复习考试并准备英语。我准备转正和直接工作；他充实简历并准备出国：我们都做着各自认为正确的事情。直到我开始准备转正答辩，他发现了更适合他的实习岗位。最后我们都离开那间两居室，他去向上海，我去向隔壁的一居室……&lt;/p&gt;
&lt;p&gt;工作和转正都比我想象中顺利很多，组内氛围很好，同事和老板都很好。尤其是导师帮助了我很多，在我入职前一天就做好了我的培养计划发给了我，密密麻麻的好几页。我不知道我在别的地方是否会收到这样的重视和培养——我觉得不会，所以我直接准备了实习转正，没有考虑实习。我也喜欢这个工作，我并没有接触过后端业务，也并不喜欢 curd，我更喜欢 infra 和解决 Linux 的疑难杂症。&lt;/p&gt;
&lt;p&gt;暑假和我妈去了香港转了一下，在之后和朋友去重庆穷游。顺带一提，重庆和香港真像，路上都是黄色的出租车，路上都没有电动车。我好像除了初中毕业和高中毕业时，感觉从来没有这么自由过。&lt;/p&gt;
&lt;p&gt;实习答辩后我回到了武汉上学（其实是翘课在武汉的 base 上班），在上车前接到老板的电话告诉我可以留用，在欣喜过后的恍惚间我才发现我其实可以不用准备秋招了。&lt;/p&gt;
&lt;p&gt;我好像没有做什么选择，被机缘推着前行，但又在每个命运的十字路口做出了坚定的选择。在八月份我被带着打了操作系统赛获得了一等奖，我又突然意识，我可能有保研的机会。结果九月份时我发现我上个学期的体育课成绩因为提前考试并跑路去实习而没有作数，我必须快速做出选择，是全力争取体育成绩生效争取保研，还是尽力争取就行，本科毕业直接工作。&lt;/p&gt;
&lt;p&gt;熟悉我的朋友都知道后来发生的故事了，我放弃了保研，我在国庆长假后回到了深圳继续实习。只不过那个时候暑期已过，深圳再没有同级的同学一起实习，我原以为后续实习的基调是孤独而无聊的，但我发现我已经融入了团队：我先是被同事邀请去他乔迁之喜，时隔多年再次打了三国杀，这是在大学这个充满年轻人的地方都不曾有过的体验；又去了惠州团建，人生第一次看到如此清晰的星空。我也发现了其他有趣的活动，我在十一月左右开始每周末独自爬两座山，这是生在江汉平原的我从未有过的体验：中午起床，骑行前往山脚下，傍晚前登顶欣赏日落，走夜路下山，再骑行回家。乘兴而来，兴尽而归。&lt;/p&gt;
&lt;p&gt;到前几天，也就是圣诞前夕，我又和朋友去香港听了弥撒亚音乐会，又是新奇的人生体验。在哈利路亚的大合唱中，我看到所有信徒起立，向受难羔羊致敬；在维港海边的轻风和音乐中，我又感到文艺电影重庆森林般的氛围。&lt;/p&gt;
&lt;p&gt;我在香港的书店又看到了我想看而一直没时间看的卡夫卡的《城堡》，我却联想到中间件消息队列工具 kafka，也许我可以把我下一个写的云原生组件命名为卡尔维诺（按照☁️上工具的命名习惯把c改成k），这也是我最喜欢的作家。或者可以叫柯西莫，让🌳上的男爵变成☁️上的男爵。&lt;/p&gt;
&lt;p&gt;再见我的 2024，我已上☁️，状态良好。希望生活在☁️上不是生活在🌳上，不是离群索居，而是命运与共……&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>求 n 个数中前 k 小的数</title>
      <link>https://vaaandark.top/posts/the-smallest-k-numbers/</link>
      <pubDate>Wed, 27 Mar 2024 20:02:33 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/the-smallest-k-numbers/</guid>
      <description>&lt;p&gt;面试时遇到的一道题：给出给出 n 个数，求出前 k 小的数字。&lt;/p&gt;
&lt;p&gt;输入是 n + 1 行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一行是 n 和 k&lt;/li&gt;
&lt;li&gt;之后 n 行是这个数列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出是 k 个数。&lt;/p&gt;
&lt;p&gt;当时没想出来怎么做，直接嗯排序，然后输出，OJ 的时限比较宽容，竟然过了😄。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;不过在面试官那里肯定是没过的。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;直接排序的时间复杂度是 $O(nlg{n})$ ，如果维护一个大小为 k 的堆则是能够优化成 $O(nlg{k})$ ，肯定有更好的方法。&lt;/p&gt;
&lt;p&gt;后来想到了类似快排的划分的思想，代码和思路如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// 打印范围在 [begin, end) 的数组切片
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; print_slice(vector&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt;&amp;gt; &amp;amp;a, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; begin, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; end) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  cout &amp;lt;&amp;lt; &amp;#34;-------&amp;#34; &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = begin; i &amp;lt; end; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  cout &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  cout &amp;lt;&amp;lt; &amp;#34;-------&amp;#34; &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// 类似二分的思想，对于范围在 [begin, end) 的数组切片进行划分
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; sol(vector&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt;&amp;gt; &amp;amp;a, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; begin, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; end, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; k) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (begin &amp;gt;= end || k &amp;lt;= &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; lower = begin;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; upper = end - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// 以最左边的为轴
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// 小于它的放左边，大于它的放右边
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; pivot = a[lower];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt; (lower &amp;lt; upper) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt; (lower &amp;lt; upper &amp;amp;&amp;amp; a[upper] &amp;gt; pivot) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      upper -= &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (lower &amp;lt; upper) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      a[lower] = a[upper];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      lower += &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt; (lower &amp;lt; upper &amp;amp;&amp;amp; a[lower] &amp;lt; pivot) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      lower += &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (lower &amp;lt; upper) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      a[upper] = a[lower];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      upper -= &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  a[lower] = pivot;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; left_count = lower - begin;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// 左边的数就是前 left_count 小的数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// 如果轴左边数的数量刚好为 k - 1 ，则说明已经找到了前 k 小的数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// 如果小于 k - 1 ，则说明还需要在右边找前 k - 1 - left_count 小的数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// 如果大于 k - 1 ，则说明需要在左边找前 k 小的数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (left_count &amp;lt;= k - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_slice(a, begin, lower + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sol(a, lower + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, end, k - left_count - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sol(a, begin, lower, k);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; n, k;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  vector&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt;&amp;gt; a(n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; n; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cin &amp;gt;&amp;gt; a[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  sol(a, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, n, k);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cout &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这道题在 &lt;a href=&#34;https://leetcode.cn/problems/smallest-k-lcci/description/&#34;&gt;力扣&lt;/a&gt; 上也有，看了题解之后发现这是算法导论上讲过的，感觉自己不仅算法水平低下，而且还读书不认真😭。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2021 年八月杂感【补档】</title>
      <link>https://vaaandark.top/posts/scribble-in-august/</link>
      <pubDate>Sat, 16 Mar 2024 01:58:33 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/scribble-in-august/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;首发于知乎&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我从未对很少阅读近三十年的文学作品感到遗憾，因为我并没有从那些已经加入作协的“主流”作家那里汲取过营养，我觉得作家不靠稿费而是靠体制的工资生活是一件奇怪而又羞耻的事情。&lt;/p&gt;
&lt;p&gt;不过我的确也曾读过他们作品的片段，那是在初中和高中的阅读之中，但这使我常常感到厌烦。倒不是因为对应试的反感，可能就是性格让我读不进去这些文章。我会反感余秋雨的“文化大散文”，也会觉得韩少功的作品充满了小农思想，还会觉得《南渡北归》对民国和民国知识精英过度美化……无一例外，这都是老师们推荐的作家，不过我隐隐约约感觉我就是对这样的文学难以接受。&lt;/p&gt;
&lt;p&gt;我前天看到了一些视频，讲的是矿工诗人陈年喜的故事。矿工，大家都知道这是一种高危职业，但很少有人能够理解他们的日常工作到底有多么危险。他们既是远离乡土的农民，也是深山深井中的工人，他们注定了不会获得社会的过多关注，就像我的输入法矿工在“旷工”和“狂攻”的后面一样。&lt;/p&gt;
&lt;p&gt;我回想起某次综艺事故，演员高某身亡，一堆所谓明星在微博发声“演员是高危职业”，要求保障演员权利。有些网友用许多职业的例子来反驳演员算高危职业的观点，更多网友只是把他们当做了公猴和母猴。是啊，这些明星光鲜亮丽、收入不菲，已经是名利双收，但他们还想要更多，也许是“学霸人设”，也许是“职业精神”，也许是公众对他们“社会责任感”认同。我又发现了我好像很少看这些明星的作品，更会觉得明星的综艺就是垃圾。想到这里，我又模糊地感觉我好像知道了我对文艺作品的评判标准。&lt;/p&gt;
&lt;p&gt;当我看完讲这位矿工诗人的视频后，我终于明白了我为何会有如此的好恶观，那就是我不会去喜欢脱离了人民生活的作品。陈年喜的作品是从土里面生长出来的。这里的土，并不是文联主席、副主席衣锦还乡，市委县委作陪时踏上的“乡土”，而是我国最为广大的劳动人民遭受且消化过的无尽苦难和通过劳动创造出的少许幸福。陈年喜爱秦腔，爱孝歌，他的作品集的名字叫做《活着就是冲天一喊》，他的诗集叫做《炸裂志》。&lt;/p&gt;
&lt;p&gt;他写的有些诗句并不逊色顾城、海子太多，当他知道母亲身患食道癌时，他写下“我在五千米深处打发中年/我把岩层一次次炸裂/借此/把一生重新组合/我微小的亲人/远在商山脚下/他们有病/身体落满灰尘/我的中年裁下多少/他们的晚年就能延长多少/我身体里有炸药三吨/他们是引信部分/就在昨夜/在他们床前/我岩石一样/轰地炸裂一地”。他的文字深沉质朴，不用过多修饰也不喜渲染苦难，犹如从土里带着泥巴钻出，但又有着炸裂地底最坚硬岩石的力量。这力量也是柔软的，能令猛士堕泪。&lt;/p&gt;
&lt;p&gt;说实话，大部分现代诗歌的文学意义我难以理解，凭借着时代背景和他人的评价我才能够理解文学史的意义。中国上个世纪的诗人，有多少都是文学史意义大于文学意义。但我时常在想，若不是“主流”的批评家可以看到他们的诗句，若不是他们的诗句带动了那个写诗的时代，他们的文学史意义又从何而来？再如果陈年喜或是其他的工农诗人，他们的作品能够带动公众目光对劳动的关注，对劳动者的关切，以及人民娱乐方式和精神生活的转变升华，他们的文学史意义岂不是比“主流”作家更高更高。&lt;/p&gt;
&lt;p&gt;再谈回到我所讨厌的几种文学吧。&lt;/p&gt;
&lt;p&gt;上个世纪的“伤痕文学”，还有所谓的“新伤痕文学”，他们大多数的反思还是停留在自己的苦难上，并把它归结到人祸之上，于是他们可以批评伟人，讽刺养活他们的所谓“落后体制”，解构中国的传统，滥用中国人的劣根性。但他们从未意识到自己身为知识青年体会到的只是农民的日常，他们应该反思的难道不应该是，为什么自己能够娇柔做作到将几亿人的生活日常视作自己不该承受的灾难。&lt;/p&gt;
&lt;p&gt;而一些有关自然和生态环境的作品，并不是通过表现生态灾难来表达环境保护的重要性，而是以文人对美感的追求出发，空洞地谈过去的自然是美的，现在是不美的。也许这只是我身为理科生的偏见，但他们的确也对工业化和科技发展有偏见。还记得一片文章里，韩少功以他的极其无知，组织着不属于他认知范围的专业名词，冷嘲热讽着人工智能。估计说来也就是答应给某个落魄纸媒的主编的人情，帮他写一篇能够蹭到社会热点的评论文章。发展带来的问题不是发展本身的过错，对发展的贬低莫不是对那些为建设付出血汗的人的背叛。坐在办公室里喝茶的作家老爷们，怎么可能看到工厂开工时对当地就业的贡献、职业病对工人身体的摧残，他们或许也早已失去了或者从未有过能够书写过量劳动和污染对人民的伤害的艺术技巧。说的低情商一点，他们需要去找到自己的初心和良心。&lt;/p&gt;
&lt;p&gt;我网购了《活着就是冲天一喊》和《炸裂志》，就当是支持身患矽肺病的老陈，可惜出版社只有简装版。但我转念一想，那些被我内涵的“主流”作家们，又有多少作品有精装版呢？在这个娱乐至死的时代，他们虽然被关注，但也不过是那余光的一瞥。不过作家们可以开个公众号，再抢一抢流量的残羹冷饭嘛。&lt;/p&gt;
&lt;p&gt;如今的文艺太轻太轻，飘得太高太高，离土地太远太远。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编辑于 2021-08-13 15:34&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>华科 OS 实验的 RISC-V 代理内核是如何启动的？</title>
      <link>https://vaaandark.top/posts/how-riscv-pke-startup/</link>
      <pubDate>Sat, 02 Mar 2024 01:32:50 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/how-riscv-pke-startup/</guid>
      <description>&lt;p&gt;代码仓库为 &lt;a href=&#34;https://gitee.com/hustos/riscv-pke&#34;&gt;hustos riscv-pke&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下内容基于 lab2 代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;入口在哪&#34;&gt;入口在哪？&lt;/h3&gt;
&lt;p&gt;入口为 &lt;code&gt;kernel/machine/mentry.S&lt;/code&gt; 的 &lt;code&gt;_mentry&lt;/code&gt; ，它调用了 &lt;code&gt;kernel/machine/minit.c&lt;/code&gt; 的 &lt;code&gt;m_start(uintptr_t hartid, uintptr_t dtb)&lt;/code&gt; ，两个参数并没有在 &lt;code&gt;_mentry&lt;/code&gt; 中设置，这是因为 spike 会自动设置 &lt;code&gt;a0&lt;/code&gt; 寄存器为 CPU id ，设置 &lt;code&gt;a1&lt;/code&gt; 寄存器为设备树字符串，这刚好也符合 RV 的传参规则。&lt;/p&gt;
&lt;p&gt;值得注意的是， spike 模拟执行 pke 代码时是从 M 模式开始的。&lt;/p&gt;
&lt;h3 id=&#34;_mentry-里面做了什么&#34;&gt;&lt;code&gt;_mentry&lt;/code&gt; 里面做了什么？&lt;/h3&gt;
&lt;p&gt;首先是给 &lt;code&gt;mscratch&lt;/code&gt; 寄存器赋值为 0 ，再设置操作系统的堆栈。&lt;/p&gt;
&lt;p&gt;设置操作系统堆栈的具体步骤是：将 &lt;code&gt;mhartid&lt;/code&gt; 寄存器的值读到 &lt;code&gt;a4&lt;/code&gt; 寄存器，之后一系列四则运算重新计算栈底寄存器，让不同 CPU 核心的堆栈不会冲突。比如 thread0 的栈底是 a ， thread1 的栈底就应该是 a + 4096 。&lt;/p&gt;
&lt;h3 id=&#34;m_start-函数里面做了什么&#34;&gt;&lt;code&gt;m_start&lt;/code&gt; 函数里面做了什么？&lt;/h3&gt;
&lt;p&gt;初始化了一些 spike 的东西，这些不是很重要。&lt;/p&gt;
&lt;p&gt;之后就是将保存中断时上下文的 &lt;code&gt;g_itrframe&lt;/code&gt; 的地址赋值给了 &lt;code&gt;mscratch&lt;/code&gt; 寄存器（也就是 &lt;code&gt;_mentry&lt;/code&gt; 中的注释， &lt;code&gt;mscratch&lt;/code&gt; 指向 M 模式下的栈底）。&lt;/p&gt;
&lt;p&gt;将 MPP 设置成了 S 模式，这个 MPP(machine previous privilege) 是指进入 M 模式之前的模式，这样设置的目的是在之后的 &lt;code&gt;mret&lt;/code&gt; 后能进入 S 模式。之后将 &lt;code&gt;mepc&lt;/code&gt; 寄存器设置为 &lt;code&gt;s_start&lt;/code&gt; ，这就能在之后的 &lt;code&gt;mret&lt;/code&gt; 后不仅能进入 S 模式，还能从 &lt;code&gt;s_start&lt;/code&gt; 开始执行。&lt;/p&gt;
&lt;p&gt;操作系统要在 M 模式执行系统调用，所以要设置系统调用时的入口，也就是把 &lt;code&gt;mtvec&lt;/code&gt; 寄存器赋值为 &lt;code&gt;mtrapvec&lt;/code&gt; 。之后分析如何进入系统调用时再详细介绍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;值得注意的是 &lt;code&gt;mtrapvec&lt;/code&gt; 要 4-byte 对齐， &lt;code&gt;mtvec&lt;/code&gt; 寄存器虽然是 MXLEN 长度的，但是它后两位使用来标识是直接系统调用还是向量系统调用的，所以它只能存 4-byte 对齐的函数入口地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之后依次，打开 M 模式中断，将所有中断和异常委托到 S 模式执行，再打开 S 模式中断，初始化时钟中断。&lt;/p&gt;
&lt;p&gt;最后调用 &lt;code&gt;mret&lt;/code&gt; 退出 M 模式，进入到预设好的 S 模式代码，也就是 &lt;code&gt;s_start&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;s_start-函数里面做了什么&#34;&gt;&lt;code&gt;s_start&lt;/code&gt; 函数里面做了什么？&lt;/h3&gt;
&lt;p&gt;(未完待续)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MIT6.S081 Lab:Fixup Xargs</title>
      <link>https://vaaandark.top/posts/mit6.s081-labfixup-xargs/</link>
      <pubDate>Mon, 26 Feb 2024 23:41:18 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/mit6.s081-labfixup-xargs/</guid>
      <description>&lt;p&gt;昨天朋友跟我说我的 MIT6.S081 lab1 的 &lt;code&gt;xargs&lt;/code&gt; 命令的代码无法通过，看到他的测试方法才知道原来是这样测试的，感觉之前写的测的都太简略了。&lt;/p&gt;
&lt;p&gt;例如测试 &lt;code&gt;xargs&lt;/code&gt; 命令这一关可以这样测试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make GRADEFLAGS=xargs grade
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之前的博客在这里：&lt;a href=&#34;&#34;&gt;MIT6.S081 Lab: Xv6 and Unix Utilities&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;检查了一下我之前的代码，发现完全没有处理多行的情况，在测试的时候就会出现问题。&lt;/p&gt;
&lt;p&gt;偷看一下测试用的脚本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mkdir a
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;echo&lt;/span&gt; hello &amp;gt; a/b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mkdir c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;echo&lt;/span&gt; hello &amp;gt; c/b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;echo&lt;/span&gt; hello &amp;gt; b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;find . b | xargs grep hello
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以对于 &lt;code&gt;find . b&lt;/code&gt; ，它的结果会是三行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./a/b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./c/b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./b
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;管道之后的 xargs 应该执行三次 &lt;code&gt;grep&lt;/code&gt; ，这才是正确的行为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;grep hello ./a/b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;grep hello ./c/b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;grep hello ./b
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是我使用 &lt;code&gt;read()&lt;/code&gt; 处理的时候又发现了新的问题，管道不是行缓冲的，不方便直接读入一行，想要换用 &lt;code&gt;scanf()&lt;/code&gt; 但是 xv6 没有提供，所以只能一个字符一个字符手动处理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/types.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/param.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;user/user.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *argv[]) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1024&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *cmd[MAXARG];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  memset(buf, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1024&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  memset(cmd, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *) * MAXARG);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &amp;lt; argc; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cmd[i-&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;] = argv[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; ch;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *p = buf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; blanked = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; ncmd = argc - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt; (read(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &amp;amp;ch, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;) &amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (ch == &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; || ch == &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\t&amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      *p = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      blanked = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      p += &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (ch == &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (fork() == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        exec(cmd[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;], cmd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        wait(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      memset(buf, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt; buf);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      p = buf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ncmd = argc - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (blanked) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        blanked = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cmd[ncmd] = p;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ncmd += &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      *p = ch;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      p += &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  exit(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>恶补 CPU 知识之 Cache 和 TLB</title>
      <link>https://vaaandark.top/posts/relearning-cpu-2-cache-and-tlb/</link>
      <pubDate>Sun, 18 Feb 2024 21:30:43 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/relearning-cpu-2-cache-and-tlb/</guid>
      <description>&lt;p&gt;即是知识回顾，也是最近学到知识的拓展延伸。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ARMv6 Manual: &amp;ldquo;The only architecturally-guaranteed way to invalidate all aliases of a physical address from a VIPT instruction cache is to invalidate the entire instruction cache.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;cache-的基本情况&#34;&gt;Cache 的基本情况&lt;/h2&gt;
&lt;p&gt;Cache 也就是缓存，作为高速的 CPU 和低速的内存之间的缓冲，用于加速访问。&lt;/p&gt;
&lt;p&gt;一个内存地址一般分为三个部分，由高到低分别为 tag, index 和 offset 。index 用于索引缓存行，offset 用于确定在缓存行的位置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么需要 tag 呢？这是因为缓存的大小是远远小于内存大小的，所以不同的 index 可能对应同一个缓存行，所以需要使用 tag 来区分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;那为什么 tag 是高位，而 index 是低位呢？这是因为一般情况下访问的内存都是若干块连续的，处于不同块的内存地址低位可能重复而高位不重复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有三种 Cache 组织方式，分别是全相连、组相连和直接相连，其中全相连不划分 index ，直接比对 tag 。&lt;/p&gt;
&lt;h2 id=&#34;多级-cache&#34;&gt;多级 Cache&lt;/h2&gt;
&lt;p&gt;为了进一步提升访存速度，人们引入了多级 Cache 。现代 CPU 一般有 3 级，以 Cortex-A53 为例，它的 L1 cache 是 CPU 私有的，L2 cache 是同一个 cluster 共享的，L3 cache 是所有 CPU 共享的，并以总线与内存相连。&lt;/p&gt;
&lt;h2 id=&#34;icachedcache-及其一致性&#34;&gt;icache/dcache 及其一致性&lt;/h2&gt;
&lt;p&gt;在 L1 或者 L2 cache 中，一些 CPU 会将 cache 分为 instruction cache 和 data cache 。这有两个考虑，一是性能，二是成本。本质原因是 CPU 对指令和数据的访问方式不同，指令一般是只读的，不需要把电路设计得非常复杂。&lt;/p&gt;
&lt;p&gt;不过现实还是比较残酷的，很多时候 icache 是不能保证只读，比如 GCC 调试打断点的时候就会修改指令，它先将数据加载到 dcache 中再修改，这时就需要解决 icache 和 dcache 的一致性问题。&lt;/p&gt;
&lt;h2 id=&#34;mmu-和-tlb&#34;&gt;MMU 和 TLB&lt;/h2&gt;
&lt;p&gt;MMU 是 Memory Management Unit ，用于将把虚拟地址转换为物理地址。Linux 中的页表一般是四级的，也可以配置为五级。从高到底分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PGD：page Global directory(47-39), 页全局目录&lt;/li&gt;
&lt;li&gt;PUD：Page Upper Directory(38-30)，页上级目录&lt;/li&gt;
&lt;li&gt;PMD：page middle directory(29-21)，页中间目录&lt;/li&gt;
&lt;li&gt;PTE：page table entry(20-12)，页表项&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这解决了利用少量页面数据管理大量内存的问题，但是也会让一次查询需要在内存中查四次页表，大大降低了访存速度，&lt;strong&gt;所以 MMU 中也需要一个类似 Cache 的存在&lt;/strong&gt;，那就是 TLB 。TLB 的访问速度比 L1 还要快，和寄存器相当。&lt;/p&gt;
&lt;p&gt;由于页面大小一般为 4KB ，因此 TLB 不需要管最低的 12 位。而且 TLB 的一个 entry 只存一个物理地址，所以也不需要类似 cache 的 offset 字段，虚拟地址只需要分成 tag 和 index 两个部分。&lt;/p&gt;
&lt;h2 id=&#34;vivt-vs-vipt-vs-pipt&#34;&gt;VIVT vs VIPT vs PIPT&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的 V 代表 virtual ， P 代表 physical ， I 和 T 分别代表 index(ed) 和 tag(ged) 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面说了通过 tag 和 index 在 cache 中查找，但是这里的 tag 和 index 位于虚拟地址还是物理地址呢？&lt;/p&gt;
&lt;h3 id=&#34;歧义和别名&#34;&gt;歧义和别名&lt;/h3&gt;
&lt;p&gt;我们也可以先注意两个问题：歧义(ambiguity)和别名(aliasing)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;歧义指不同的数据有相同的 tag 和 index ，从而导致无法区别。&lt;/li&gt;
&lt;li&gt;别名指不同的虚拟地址映射相同的物理地址（这在 Linux 中很常见），这容易导致 cache 的数据不一致问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vivt&#34;&gt;VIVT&lt;/h3&gt;
&lt;p&gt;这种 index 和 tag 都取自虚拟地址的方法又叫虚拟高速缓存。在这种情况下，只要 cache 命中，就不需要进行地址翻译，这提升了速度，也设计简单。&lt;/p&gt;
&lt;p&gt;但是这样的设计暂时还不能解决 ambiguity 和 aliasing 问题。&lt;/p&gt;
&lt;p&gt;想要解决 ambiguity ，可以在每次切换进程的时候 flush 所有的 cache ，但是这样又会导致大量的 cache miss 。&lt;/p&gt;
&lt;p&gt;想要解决不同进程的 aliasing ，也可以在每次切换进程的时候 flush 所有的 cache 。&lt;/p&gt;
&lt;p&gt;如果是同一个进程的 aliasing ，就没有很好的办法了。&lt;/p&gt;
&lt;h3 id=&#34;pipt&#34;&gt;PIPT&lt;/h3&gt;
&lt;p&gt;这种 index 和 tag 都取自物理地址的方法又叫物理高速缓存。这样的设计可以让操作系统少操心，完全避免了 ambiguity 和  aliasing 问题。&lt;/p&gt;
&lt;p&gt;虽然 PIPT 在软件层面基本不需要维护，但是硬件设计上比 VIVT 复杂很多，成本也更高。而且由于虚拟地址每次都要先翻译成物理地址，因此在查找性能上低于 VIVT 。&lt;/p&gt;
&lt;h3 id=&#34;vipt&#34;&gt;VIPT&lt;/h3&gt;
&lt;p&gt;在索引 cache 时，可以使用虚拟地址的一部分作为 cache 的inde 。而 cache 的 tag 则使用物理地址中的 PFN （独一无二，后文也会说到）。这种方法的好处是，TLB 翻译得到 PFN 和 index 索引 cache 是同时进行的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;VIPT&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/vipt.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;为什么没有歧义问题&#34;&gt;为什么没有歧义问题？&lt;/h4&gt;
&lt;p&gt;我们可能有种思维惯性， tag 就是地址的一部分，和 index 合在一起才能成为一个低 offset 位为 0 的地址。这种说法在 VIVT 中是对的，但是在 VIPT 中是错的。&lt;strong&gt;tag 本来就是标签的意思，只是用于区分相同 index ，它并不意味着它是减去 index 的那些位。&lt;/strong&gt; 只是在 cache 的查询中， tag 和 index 没有重合而且合起来刚好覆盖了地址中除了 offset 的位。&lt;/p&gt;
&lt;p&gt;现在再看 MMU ，一般情况下 64 位地址只用了低 48 位表示地址，而一个页面一般是 4KB 。这样一来， MMU 只需要将 47 位到 12 位进行地址映射，这和 VIVT 的 index 和 tag 的那些位是不同的。&lt;/p&gt;
&lt;p&gt;既然都使用了 MMU 把虚拟地址的全部位翻译成了物理地址，那么为什么还要取物理地址中和 VIVT 中的 tag 一样的位呢？所以 VIPT 使用这 47 位到 12 位作为 tag ，&lt;strong&gt;这些 tag 是独一无二的&lt;/strong&gt;，可以完全避免 ambiguity 的问题。&lt;/p&gt;
&lt;h4 id=&#34;什么时候没有别名问题&#34;&gt;什么时候没有别名问题？&lt;/h4&gt;
&lt;p&gt;可以发现， VIPT 虽然没有直接解决别名问题，但有些情况下可以避免别名，那就是 cache size 除以路数小于 page 大小时。即 index + offset &amp;lt;= 12bit 不会发生重名，即只要 cache 每一路小于等于 4KB ，就不会发生重名。即 4KB 直接映射、 8KB 两路组相联、 32KB 八路组相联等，都不会有问题。此时 VIPT 的功能和 PIPT 一致，但速度和 VIVT 一致，可以说综合了两者的优点。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;VIPT 没有别名问题的情况&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/vipt-no-aliasing.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是，当 index + offset &amp;gt; 12bit （页面大小为 4KB ）时，对应同一个物理地址的两个虚拟地址可能被分配到两个 cache set 中，就出现了重名现象。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;VIPT 有别名问题的情况&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/vipt-aliasing.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;如果无法避免别名如何解决&#34;&gt;如果无法避免别名，如何解决？&lt;/h4&gt;
&lt;p&gt;很多 CPU 的 L1 dcache 都遵循了上述的 cache 每一路小于 4KB 的规律。但是继续增加 cache size 的同时继续增加相联度会导致过于复杂的时序。此时，我们不得不增大 cacheline 和增加组数，最后导致 index + offset &amp;gt; 4KB 。&lt;/p&gt;
&lt;p&gt;解决办法其实也很简单，可以在操作系统层面上创建共享内存的时候地址要按照一路 cache size 对齐，这样就完全避免了别名问题。这也就是 page coloring 技术。它相当于将一路 cache 按照 page 的大小切分了。&lt;/p&gt;
&lt;p&gt;例如 page size 是 4KB ，而一路 cache size 是 16 KB ，则我们可以将页面按顺序填上 16 / 4 = 4 种颜色，只有颜色相同的虚拟页面才能分配到对应的物理地址上，这也就做到了按照一路 cache size 对齐了。&lt;/p&gt;
&lt;p&gt;对于上例，一些 CPU 的做法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最简单的方法是确保给定虚拟地址的第 12 位和第 13 位（也就是 VPN 的低两位）与相应物理地址中的相同位匹配。即相当于将页面大小改大为 16KB ，这需要 CPU 支持修改 MMU 粒度。&lt;/li&gt;
&lt;li&gt;如果仅使用 4KB 页面，则可以构建保留颜色限制的映射，并允许虚拟地址和物理地址之间的第 12 位和第 13 位不同。这种做法会增加额外的复杂性。&lt;/li&gt;
&lt;li&gt;硬件方法解决，例如 &lt;a href=&#34;https://xiangshan-doc.readthedocs.io/zh-cn/latest/huancun/cache_alias/&#34;&gt;香山架构&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;page coloring&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/page-coloring.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;现代-cpu-的选择&#34;&gt;现代 CPU 的选择&lt;/h2&gt;
&lt;h3 id=&#34;多数的选择&#34;&gt;多数的选择&lt;/h3&gt;
&lt;p&gt;绝大多数 CPU 的 L2 L3 都是 PIPT 的，不同点在于 L1 cache 的设计。&lt;/p&gt;
&lt;p&gt;L1 cache 的 dcache 和 icache 可以采用不同的设计，分别选用 VIPT 或者 PIPT 。很多 CPU 的 L1 dcache 使用的是 PIPT 而 icache 是 VIPT 。&lt;/p&gt;
&lt;h3 id=&#34;少数-vivt-的-l1-设计&#34;&gt;少数 VIVT 的 L1 设计&lt;/h3&gt;
&lt;p&gt;传统上，虚拟地址的缓存有很多缺点：它们会在上下文切换或 TLB 维护操作时被刷新，因为更改虚拟地址到物理地址的映射意味着一个虚拟地址的缓存的内容不再是最新的。&lt;/p&gt;
&lt;p&gt;但是可以通过引入 ASID （标记不同进程）来避免上下文切换时刷新，还可以通过记录 VA 到 PA 的别名来解决别名问题。&lt;/p&gt;
&lt;h3 id=&#34;趣事arm-与-mmap&#34;&gt;趣事：ARM 与 &lt;code&gt;mmap&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;ARMv6 和 ARMv7 执行相同的 &lt;code&gt;mmap&lt;/code&gt; 代码会有不同的结果， v6 会失败，而 v7 会成功：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// Preconditions:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  - fd is a file descriptor as returned from open() (or a related function).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  - The file is at least 4096 bytes long (and so can fill the mapping).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  - The file&amp;#39;s permissions are compatible with those in the mmap calls.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  - MAP_FIXED is supported.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  - The addresses provided can be mapped by the process, and are not
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//    allocated or otherwise reserved or invalid.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; * buffer0 = mmap((&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;*)(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x12340000&lt;/span&gt;), &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4096&lt;/span&gt;, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fd, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; * buffer1 = mmap((&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;*)(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0xdebc1000&lt;/span&gt;), &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4096&lt;/span&gt;, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fd, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码将文件映射到了两种颜色的虚拟地址上，可以看到 0x12340000 的第十二十三位是 00 ，而 0xdebc1000 的第十二十三位是 01 ，这违背了 page coloring 的原则。&lt;/p&gt;
&lt;p&gt;两代架构执行代码的结果不同是因为：v6 的 dcache 是 vipt 的，而 v7 的 dcache 是 pipt 的，所以 v7 不存在别名问题，而 v6 存在。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.eastonman.com/blog/2024/02/hot-chips-2023-ventanas-unconventional-veyron-v1/&#34;&gt;HotChips 2023: Ventana 不寻常的 Veyron V1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiangshan-doc.readthedocs.io/zh-cn/latest/huancun/cache_alias/&#34;&gt;香山官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/page-colouring-on-armv6-and-a-bit-on-armv7&#34;&gt;arm community: Page Colouring on ARMv6 (and a bit on ARMv7)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>恶补 CPU 知识之分支预测</title>
      <link>https://vaaandark.top/posts/relearning-cpu-1-branch-prediction/</link>
      <pubDate>Sun, 18 Feb 2024 12:44:41 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/relearning-cpu-1-branch-prediction/</guid>
      <description>&lt;h2 id=&#34;前因&#34;&gt;前因&lt;/h2&gt;
&lt;p&gt;最近看了一篇介绍 Ventana 的 Veyron V1 核心的博客 &lt;a href=&#34;https://blog.eastonman.com/blog/2024/02/hot-chips-2023-ventanas-unconventional-veyron-v1/&#34;&gt;HotChips 2023: Ventana 不寻常的 Veyron V1&lt;/a&gt; ，里面出现了很多我没听说过或者不甚了解的名词，在阅读这篇博客和查找资料的过程中，我学到了很多新的 CPU 知识。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Veyron V1 的框图&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/veyron.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;btb-是什么&#34;&gt;BTB 是什么？&lt;/h2&gt;
&lt;p&gt;BTB 即分支目标缓冲(Branch Target Buffer)，本质上是 Cache ，通过当前 PC 的一部分进行索引，与 entry 中的 tag 进行比对，输出的是 target address 。&lt;/p&gt;
&lt;p&gt;BTB 解决的是什么问题呢？解决的是如何快速定位跳转地址的问题。但是，跳转的地址一般就在指令中，取出来几乎是无延迟的，那为什么需要快速定位呢？原因在于&lt;strong&gt;分支预测在取指阶段之前&lt;/strong&gt;！只有先做预测才能快速取出多条指令进行译码。&lt;/p&gt;
&lt;h2 id=&#34;2-bit-饱和计数器是什么&#34;&gt;2-bit 饱和计数器是什么？&lt;/h2&gt;
&lt;p&gt;解决了跳转地址的问题还需要解决是否跳转的问题，这个一般叫做 Taken / Not taken ，这也是分支预测的核心。&lt;/p&gt;
&lt;p&gt;分支预测的前提是程序执行顺序有一定的规律，或者说有一定的惯性，所以有人就设计出来了 2-bit 饱和计数器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;之所以叫 2-bit 是因为它有四种状态：strongly taken, weakly taken, weakly not taken, strongly not taken 。每次 actually taken 了，状态就将向左迁移；每次 actually not taken ,状态就将向右迁移。&lt;/li&gt;
&lt;li&gt;之所以叫「饱和」是因为当处于 strongly (not) taken 状态时再 (not) taken 不会再迁移状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;状态迁移图&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/2-bit-counter.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;2-bit 饱和计数器是如今分支预测方案的基础，但是单纯只使用它会导致在一些极端条件下性能很低。举一个很简单的例子 NTNTNTNT&amp;hellip; ，它的准确率只有 50% ，这显然是不可接受的。&lt;/p&gt;
&lt;h2 id=&#34;bhr-是什么局部历史分支预测器是什么&#34;&gt;BHR 是什么？局部历史分支预测器是什么？&lt;/h2&gt;
&lt;p&gt;BHR 即分支历史寄存器(Branch History Register)，它的出现是为了配合 2-bit 饱和计数器来提高预测准确率。&lt;/p&gt;
&lt;p&gt;BHR 是一个 n 位的可以不断左移的寄存器，用于存储 n 次分支跳转结果。&lt;/p&gt;
&lt;p&gt;一个 BHR 对应 2^n 个 2-bit 饱和计数器，这样的一组饱和计数器被称为 Pattern History Table(PHT) 。可以想到，此时的分支预测就是通过 BHR 的值来索引 PHT 的计数器。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;BHR&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/branch-history-register.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;以之前提到的 NTNTNTNT&amp;hellip; 这个极端情况为例，假设 BHR 的宽度为 2 ，它会在 10 和 01 之间交替，分别对应了两个计数器，一个会饱和于 taken ，另一个则会饱和于 not taken 。这样一来就完美解决了之前的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整体的工作流程就是：首先通过 BTB 找到分支 PC ，再通过分支 PC 找到对应的 BHR ，最后通过 BHR 在 PHT 中查找，决定是否 taken 。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;pht2-bit-counter-何时更新&#34;&gt;PHT/2-bit counter 何时更新？&lt;/h3&gt;
&lt;p&gt;现代 CPU 一般都是超标量的，每次可以取出不止一条指令送入流水线中进行乱序执行。为了保证结果的正确性，必须在 commit/retire 阶段更新，此时不会再因为分支预测的错误导致流水线 flush 。&lt;/p&gt;
&lt;p&gt;但是分支预测一般是流水线的第一个阶段， commit/retire 是最后一个阶段。这样一来，预测和更新之间间隔时间过长，在这个间隔时间内这条指令可能已经按照之前的 counter 状态执行多次了，这好像失去了时效性。&lt;strong&gt;但其实不需要担心，这种情况一般发生在循环体很短的情况下，由于饱和计数器的性质，它在几次后就会成为 strongly taken 状态，由于已经饱和，不及时更新也没有关系。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;bhr-何时更新&#34;&gt;BHR 何时更新？&lt;/h3&gt;
&lt;p&gt;一般情况下 BHR 的更新也是在 commit/retire 阶段的。这也是因为如果在其他阶段会遇到正确性问题，需要额外开销来恢复（或者说修正）。&lt;/p&gt;
&lt;p&gt;BHR 同样不用担心间隔时间过长，原因和上面的 PHT 一样。&lt;/p&gt;
&lt;h2 id=&#34;ghr-是什么全局历史分支预测器是什么&#34;&gt;GHR 是什么？全局历史分支预测器是什么？&lt;/h2&gt;
&lt;p&gt;这一设计的假设是分支的结果之间互相关联，这在我们日常写的代码中有很多体现，显然是很有道理的。&lt;/p&gt;
&lt;p&gt;这样就只需要一个 Global Branch History Register ，记录所有分支在过去的执行结果。&lt;/p&gt;
&lt;h3 id=&#34;ghr-何时更新&#34;&gt;GHR 何时更新？&lt;/h3&gt;
&lt;p&gt;GHR 应当在分支预测后更新，因为两个邻近的分支指令会间隔很短的时间进入流水线，GHR 如果不在分支预测后更新便失去了意义，违反了「分支的结果之间相互关联」的假设。&lt;/p&gt;
&lt;p&gt;分支预测错误了，但是后续的分支指令使用了错误的 GHR 怎么办呢？&lt;strong&gt;不用管，因为后续的指令都应该被流水线 flush 掉。&lt;/strong&gt; 不过，还是需要额外的开销来恢复 GHR 。&lt;/p&gt;
&lt;h3 id=&#34;aliasing-pht-是什么问题&#34;&gt;Aliasing PHT 是什么问题？&lt;/h3&gt;
&lt;p&gt;由于所有的分支使用同一个 PHT ，因此容易出现不同分支指向同一个 PHT entry 的问题。解决方案有很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最简单的方法是增大 PHT ，使用 PC 中更多位来寻找 entry ，这会增加面积和功耗。&lt;/li&gt;
&lt;li&gt;还有就是使用 hashing/index-randomization ，比如 Tage(TAgged GEometric history length)，最简单的方法是将 GHR 和 PC 进行异或操作后再寻址，&lt;a href=&#34;https://xiangshan-doc.readthedocs.io/zh-cn/latest/frontend/bp/#ubtb&#34;&gt;香山架构&lt;/a&gt;就使用的是这个方法。以此思想还有很多 hash 设计来防止碰撞。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;warmuptraining-time-是什么&#34;&gt;Warmup/Training time 是什么？&lt;/h3&gt;
&lt;p&gt;PHT entry的计数器达到饱和状态的时间称为 training time ，它和 BHR/GHR 的长度有关，较长的 BHR/GHR 需要更多的时间 warmup ，但也会记录更多的历史信息，提高预测准确度。较短的 BHR/GHR 不能记录分支的所有结果。&lt;/p&gt;
&lt;p&gt;现代 CPU 很多都是超标量的，下一条分支指令开始预测时上一条分支指令可能还远远没有执行结束。为了尽快拿到分支历史，大部分分支预测机制都会选择「推测更新历史」，也就是上文中说到的在分支预测后立即更新 GHR 。&lt;/p&gt;
&lt;h2 id=&#34;全局历史分支预测--局部历史分支预测&#34;&gt;全局历史分支预测 &amp;gt; 局部历史分支预测？&lt;/h2&gt;
&lt;p&gt;记得之前说过全局分支预测只需要一个 GHR 而局部分支预测需要一组 BHR 吗？&lt;strong&gt;这会引起存储介质选择的问题，一个 GHR 再怎么长都可以直接用寄存器存，而一组通过 PC 索引的 BHR 表相对较大，只能用和缓存一样的 SRAM 来存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 SRAM 来存的问题在于，恢复历史时无法在一拍内恢复或者甚至无法在短时间内恢复。这种维护的困难使得局部历史在现代处理器的分支预测器中很少见到。&lt;/p&gt;
&lt;h3 id=&#34;更高级的分支预测机制&#34;&gt;更高级的分支预测机制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;将局部和全局历史分支预测结合 &lt;a href=&#34;https://link.zhihu.com/?target=https%3A//www.csee.umbc.edu/portal/help/architecture/alpha21264a.pdf&#34;&gt;The Alpha 21264 Microprocessor Architecture&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;预测循环，即使用通过计数避免最后一次循环预测错误。&lt;/li&gt;
&lt;li&gt;引入机器学习的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/486239354&#34;&gt;知乎问题：现代中央处理器（CPU）是怎样进行分支预测的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.eastonman.com/blog/2024/02/hot-chips-2023-ventanas-unconventional-veyron-v1/&#34;&gt;HotChips 2023: Ventana 不寻常的 Veyron V1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.eastonman.com/blog/2023/12/modern-branch-prediction-from-academy-to-industry/&#34;&gt;现代分支预测：从学术界到工业界&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiangshan-doc.readthedocs.io/zh-cn/latest/frontend/bp/&#34;&gt;香山官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inf.pucrs.br/~calazans/graduate/SDAC/saltos.pdf&#34;&gt;Two-Level Adaptive Training Branch Prediction&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Pthread</title>
      <link>https://vaaandark.top/posts/pthread/</link>
      <pubDate>Sat, 23 Dec 2023 22:03:25 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/pthread/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;赛博考古：Linux 支持 POSIX 线程标准的前世今生&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;线程是什么&#34;&gt;线程是什么&lt;/h2&gt;
&lt;p&gt;操作系统能够进行运算调度的最小单位。在一般的操作系统上，它被包含在进程之中，是进程中的实际运作单位。&lt;/p&gt;
&lt;h3 id=&#34;线程共享了什么&#34;&gt;线程共享了什么&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;代码段、数据段、堆&lt;/li&gt;
&lt;li&gt;文件描述符&lt;/li&gt;
&lt;li&gt;进程信息（如 pid ）、用户 id 和组 id&lt;/li&gt;
&lt;li&gt;Signal Handle&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程没有共享什么&#34;&gt;线程没有共享什么&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;寄存器&lt;/li&gt;
&lt;li&gt;线程优先级和调度策略&lt;/li&gt;
&lt;li&gt;TLS(Thread Local Storage)（线程局部存储）&lt;/li&gt;
&lt;li&gt;tid(可以使用 &lt;code&gt;syscall(SYS_gettid)&lt;/code&gt; 查看)&lt;/li&gt;
&lt;li&gt;Signal Mask&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;值得注意的问题pid-vs-tgid-getpid-vs-gettid&#34;&gt;值得注意的问题(pid vs tgid, getpid vs gettid)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;tg for thread group&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;getpid&lt;/code&gt; 是 man 3 里面的，因此它是 Library call ；&lt;code&gt;gettid&lt;/code&gt; 是 man 2 里面的，因此它是 System Call 。&lt;/p&gt;
&lt;p&gt;我们使用 &lt;code&gt;unistd.h&lt;/code&gt; 中的 &lt;code&gt;getpid()&lt;/code&gt; 实际上获取的是 tgid ，而 &lt;code&gt;syscall(SYS_gettid)&lt;/code&gt; 实际上获取的是 pid 。&lt;/p&gt;
&lt;p&gt;如图所示，每个线程都有独一无二的 pid ，有可能重复的 tgid 。当一个进程属于一个单线程程序时，它的 pid 就等于 tgid ；当它创建了一个线程时，新的线程拥有一个新的 pid ，同时继承了同一线程组的 tgid 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         USER VIEW
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;-- PID 43 --&amp;gt;|&amp;lt;----------------- PID 42 -----------------&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              |      +---------+          |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              |      | process |          |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              |     _| pid=42  |_         |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         __(fork) _/ | tgid=42 | \_ (new thread) _
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        /     |      +---------+          |       \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;+---------+   |                           |    +---------+
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| process |   |                           |    | process |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| pid=43  |   |                           |    | pid=44  |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| tgid=43 |   |                           |    | tgid=42 |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;+---------+   |                           |    +---------+
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;-- PID 43 --&amp;gt;|&amp;lt;--------- PID 42 --------&amp;gt;|&amp;lt;--- PID 44 ---&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        KERNEL VIEW
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;posix-thread&#34;&gt;POSIX Thread&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;与其说是 pthread 的历史，不如说是 kernel 变得更大更强，对线程模型支持得更好的历史。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;LinuxThreads（早期）&lt;/li&gt;
&lt;li&gt;NPTL(Native POSIX Thread Library)（现在）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看你的 pthread 实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ getconf GNU_LIBPTHREAD_VERSION
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NPTL 2.38
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;linuxthreads&#34;&gt;LinuxThreads&lt;/h3&gt;
&lt;p&gt;在 Linux 操作系统中， LinuxThreads 是 1996 年推出的 POSIX Threads 的部分实现，其主要开发者是 Xavier Leroy 。&lt;/p&gt;
&lt;h4 id=&#34;管理线程manager-thread&#34;&gt;管理线程(Manager Thread)&lt;/h4&gt;
&lt;p&gt;为什么需要管理线程？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对致命的信号做出反应(fatal signals)，并杀死或终止整个线程。（后文详细说明这一点的原因，这是由 LinuxThreads 的缺陷导致的）&lt;/li&gt;
&lt;li&gt;释放用作线程栈的内存不能由该线程本身执行，必须要等这个线程结束再进行，因此需要特殊的管理线程来收尾。&lt;/li&gt;
&lt;li&gt;释放 tls 需要遍历所有线程，因此需要管理线程。&lt;/li&gt;
&lt;li&gt;终止线程必须是等待的（由管理线程等待），不然会出现僵尸线程。&lt;/li&gt;
&lt;li&gt;当主线程调用 &lt;code&gt;pthread_exit()&lt;/code&gt; 时，这个进程不能就此结束。正确的行为是，主线程 sleep ，当其他线程被杀死后管理线程再唤醒主线程，主线程此时才能退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缺陷&#34;&gt;缺陷&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;管理线程带来的额外开销。&lt;/li&gt;
&lt;li&gt;使用信号实现同步原语。&lt;/li&gt;
&lt;li&gt;基本符合 POSIX 标准，信号处理除外。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LinuxThreads 实现的线程，本质上是共享了内存、文件描述符的进程，它们有着不同的 pid ，它们并不作为进程的一个整体：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的 pid 是抽象概念，当时的 Kernel 并没有 pid 和 tgid 的区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;发送到线程 pid 的信号只能由该线程处理。只要没有线程阻塞该信号，该行为就符合标准：程序的一个（未指定）线程处理该信号。&lt;/li&gt;
&lt;li&gt;但是，如果向 pid 发送信号的线程阻塞了信号，那么 LinuxThreads 将简单地在该线程中排队，仅当该线程解除阻塞信号时才执行处理程序，而不是立即在不阻塞信号的另一个线程中执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现者的吐槽：This is to be viewed as a LinuxThreads bug, but I currently don&amp;rsquo;t see any way to implement the POSIX behavior without kernel support.&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;线程模型&#34;&gt;线程模型&lt;/h4&gt;
&lt;p&gt;此时就已经出现了 Linux 代表性的一对一(one-to-one)模型。内核对线程和进程不做区分，所谓的内核线程是 &lt;code&gt;task_struct&lt;/code&gt; ，而内核调度时也只考虑它们。&lt;/p&gt;
&lt;h5 id=&#34;one-to-one-vs-many-to-one&#34;&gt;one-to-one vs many-to-one&lt;/h5&gt;
&lt;p&gt;当用户创建出很多用户线程时， Linux 的做法是：每当用户调用库函数创建线程，库函数让内核创建出一个新的内核线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多处理器上，CPU 密集型程序的开销最小，即每个处理器上都可以跑一个线程（思考一下如果是 many-to-one ，一个内核线程对应多个用户线程，则很难在多核上并行）。&lt;/li&gt;
&lt;li&gt;I/O 操作开销最小（思考一下如果是 many-to-one ，阻塞 IO 操作实现起来有多么复杂）。&lt;/li&gt;
&lt;li&gt;实现简单，不与内核过度耦合（内核调度可以完成大部分复杂工作）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;one-to-one-vs-many-to-many&#34;&gt;one-to-one vs many-to-many&lt;/h5&gt;
&lt;p&gt;那么为什么不用多对多模型呢？&lt;/p&gt;
&lt;p&gt;当时大多数商业 Unix 系统（Solaris、Digital Unix、IRIX）都以这种方式实现 POSIX 线程。该模型结合了“多对一”和“一对一”模型的优点，很有吸引力。&lt;/p&gt;
&lt;p&gt;多对多模型能成功避免两种模型的最坏情况。在上下文切换成本高昂的内核 Digital Unix 上多对多模型几乎可以说是唯一选择。&lt;/p&gt;
&lt;p&gt;但是，多对多模型的实现相当复杂，并且需要 Linux 增加支持很多新的功能。另一方面，Linus Torvalds 和其他 Linux 内核开发人员一直以整体简单性的名义推动一对一模型，更何况 Linux 的上下文切换效率相当出色。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然多对多模型在 pthread 中被放弃，但是它在一些编程语言的运行时中大放异彩。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;管理线程与一对一模型结合导致的问题&#34;&gt;管理线程与一对一模型结合导致的问题&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;管理线程只能在一个核上运行，这导致加速比变低，性能变差。&lt;/li&gt;
&lt;li&gt;由于整个系统围绕着管理线程设计，上下文切换开销变大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nptl&#34;&gt;NPTL&lt;/h3&gt;
&lt;p&gt;为了解决 LinuxThreads 的一些问题，内核开发人员设计实现了 NPTL(Native POSIX Thread Library) 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NPTL 完全兼容 POSIX 标准。&lt;/li&gt;
&lt;li&gt;NPTL 在多处理器机器上效果也很好。&lt;/li&gt;
&lt;li&gt;NPTL 的启动开销不大。&lt;/li&gt;
&lt;li&gt;NPTL 也能利用到 NUMA 架构的优势。&lt;/li&gt;
&lt;li&gt;NPTL 和 LinuxThreads 二进制兼容（LD 实现的）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;利用了新的内核特性&#34;&gt;利用了新的内核特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;NPTL 无需管理线程：
&lt;ul&gt;
&lt;li&gt;不需要转发 fatal signal 的工作，内核可以处理好向某一进程发送信号的工作。&lt;/li&gt;
&lt;li&gt;不需要由管理线程析构，内核可以处理线程内存的释放。&lt;/li&gt;
&lt;li&gt;不需要管理线程来避免僵尸线程，内核可以在清理父线程前等待所有线程。&lt;/li&gt;
&lt;li&gt;去掉管理线程，对 SMP 和 NUMA 更友好。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 &lt;em&gt;futex&lt;/em&gt; 来实现同步，而且 futex 可以在进程间共享，能在更多场景使用。&lt;/li&gt;
&lt;li&gt;NPTL 的每个线程都有自己的父线程，在进行资源统计时便于统计整个进程，此前的 LinuxThreads 不能做到。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;如何实现-tls&#34;&gt;如何实现 TLS&lt;/h4&gt;
&lt;p&gt;我们都知道在写声明时加入 &lt;code&gt;__thread&lt;/code&gt; 可以声明一个线程局部变量。那它是如何实现的呢？&lt;/p&gt;
&lt;p&gt;在早期 LinuxThreads 的实现中， TLS 直接放在线程栈旁边。而在引入 NPTL 后，各个 libc （如 glibc, uClibc, musl）都是使用新增的 ELF 标准对 TLS 的支持和动态链接器来实现的。&lt;/p&gt;
&lt;p&gt;查看一个 &lt;code&gt;__thread&lt;/code&gt; 声明的汇编代码时，我们可能看到 &lt;code&gt;mov %fs:0xfffffffffffffffc,%eax&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这也就是 &lt;code&gt;mov %fs:-4,%eax&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这是什么？这太奇怪了！&lt;/p&gt;
&lt;p&gt;虽然某些 CPU 架构有专用的寄存器来保存线程特定的上下文，但 x86 没有。众所周知，x86 只有少量的通用寄存器。&lt;/p&gt;
&lt;p&gt;英特尔 80386 引入了 FS 和 GS 作为用户定义的段寄存器，但没有规定它们的用途。然而，随着多线程编程的兴起，人们看到了重新利用 FS 和 GS 的机会，并开始将它们用作线程寄存器。&lt;/p&gt;
&lt;p&gt;TLS 的结构：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;tls&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/tls.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;dlopen&lt;/code&gt; 加载的 DSO(动态共享对象) 放在动态 TLS 中，其余的放在静态 TLS 中。&lt;/li&gt;
&lt;li&gt;$dtv_t$ 可以看作是一个二维数组，可以通过模块 id 和偏移量对任何 TLS 变量进行寻址。TLS 变量偏移量是模块中的本地偏移量，模块 id 是进程中加载的 ELF 对象的索引号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;访问一个 TLS 变量的通用方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dtv[-&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;].counter; &lt;span style=&#34;color:#007f7f&#34;&gt;/* Pro tip: The length of this dtv array */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dtv[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;].counter;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* Generation counter for the DTV in this thread */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dtv[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;].pointer;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* Pointer to the main executable TLS block in this thread */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;/* Pointer to a TLS variable defined in a module id `ti_module` */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;main_tls_var = *(dtv[tls_index.ti_module].pointer + tls_index.ti_offset);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译器和动态链接器共同计算出地址，因为可执行文件的 TLS 块和 TLS 偏移量都是提前知道的。&lt;/p&gt;
&lt;p&gt;这种合作依赖于编译器在构建时的以下「事实」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FS 寄存器指向 TCB 。&lt;/li&gt;
&lt;li&gt;编译器设置的 TLS 变量偏移量在运行时不会更改。&lt;/li&gt;
&lt;li&gt;可执行文件的 TLS 块位于 TCB 之前。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时，将 TLS 放在 TCB 之前可以让经常被访问的内存更持久地留在缓存中。&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lix.polytechnique.fr/~liberti/public/computing/parallel/threads/linuxthreads/linuxthreads-FAQ.html&#34;&gt;LinuxThreads Frequently Asked Questions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://comet.lehman.cuny.edu/jung/cmp426697/NPTL.pdf&#34;&gt;Linux threading models compared: LinuxThreads and NPTL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cs.utexas.edu/~witchel/372/lectures/POSIX_Linux_Threading.pdf&#34;&gt;NPTL design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kernel.org/doc/ols/2006/ols2006v1-pages-409-420.pdf&#34;&gt;uClibc NPTL design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.akkadia.org/drepper/tls.pdf&#34;&gt;ELF Handling for Thread-Local Storage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://maskray.me/blog/2021-02-14-all-about-thread-local-storage&#34;&gt;All about thread-local storage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chao-tic.github.io/blog/2018/12/25/tls&#34;&gt;A Deep dive into (implicit) Thread Local Storage&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>为什么 Rust std fs 慢于 Python</title>
      <link>https://vaaandark.top/posts/rust-slower-than-python/</link>
      <pubDate>Thu, 30 Nov 2023 16:45:58 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/rust-slower-than-python/</guid>
      <description>&lt;p&gt;看到了 &lt;a href=&#34;https://github.com/Xuanwo/&#34;&gt;xuanwo&lt;/a&gt; 的一篇 &lt;a href=&#34;https://xuanwo.io/2023/04-rust-std-fs-slower-than-python/&#34;&gt;博客&lt;/a&gt;，感觉很有意思。&lt;/p&gt;
&lt;p&gt;完整读一遍也可以，不过也可以看我的省流。&lt;/p&gt;
&lt;h2 id=&#34;python-io-比-c--rust-io-更快&#34;&gt;Python IO 比 C / Rust IO 更快&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;有人发现在 AMD Ryzen 9 5900X 和 AMD Ryzen 7 5700X 上访问页对齐的前10个 byte 会比其他偏移有更多的 L1 prefetch 和 load 的 miss 。&lt;/li&gt;
&lt;li&gt;学过 x86 汇编的应该知道不同于 RISC ，x86 是有专门用于复制字符串的指令的。有人发现上述问题的底层原因来自于 AMD 对 FSRM(Fast Short REP MOV) 的实现，&lt;strong&gt;逆天的是在 Zen 3 上，访问页对齐的数据比不对齐慢&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;更有趣的事情&#34;&gt;更有趣的事情&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;作者发现将 C 的分配器换成 jemalloc 后速度就可以击败 Python 了，我个人猜测可能是 mmap 后分配的页对齐的内存使用了更多（也就是大于 glibc 的 10 byte）来存 meta data ，恰巧避免了这个硬件 bug 。&lt;/li&gt;
&lt;li&gt;有人使用 eBPF profile 发现 Rust 和 Python 的 fs read 在系统调用的延迟上存在差距，Rust 更慢。&lt;/li&gt;
&lt;li&gt;为了解决这个奇怪的性能问题，作者（开源大手子漩涡）和他的开源伙伴（包括了热心网友、国内开源大佬依云和一些内核开发者）使用了 strace, perf, eBPF 等各种性能分析工具，以及分析了各种可能导致性能问题的原因（内存大页、CPU 核亲和性、mmap 分配匿名内存、Linux 启动选项例如 Enable Mitigations、系统调用延迟等）。&lt;/li&gt;
&lt;li&gt;有 &lt;a href=&#34;https://github.com/Enter-tainer&#34;&gt;朋友&lt;/a&gt; 告诉我「Intel 前几天刚出了 &lt;code&gt;rep mov&lt;/code&gt; 导致的 Dos 漏洞」。&lt;/li&gt;
&lt;li&gt;好消息是 FSRM 是微码实现，也许在未来的某一次更新就修好了🥰。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;相关链接&#34;&gt;相关链接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bugs.launchpad.net/ubuntu/+source/glibc/+bug/2030515&#34;&gt;Terrible memcpy performance on Zen 3 when using rep movsb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Cargo Runner</title>
      <link>https://vaaandark.top/posts/cargo-runner/</link>
      <pubDate>Sun, 22 Oct 2023 11:36:13 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/cargo-runner/</guid>
      <description>&lt;p&gt;最近在完成一个使用 Rust 语言编写 Linux 内核引导程序的项目 &lt;a href=&#34;github.com/vaaandark/lboot&#34;&gt;lboot&lt;/a&gt; ，其核心代码和原理在之前的博客中介绍过 &lt;a href=&#34;https://vaaandark.top/posts/how-uefi-startup-linux/&#34;&gt;UEFI 如何启动 Linux&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;因为不可能直接在 UEFI 环境下进行代码开发，所以我使用的是交叉编译的方法，目标平台是 &lt;code&gt;x86_64-unknown-uefi&lt;/code&gt; 和 &lt;code&gt;aarch64-unknown-uefi&lt;/code&gt; 。这就带来了一个问题，使用命令 &lt;code&gt;cargo run&lt;/code&gt; 不能直接运行代码，必须使用 qemu 来模拟目标架构的执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;真的不行吗？其实是可以的🥳🥳🥳&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在翻阅 Cargo Book 之后发现，在&lt;a href=&#34;https://doc.rust-lang.org/cargo/reference/config.html?#command-line-overrides&#34;&gt;命令行重载&lt;/a&gt;这一章中写到可以使用 &lt;code&gt;runner&lt;/code&gt; 字段来定义自己的 &lt;code&gt;cargo run&lt;/code&gt; 行为。&lt;/p&gt;
&lt;p&gt;当执行 &lt;code&gt;cargo run&lt;/code&gt; 时，cargo 会首先将这个 &lt;code&gt;runner&lt;/code&gt; 字段中的命令末尾附上构建出的可执行文件的路径（相当于把路径传入 runner 脚本或命令），然后执行这个命令。&lt;/p&gt;
&lt;p&gt;所以我编写了一个&lt;a href=&#34;https://github.com/vaaandark/lboot/blob/dev/test/qemu_run.sh&#34;&gt;包装脚本&lt;/a&gt; ，它接受两个参数，第一个是目标平台，第二个是 UEFI 可执行文件的路径。然后编写 &lt;code&gt;.cargo/config.toml&lt;/code&gt; 文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[target.x86_64-unknown-uefi]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;runner = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;test/qemu_run.sh x86_64&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[target.aarch64-unknown-uefi]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;runner = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;test/qemu_run.sh aarch64&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;runner&lt;/code&gt; 字段只写一个参数是因为，&lt;code&gt;cargo run&lt;/code&gt; 时可执行文件路径会附加到最后。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在就可以直接 &lt;code&gt;cargo run&lt;/code&gt; 启动 qemu 仿真了！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>UEFI 如何启动 Linux</title>
      <link>https://vaaandark.top/posts/how-uefi-startup-linux/</link>
      <pubDate>Sat, 30 Sep 2023 19:59:34 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/how-uefi-startup-linux/</guid>
      <description>&lt;p&gt;之前讲到了 Linux 是如何启动的，现在就写一个 UEFI 程序可以启动 Linux ，语言选择的是非常火热的 Rust 。&lt;/p&gt;
&lt;p&gt;Linux Kernel 经过了这么多年的发展，其实完全有着 boot 的能力，使用 UEFI 启动 Kernel 其实是非常简单的一件事情，不再需要像以前 BIOS 启动老版本内核一样要把内核加载到某个内存地址，把参数放到某个内存地址，再将这个地址放到寄存器中等等复杂操作。&lt;/p&gt;
&lt;h2 id=&#34;制作-kernel-镜像&#34;&gt;制作 Kernel 镜像&lt;/h2&gt;
&lt;p&gt;启动 Linux 之前我们首先需要一个 Linux Kernel 的镜像。&lt;/p&gt;
&lt;p&gt;首先从 kernel.org 上拉取最新的 release Linux 6.5.5 ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ wget &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.5.5.tar.xz&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ tar -xf linux-6.5.5.tar.xz
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;cd&lt;/span&gt; linux-6.5.5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再配置一下编译选项，要把内核编译成一个 EFI 格式的可执行文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make menuconfig
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;找到并进入 &amp;ldquo;Processor type and features&amp;rdquo; ，并勾选 &amp;ldquo;EFI stub support&amp;rdquo; ，。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前的 Kernel 中 &amp;ldquo;EFI stub support&amp;rdquo; 是默认勾选，只是为了确认一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后就可以编译了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make -j &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;$(&lt;/span&gt;nproc&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完成之后可以看到在 &lt;code&gt;arch/x86/boot/&lt;/code&gt; 下有个 &lt;code&gt;bzImage&lt;/code&gt; ，这就是编译出来的内核：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ file arch/x86/boot/bzImage
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;arch/x86/boot/bzImage: Linux kernel x86 boot executable bzImage, version 6.5.5 (vandark@hustcpu01) #2 SMP PREEMPT Fri Sep 29 02:03:58 CST 2023, RO-rootFS, swap_dev 0xB, Normal VGA
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;构建-initramfs-和-rootfs&#34;&gt;构建 initramfs 和 rootfs&lt;/h2&gt;
&lt;p&gt;只是想要启动看看效果的话其实只需要复制 &lt;code&gt;/boot/initramfs-linux.img&lt;/code&gt; 到 &lt;code&gt;esp/efi/boot&lt;/code&gt; 中就可以了，这样的话能够进入一个使用内存当作磁盘的 Linux 环境中，但这也足以验证 Linux 的成功启动了。&lt;/p&gt;
&lt;h2 id=&#34;编写-rust-uefi-代码&#34;&gt;编写 Rust UEFI 代码&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#![no_main]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#![no_std]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;crate&lt;/span&gt; alloc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;use&lt;/span&gt; alloc::vec::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Vec&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;use&lt;/span&gt; log::info;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;use&lt;/span&gt; uefi::prelude::*;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;use&lt;/span&gt; uefi::proto::device_path::build::media::FilePath;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;use&lt;/span&gt; uefi::proto::device_path::build::DevicePathBuilder;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;use&lt;/span&gt; uefi::proto::device_path::{DevicePath, DeviceSubType, DeviceType, LoadedImageDevicePath};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;use&lt;/span&gt; uefi::proto::loaded_image::LoadedImage;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;use&lt;/span&gt; uefi::table::boot::LoadImageSource;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;use&lt;/span&gt; uefi::{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    entry,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    table::{Boot, SystemTable},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Handle,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#[entry]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; main(image_handle: Handle, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; st: SystemTable&amp;lt;Boot&amp;gt;) -&amp;gt; Status {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    uefi_services::init(&amp;amp;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; st).unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; bt = st.boot_services();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    info!(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Start booting...&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; storage = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Vec&lt;/span&gt;::new();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; kernel_image_path = get_kernel_device_path(bt, &amp;amp;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; storage);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; kernel_image_handle = bt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .load_image(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            image_handle,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            LoadImageSource::FromDevicePath {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                device_path: kernel_image_path,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                from_boot_manager: false,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .expect(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;failed to load kernel&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// 加载 kernel image
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; kernel_loaded_image = bt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .open_protocol_exclusive::&amp;lt;LoadedImage&amp;gt;(kernel_image_handle)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .expect(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;failed to open LoadedImage protocol&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// 设置参数，只设置了 initrd 没有设置 root
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; load_options = cstr16!(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;r&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;initrd=efi\boot\initramfs-linux.img&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsafe&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        kernel_loaded_image.set_load_options(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            load_options.as_ptr().cast(),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            load_options.num_bytes() &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u32&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        );
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// 启动 kernel image
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bt.start_image(kernel_image_handle).expect(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;failed to launch kernel&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Status::SUCCESS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; get_kernel_device_path&amp;lt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt;&amp;gt;(bt: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;BootServices, storage: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt; mut &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Vec&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u8&lt;/span&gt;&amp;gt;) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt; DevicePath {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; loaded_image_device_path = bt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .open_protocol_exclusive::&amp;lt;LoadedImageDevicePath&amp;gt;(bt.image_handle())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .expect(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;failed to open LoadedImageDevicePath protocol&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; builder = DevicePathBuilder::with_vec(storage);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; node &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;in&lt;/span&gt; loaded_image_device_path.node_iter() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; node.full_type() == (DeviceType::MEDIA, DeviceSubType::MEDIA_FILE_PATH) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        builder = builder.push(&amp;amp;node).unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    builder = builder
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .push(&amp;amp;FilePath {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            path_name: cstr16!(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;r&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;efi\boot\bzImage.efi&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    builder.finalize().unwrap()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 qemu 环境中运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ mkdir -p esp/efi/boot
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cp target/x86_64-unknown-uefi/debug/boot.efi esp/efi/boot/bootx64.efi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cp bzImage esp/efi/boot/bzImage.efi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cargo build --target x86_64-unknown-uefi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-system-x86_64 -enable-kvm &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&lt;/span&gt;    -m 1G \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    -hda disk.qcow2 \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    -serial stdio \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    -drive if=pflash,format=raw,readonly=on,file=OVMF_CODE.fd \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    -drive if=pflash,format=raw,readonly=on,file=OVMF_VARS.fd \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    -drive format=raw,file=fat:rw:esp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;OVMF 是为虚拟机开启 UEFI 支持的工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;运行结果&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/boot.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;好耶！成功引导启动了 Linux ！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux ，启动！</title>
      <link>https://vaaandark.top/posts/linux-startup/</link>
      <pubDate>Sat, 09 Sep 2023 08:15:06 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/linux-startup/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;pull oneself up by one&amp;rsquo;s bootstraps.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;拽着鞋带把自己拉起来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家在安装 Arch Linux 或者其他 Linux 发行版时，可能会看到很多有关启动或者引导的名词，例如 BIOS 、UEFI 、GRUB 、ESP 、GPT 、LBA 、MBR 等等。有些名词比较熟悉，有些就会一头雾水，今天就来讲讲这些名词。&lt;/p&gt;
&lt;h2 id=&#34;bios-vs-uefi&#34;&gt;BIOS vs UEFI&lt;/h2&gt;
&lt;p&gt;BIOS（Basic Input Output System，基本输入输出系统）是固化在计算机主板中的程序代码，其主要功能是在计算机上电时对硬件进行初始化配置，并将硬件操作封装为BIOS中断服务。这样，各种硬件间的差异便由 BIOS 负责维护，程序直接调用 BIOS 中断服务即可实现对硬件的控制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加电自检程序，在开机时负责检测硬件设备是否正常工作&lt;/li&gt;
&lt;li&gt;系统初始化程序，其中包括硬件设备的初始化以及创建 BIOS 中断向量等&lt;/li&gt;
&lt;li&gt;适配外围即插即用设备&lt;/li&gt;
&lt;li&gt;CMOS 设置程序，负责读写保存在 CMOS 中的系统设置信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UEFI（Unified Extensible Firmware Interface，统一可扩展固件接口）则是一种规范，它描述了操作系统和平台固件之间的接口，其目的是为操作系统和平台固件定义一种通信方法。在 UEFI 中，设备的访问是通过句柄（Handle）和协议（Protocol）抽象出来的。UEFI 通过将基础实现隔离在规范之外，以避免给设备的访问者带来负担，进而促进现有 BIOS 代码的重用。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;uefi 组成结构&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/uefi.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;bios-启动&#34;&gt;BIOS ，启动！&lt;/h3&gt;
&lt;p&gt;在系统上电后，CPU 运行于实模式工作环境中，数据位宽为 16 位，最大物理地址寻址范围是 0&lt;del&gt;1 MB，其中的物理地址 0x0C0000&lt;/del&gt;0x0FFFFF 保留给 BIOS 使用。开机后， CPU 首先跳转到物理地址 0x0FFFF0 处执行程序。一般情况下，这里是一条跳转指令， CPU 通过执行此处的跳转指令跳转到真正的 BIOS 入口地址处执行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BIOS代码首先做的是 POST（Power On Self Test，加电自检）操作，主要是检测关键设备是否正常工作，设备设置是否与CMOS中的设置一致。如果发现硬件错误，则通过喇叭报警&lt;/li&gt;
&lt;li&gt;初始化显示设备并显示显卡信息，接着初始化其他设备&lt;/li&gt;
&lt;li&gt;检测CPU和内存并显示检测结果&lt;/li&gt;
&lt;li&gt;检测标准设备，例如硬盘、光驱、串口设备、并口设备等&lt;/li&gt;
&lt;li&gt;检测即插即用设备，并为这些设备分配中断号、 I/O 端口和 DMA 通道等资源&lt;/li&gt;
&lt;li&gt;如果硬件配置发生变化，那么这些变化的配置将更新到 CMOS 中&lt;/li&gt;
&lt;li&gt;根据配置的启动顺序引导设备启动，通过BIOS中断将设备的引导程序入内存&lt;/li&gt;
&lt;li&gt;将处理器的控制权交给引导程序，最终引导进入操作系统&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;uefi-启动&#34;&gt;UEFI ，启动！&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;uefi 启动流程&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/uefi-stages.png&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;验证阶段（Security，SEC）。系统上电后，CPU 开始执行第一条指令，此时系统就进入 SEC 阶段。这个阶段的内存尚未被初始化，不可使用。所以， SEC 阶段最主要的工作是建立一些临时内存并将 CPU 切换到保护模式，这里提到的临时内存可以是处理器的缓存，亦或者系统的物理内存。&lt;/li&gt;
&lt;li&gt;EFI 环境预初始化阶段（Pre-EFI Initialization Environment，PEI）。PEI 阶段最主要的工作就是对内存、CPU 以及芯片组等关键设备进行初始化。由于这部分代码没有进行压缩，因此代码必须越精简越好。而且，在PEI阶段还要确定操作系统的引导路径，初始化 UEFI 驱动和固件需要的内存。&lt;/li&gt;
&lt;li&gt;驱动运行环境阶段（Driver Execution Environment，DXE）。DXE 是 EFI 最重要的阶段，大部分的驱动、固件加载工作都是在这个阶段完成的。&lt;/li&gt;
&lt;li&gt;引导设备选择阶段（Boot Device Select，BDS）。BDS 阶段的主要工作是初始化控制台设备的环境变量，尝试加载环境变量列表中记录的驱动，并尝试从环境变量列表中记录的启动设备中启动。&lt;/li&gt;
&lt;li&gt;临时系统运行阶段（Transient System Load，TSL）。这个阶段将进入 UEFI 的临时 Shell 系统环境。&lt;/li&gt;
&lt;li&gt;运行时阶段（RunTime，RT）。当操作系统调用 &lt;code&gt;EFI_BOOT_SERVICES.ExitBootServices&lt;/code&gt; 服务后，系统进入 RT 阶段。此时，DXE 与引导服务都将销毁，只有 EFI 运行时服务和 EFI 系统表可以继续使用。&lt;/li&gt;
&lt;li&gt;后世阶段（After Life，AL）。当操作系统调用 &lt;code&gt;EFI_RUNTIME_SERVICES.ResetSystem&lt;/code&gt; 服务或者调用 ACPI SleepState，系统进入 AL 阶段。触发异步事件（比如：SMI、NMI）亦可使系统进入 AL 阶段，这在服务器和工作站中比较常见。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;bios-的缺点--uefi-的优点&#34;&gt;BIOS 的缺点 &amp;amp; UEFI 的优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;正如 systemd 取代 init.d 的原因之一，BIOS 不支持异步工作模式，只能使用中断来实现各种服务；而 UEFI 可以舍弃中断这种比较耗时的操作外部设备的方式，仅仅保留了时钟中断。外部设备的操作采用“事件+异步操作”完成。&lt;/li&gt;
&lt;li&gt;功能拓展性与拓展性：BIOS 代码采用静态链接，增加硬件功能时，必须将 16 位代码放置在 0x0C0000~0x0DFFFF 区间，初始化时将其设置为约定的中断处理程序。而且 BIOS 没有提供动态加载设备驱动的方案。而 UEFI 系统的可扩展性体现在两个方面：一是驱动的模块化设计；二是软硬件升级的兼容性。大部分硬件的初始化通过 UEFI 驱动实现。每个驱动是一个独立的模块，可以包含在固件中，也可以放在设备上，运行时根据需要动态加载。UEFI 中的每个表和协议（包括驱动）都有版本号，这使得系统升级过程更加简单、平滑。&lt;/li&gt;
&lt;li&gt;BIOS 不支持从硬盘 2TB 以上的地址空间引导：受限于 BIOS 硬盘的寻址方式，BIOS 硬盘采用 32 位地址，因而引导扇区的最大逻辑块地址是 2^32（换算成字节地址，即 2^32×512B=2TB）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mbr-vs-gpt&#34;&gt;MBR vs GPT&lt;/h2&gt;
&lt;p&gt;Legacy MBR（Master Boot Record）是为 BIOS 引导方式设计的磁盘引导扇区结构，其绝大部分功能结构都保存在磁盘的引导扇区。而 GPT（GUID Partition table）却是区别于 legacy MBR 磁盘布局的一种全新布局，它专为 UEFI 固件使用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;64 位的LBA（Logical Block Address）磁盘扇区寻址，而不是 32 位&lt;/li&gt;
&lt;li&gt;支持更多分区，而不仅仅是四个主分区&lt;/li&gt;
&lt;li&gt;为主分区表提供冗余的备份分区表&lt;/li&gt;
&lt;li&gt;使用版本号和大小字段为将来做扩展&lt;/li&gt;
&lt;li&gt;使用 CRC32 字段改进数据完整性&lt;/li&gt;
&lt;li&gt;定义用于唯一标识每个分区的 GUID&lt;/li&gt;
&lt;li&gt;使用 GUID 和属性定义分区类型&lt;/li&gt;
&lt;li&gt;每个分区包含一个 36 字符的人类可读名称&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了兼容 legacy MBR 磁盘布局，GPT 仍使用 legacy MBR 的引导扇区结构，但 UEFI 固件不会执行 MBR 上的启动代码。GPT 为了与 legacy MBR 的引导扇区结构相区分特将引导扇区结构命名为 Protective MBR（PMBR），并使用 GPT 伪分区模拟 MBR 分区表。&lt;/p&gt;
&lt;p&gt;GPT 的 Protective MBR 引导扇区结构只使用一个分区记录表项，这个分区将占用 Protective MBR 之后的整个磁盘空间，剩余三个表项保留使用并填充 0 。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pmbr&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/pmbr.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看到备份分区表的顺序是相反的，这也非常符合我们对这种记录结构的直觉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;guid&#34;&gt;GUID&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;GUID值&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;未使用&lt;/td&gt;
          &lt;td&gt;00000000-0000-0000-0000-000000000000&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;EFI System Partition&lt;/td&gt;
          &lt;td&gt;C12A7328-F81F-11D2-BA4B-00A0C93EC93B&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Partition Containing a legacy MBR&lt;/td&gt;
          &lt;td&gt;024DEE41-33E7-11D3-9D69-0008C781F39F&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;FAT12/16/32/NTFS&lt;/td&gt;
          &lt;td&gt;EBD0A0A2-B9E5-4433-87C0-68B6B72699C7&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;EXT4&lt;/td&gt;
          &lt;td&gt;0FC63DAF-8483-4772-8E79-3D69D8477DE4&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;区别于分区的 UUID 。这个 GUID 用于标识分区的内容，类似于MBR中的 OSType 字段。每个文件系统都必须发布其唯一的 GUID 。&lt;/p&gt;
&lt;h3 id=&#34;esp--fat--pe&#34;&gt;ESP &amp;amp; FAT &amp;amp; PE&lt;/h3&gt;
&lt;p&gt;UEFI 的 ESP 文件系统是指 UEFI 系统分区（EFI System Partition）上的文件系统，它是一个使用 FAT32 格式化的小分区，通常为 100MB，其中存储了已安装系统的 UEFI 引导加载程序以及启动时固件使用的应用程序。UEFI 固件在启动时会加载 ESP 分区上的 .efi 文件，开始加载操作系统。&lt;/p&gt;
&lt;p&gt;UEFI 不能运行 ELF 格式的可执行程序，只能运行 PE 格式的。使用 objcopy 处理生成的二进制文件，将其格式改变为 PE+ ，或者使用交叉编译的方式，将 target 设置为 &lt;code&gt;x86_64-unknown-uefi&lt;/code&gt; 或 &lt;code&gt;aarch64-unknown-uefi&lt;/code&gt; 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# file /boot/EFI/GRUB/grubx64.efi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/boot/EFI/GRUB/grubx64.efi: PE32+ executable (EFI application) x86-64 (stripped to external PDB), for MS Windows, 4 sections
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;linux-启动&#34;&gt;Linux ，启动！&lt;/h2&gt;
&lt;p&gt;不管接口或者规范如何变化，计算机的启动一般都会是三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CAR(Cache As RAM) ，这个阶段连内存都用不了&lt;/li&gt;
&lt;li&gt;能执行汇编语言&lt;/li&gt;
&lt;li&gt;设置堆栈环境，这时能执行 C 等高级语言&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里主要介绍在 BootLoader 阶段完成的工作。&lt;/p&gt;
&lt;h3 id=&#34;grub-启动&#34;&gt;GRUB ，启动！&lt;/h3&gt;
&lt;p&gt;grub 是一款不断扩充功能直到最后历史包袱积重难返的软件，因此它的启动过程比较复杂。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Stage 1：执行GRUB主程序。第一阶段是用来执行 GRUB 主程序的，这个主程序必须放在启动区中（也就是 MBR 或者引导扇区中）。但是 MBR 太小了，所以只能安装 GRUB 的最小的主程序，而不能安装 GRUB 的相关配置文件。这个主程序主要是用来启动 Stage 1.5 和 Stage 2 的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stage 1.5：识别不同的文件系统。Stage 2 比较大，只能放在文件系统中（分区），但是 Stage 1 不能识别不同的文件系统，所以不能直接加载 Stage 2。这时需要先加载 Stage 1.5，由 Stage 1.5 来加载不同文件系统中的 Stage 2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;还有一个问题，难道 Stage 1.5 不是放在文件系统中的吗？如果是，那么 Stage 1 同样不能找到 Stage 1.5。其实，Stage 1.5 还真没有放在文件系统中，而是在安装 GRUB 时，直接安装到紧跟 MBR 之后的 32KB 的空间中，这段硬盘空间是空白无用的，而且是没有文件系统的，所以 Stage 1 可以直接读取 Stage 1.5。读取了 Stage 1.5 就能识别不同的文件系统，才能加载 Stage 2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Stage 2：加载GRUB的配置文件。Stage 2 阶段主要就是加载 GRUB 的配置文件 /boot/grub/grub.conf，然后根据配置文件中的定义，加载内核和虚拟文件系统。接下来内核就可以接管启动过程，继续自检与加载硬件模块了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;grub2-启动&#34;&gt;GRUB2 ，启动！&lt;/h3&gt;
&lt;p&gt;grub2 是 grub 的重写版本，启动过程更简单明了。grub2 将 boot.img 转换后的内容安装到 MBR(VBR或EBR) 中的 boot loader 部分，将 diskboot.img 和 kernel.img 结合成为 core.img，同时还会嵌入一些模块或加载模块的代码到 core.img 中，然后将 core.img 转换后的内容安装到磁盘的指定位置处。&lt;/p&gt;
&lt;p&gt;grub2 的 core 阶段相当于 grub 的 stage1.5 和 stage2 的结合，它可以直接加载不同的文件系统和模块，而不需要额外的驱动程序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;core 阶段通常存储在一个专门的 UEFI 分区或者 /boot/grub 目录中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Stage 1：第一阶段为执行 boot loader 的主程序，这个主程序必须要被安装在引导区，也就是是 MBR 或者启动扇区。但因为 MBR 空间有限，所以，MBR 或启动扇区通常仅安装 boot loader 的最小主程序，并没有安装 loader 的相关配置文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stage 2：第二阶段通过 boot loader 加载所有配置文件与相关的环境参数文件（包括文件系统定义与主要配置文件 grub.cfg），通常配置文件都在 /boot 目录下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# ls /boot
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;EFI  grub  initramfs-linux-fallback.img  initramfs-linux.img  vmlinuz-linux
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# file vmlinuz-linux
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vmlinuz-linux: Linux kernel x86 boot executable bzImage, version 6.4.12-arch1-1 (linux@archlinux) #1 SMP PREEMPT_DYNAMIC Thu, 24 Aug 2023 00:38:14 +0000, RO-rootFS, swap_dev 0XC, Normal VGA
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# tree EFI
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;EFI
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└── GRUB
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    └── grubx64.efi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;2 directories, 1 file
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# tree grub
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;grub
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── fonts
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   └── unicode.pf2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── grub.cfg
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── grubenv
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── locale
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   ├── ast.mo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   ├── ca.mo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   ├── da.mo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   ├── de_CH.mo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   ├── de@hebrew.mo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;......
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;.mo 文件都是供 grub 加载的模块，包含了对字体、图像、USB 设备等。而 initramfs-linux.img 是一个初始内存文件系统，它是一个压缩的归档文件，包含了一些必要的程序和驱动，用于在启动过程中加载根文件系统。vmlinuz-linux 是一个 Linux 内核镜像，它是一个可执行的二进制文件，用于在 UEFI 启动模式下被固件直接加载。这两个文件通常位于 /boot 目录下，是 Linux 系统启动的重要组成部分。&lt;/p&gt;
&lt;p&gt;initramfs 的目的在于提供启动过程中所需要的最重要内核模块，以让系统启动过程可以顺利完成。需要 initramfs 的原因，是因为内核模块放置于 /lib/modules/$(uname -r)/kernel/ 当中， 这些模块必须要根目录被挂载时才能够被读取。但是如果内核本身不具备磁盘的驱动程序时， 就无法挂载根目录，也就没有办法获取到驱动程序，造成无法启动&lt;/p&gt;
&lt;p&gt;initramfs 可以将 /lib/modules/ 内的启动过程中必需的模块打包到 initramfs 中，然后在启动时，通过主机的 INT 13 硬件功能将该文件读出来解压缩，并且 initramfs 在内存内会模拟成为根目录， 由于此虚拟文件系统主要包含磁盘与文件系统的模块，因此内核最后就能够识别实际的磁盘，然后就能够进行实际根目录的挂载，因此，initramfs 内所包含的模块大多是与启动过程有关，且主要以文件系统及硬盘模块 (如 usb, SCSI 等) 为主的&lt;/p&gt;
&lt;p&gt;通常在以下情况下需要 initramfs：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根目录所在磁盘为 SATA、USB 或 SCSI 等接口&lt;/li&gt;
&lt;li&gt;根目录所在文件系统为 LVM, RAID 等特殊格式&lt;/li&gt;
&lt;li&gt;根目录所在文件系统为非传统 Linux 识别的文件系统&lt;/li&gt;
&lt;li&gt;其他必须要在内核加载时提供的模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在发行版更新内核时，一般都会执行一个钩子函数，重新生成这些重要部件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;:: Running post-transaction hooks...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;/&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;7&lt;/span&gt;) Reloading system manager configuration...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;/&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;7&lt;/span&gt;) Reloading device manager configuration...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;/&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;7&lt;/span&gt;) Arming ConditionNeedsUpdate...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;/&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;7&lt;/span&gt;) Updating module dependencies...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;/&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;7&lt;/span&gt;) Install DKMS modules
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; dkms install --no-depmod v4l2loopback/&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.12&lt;/span&gt;.&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;7&lt;/span&gt; -k &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;6.5&lt;/span&gt;.&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;-arch1-&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; depmod &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;6.5&lt;/span&gt;.&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;-arch1-&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;6&lt;/span&gt;/&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;7&lt;/span&gt;) Updating linux initcpios...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; Building image from preset: /etc/mkinitcpio.d/linux.preset: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;default&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; Using default configuration file: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;/etc/mkinitcpio.conf&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; -k /boot/vmlinuz-linux -g /boot/initramfs-linux.img --microcode /boot/*-ucode.img
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; Starting build: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;6.5.2-arch1-1&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [base]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [udev]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [autodetect]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [modconf]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [kms]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [keyboard]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; WARNING: Possibly missing firmware &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; module: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;xhci_pci&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [keymap]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [consolefont]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; WARNING: consolefont: no font found in configuration
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [block]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [filesystems]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [fsck]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; Generating module dependencies
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; Creating zstd-compressed initcpio image: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;/boot/initramfs-linux.img&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; Image generation successful
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; Building image from preset: /etc/mkinitcpio.d/linux.preset: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;fallback&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; Using default configuration file: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;/etc/mkinitcpio.conf&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; -k /boot/vmlinuz-linux -g /boot/initramfs-linux-fallback.img -S autodetect --microcode /boot/*-ucode.img
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; Starting build: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;6.5.2-arch1-1&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [base]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [udev]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [modconf]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [kms]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; WARNING: Possibly missing firmware &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; module: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;ast&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [keyboard]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; WARNING: Possibly missing firmware &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; module: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;xhci_pci&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [keymap]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [consolefont]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; WARNING: consolefont: no font found in configuration
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [block]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; WARNING: Possibly missing firmware &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; module: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;aic94xx&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; WARNING: Possibly missing firmware &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; module: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;bfa&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; WARNING: Possibly missing firmware &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; module: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;qed&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; WARNING: Possibly missing firmware &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; module: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;qla1280&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; WARNING: Possibly missing firmware &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; module: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;qla2xxx&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; WARNING: Possibly missing firmware &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; module: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;wd719x&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [filesystems]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt; Running build hook: [fsck]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; Generating module dependencies
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; Creating zstd-compressed initcpio image: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;/boot/initramfs-linux-fallback.img&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;==&amp;gt; Image generation successful
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;7&lt;/span&gt;/&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;7&lt;/span&gt;) Reloading system bus configuration...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;total &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;h &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;m &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;21&lt;/span&gt;s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个 UEFi 引导程序的实现&lt;/li&gt;
&lt;li&gt;GRUB legacy document&lt;/li&gt;
&lt;li&gt;GRUB2 document&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yanjun.pro/?p=78&#34;&gt;Linux启动流程（二）：grub2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dingmos.com/index.php/archives/31/&#34;&gt;计算机是如何启动的？从未上电到操作系统启动&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>足球队账单</title>
      <link>https://vaaandark.top/posts/football-team-bill/</link>
      <pubDate>Tue, 29 Aug 2023 21:57:09 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/football-team-bill/</guid>
      <description>&lt;p&gt;8 月 13 日开始记账，开始时剩余 2392.87 元。截至 12.29 日，剩余 864.77 元。&lt;/p&gt;
&lt;p&gt;去除尚未到账的学院报销，2023 年秋季学期实际支出 801.10 元。&lt;/p&gt;
&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;中操西操纯净水 1 元一瓶，整箱购买中操有优惠 22 元，西操没有优惠 24 元，直接购买超市矿泉水一件 48 元。&lt;/li&gt;
&lt;li&gt;购买训练道具 728 元，学院尚未报销。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;账单&#34;&gt;账单&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;收入 / 支出&lt;/th&gt;
          &lt;th&gt;用途&lt;/th&gt;
          &lt;th&gt;剩余&lt;/th&gt;
          &lt;th&gt;备注&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.08.29&lt;/td&gt;
          &lt;td&gt;-24.00&lt;/td&gt;
          &lt;td&gt;与新生训练赛买水&lt;/td&gt;
          &lt;td&gt;2368.87&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.08.31&lt;/td&gt;
          &lt;td&gt;-36.00&lt;/td&gt;
          &lt;td&gt;与新生训练赛买水&lt;/td&gt;
          &lt;td&gt;2332.87&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.09.01&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;新生野球买水&lt;/td&gt;
          &lt;td&gt;2310.87&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.09.02&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;2288.87&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.09.09&lt;/td&gt;
          &lt;td&gt;-43.20&lt;/td&gt;
          &lt;td&gt;与网安院队友谊赛买水&lt;/td&gt;
          &lt;td&gt;2245.67&lt;/td&gt;
          &lt;td&gt;农夫山泉 1.8/瓶&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.09.16&lt;/td&gt;
          &lt;td&gt;-43.20&lt;/td&gt;
          &lt;td&gt;新生队与集成新生队友谊赛买水&lt;/td&gt;
          &lt;td&gt;2202.47&lt;/td&gt;
          &lt;td&gt;农夫山泉 1.8/瓶&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.09.16&lt;/td&gt;
          &lt;td&gt;-200.00&lt;/td&gt;
          &lt;td&gt;新生杯保证金&lt;/td&gt;
          &lt;td&gt;2002.47&lt;/td&gt;
          &lt;td&gt;之后会根据红黄牌情况退还&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.09.17&lt;/td&gt;
          &lt;td&gt;-78.00&lt;/td&gt;
          &lt;td&gt;新生杯第一场保险&lt;/td&gt;
          &lt;td&gt;1924.47&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.09.18&lt;/td&gt;
          &lt;td&gt;-33.00&lt;/td&gt;
          &lt;td&gt;新生杯第一场买水&lt;/td&gt;
          &lt;td&gt;1891.47&lt;/td&gt;
          &lt;td&gt;半箱冰露和四瓶佳得乐&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.09.24&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;与集成院队友谊赛买水&lt;/td&gt;
          &lt;td&gt;1869.47&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.09.25&lt;/td&gt;
          &lt;td&gt;-48.00&lt;/td&gt;
          &lt;td&gt;新生杯第二场买水&lt;/td&gt;
          &lt;td&gt;1821.47&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.10.07&lt;/td&gt;
          &lt;td&gt;-48.00&lt;/td&gt;
          &lt;td&gt;新生杯第三场保险&lt;/td&gt;
          &lt;td&gt;1773.47&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.10.07&lt;/td&gt;
          &lt;td&gt;-45.00&lt;/td&gt;
          &lt;td&gt;新生杯第三场买水&lt;/td&gt;
          &lt;td&gt;1728.47&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.10.15&lt;/td&gt;
          &lt;td&gt;-48.00&lt;/td&gt;
          &lt;td&gt;与软件院队友谊赛买水&lt;/td&gt;
          &lt;td&gt;1680.47&lt;/td&gt;
          &lt;td&gt;两箱矿泉水&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.10.17&lt;/td&gt;
          &lt;td&gt;-24.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;1656.47&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.10.21&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;与数学院队友谊赛买水&lt;/td&gt;
          &lt;td&gt;1634.47&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.10.24&lt;/td&gt;
          &lt;td&gt;+170.00&lt;/td&gt;
          &lt;td&gt;新生杯保证金退还&lt;/td&gt;
          &lt;td&gt;1804.47&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.10.24&lt;/td&gt;
          &lt;td&gt;-728.00&lt;/td&gt;
          &lt;td&gt;购买训练道具&lt;/td&gt;
          &lt;td&gt;1076.47&lt;/td&gt;
          &lt;td&gt;等待学院报销&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.10.31&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;1054.47&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.11.06&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;1032.47&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.11.14&lt;/td&gt;
          &lt;td&gt;-2.00&lt;/td&gt;
          &lt;td&gt;冰袋&lt;/td&gt;
          &lt;td&gt;1030.47&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.11.22&lt;/td&gt;
          &lt;td&gt;-12.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;1018.47&lt;/td&gt;
          &lt;td&gt;半箱&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.11.26&lt;/td&gt;
          &lt;td&gt;-48.00&lt;/td&gt;
          &lt;td&gt;与管理院队友谊赛买水&lt;/td&gt;
          &lt;td&gt;970.47&lt;/td&gt;
          &lt;td&gt;两箱&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.11.28&lt;/td&gt;
          &lt;td&gt;-24.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;946.47&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.12.10&lt;/td&gt;
          &lt;td&gt;-37.70&lt;/td&gt;
          &lt;td&gt;与光电院队友谊赛买水和冰敷&lt;/td&gt;
          &lt;td&gt;898.77&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.12.17&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;与网安院队友谊赛买水&lt;/td&gt;
          &lt;td&gt;876.77&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.12.26&lt;/td&gt;
          &lt;td&gt;-12.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;864.77&lt;/td&gt;
          &lt;td&gt;半箱&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.03.03&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;842.77&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.03.05&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;820.77&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.03.09&lt;/td&gt;
          &lt;td&gt;-24.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;796.77&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.03.10&lt;/td&gt;
          &lt;td&gt;-40.08&lt;/td&gt;
          &lt;td&gt;与软件院队友谊赛买水&lt;/td&gt;
          &lt;td&gt;756.69&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.03.12&lt;/td&gt;
          &lt;td&gt;-24.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;732.69&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.03.20&lt;/td&gt;
          &lt;td&gt;-24.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;708.69&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.03.21&lt;/td&gt;
          &lt;td&gt;-48.00&lt;/td&gt;
          &lt;td&gt;华工杯(vs网安)买水&lt;/td&gt;
          &lt;td&gt;660.69&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.03.24&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;训练买水&lt;/td&gt;
          &lt;td&gt;638.69&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.03.31&lt;/td&gt;
          &lt;td&gt;-47.00&lt;/td&gt;
          &lt;td&gt;华工杯(vs船海)买水&lt;/td&gt;
          &lt;td&gt;591.69&lt;/td&gt;
          &lt;td&gt;包含五瓶佳得乐&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.04.06&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;华工杯(vs生科)买水&lt;/td&gt;
          &lt;td&gt;569.69&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.04.13&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;华工杯(vs集成)买水&lt;/td&gt;
          &lt;td&gt;547.69&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.04.17&lt;/td&gt;
          &lt;td&gt;-47.00&lt;/td&gt;
          &lt;td&gt;华工杯(vs建规)买水&lt;/td&gt;
          &lt;td&gt;500.69&lt;/td&gt;
          &lt;td&gt;包含五瓶佳得乐&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023.04.20&lt;/td&gt;
          &lt;td&gt;-22.00&lt;/td&gt;
          &lt;td&gt;华工杯(vs建规)买水&lt;/td&gt;
          &lt;td&gt;478.69&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>PAC2023娱乐赛</title>
      <link>https://vaaandark.top/posts/pac2023-game/</link>
      <pubDate>Thu, 06 Jul 2023 23:55:08 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/pac2023-game/</guid>
      <description>&lt;p&gt;7.6 举办了 PAC2023 的开幕赛，以轻松娱乐为主，我还没有体验过在短时间内完成优化工作（不过今天的工作量倒也不大）。这场娱乐赛给了我别样的体验，也让我发现了我有好的好多不足，以及一些以前没有注意到的坏习惯。&lt;/p&gt;
&lt;h2 id=&#34;赛题介绍&#34;&gt;赛题介绍&lt;/h2&gt;
&lt;p&gt;赛题是针对一个朴素实现的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F&#34;&gt;康威生命游戏&lt;/a&gt;的优化。由于代码写得很朴素，所以比较轻松地就可以达到比较好看的加速比。&lt;/p&gt;
&lt;p&gt;代码的核心部分如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; iter = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; iter &amp;lt; max_iter; ++iter) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Iter %d...&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, iter);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &amp;lt; Ny - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; j &amp;lt; Nx - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++j) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; cnt = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; k = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; k &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;; ++k) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; ii = i + dy[k];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; jj = j + dx[k];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (a[ii][jj] == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cnt++;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (a[i][j] == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (cnt == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; || cnt == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            tmp[i][j] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            tmp[i][j] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {  &lt;span style=&#34;color:#007f7f&#34;&gt;// a[i][j] == 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;          &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (cnt == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            tmp[i][j] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            tmp[i][j] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; Ny; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; j &amp;lt; Nx; ++j) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        a[i][j] = tmp[i][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;代码分析&#34;&gt;代码分析&lt;/h2&gt;
&lt;p&gt;可以看到生命游戏一共要进行 1000 次迭代，每次都遍历一遍整个地图，对每个点都计算一下邻居的个数，再根据生命游戏的 B3/S23 规则决定下一次迭代时的状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;B3/S23 规则是对生命游戏规则的概括缩写&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个朴素写法非常的暴力，不仅是直接访问每个点周围的八个点，而且还使用了 &lt;code&gt;tmp&lt;/code&gt; 数组暂存元素，最后将 &lt;code&gt;tmp&lt;/code&gt; 复制到地图数组 &lt;code&gt;a&lt;/code&gt; 中，开销不可谓不大。&lt;/p&gt;
&lt;p&gt;在本地的 64 核心集群上运行 baseline ，运行时间为 &lt;strong&gt;741335.164000 ms&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在北京超级云计算中心上运行 baseline ，运行时间为 &lt;strong&gt;634306.056000 ms&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;优化策略&#34;&gt;优化策略&lt;/h2&gt;
&lt;h3 id=&#34;算法微调--访存优化&#34;&gt;算法微调 &amp;amp;&amp;amp; 访存优化&lt;/h3&gt;
&lt;p&gt;首先我想到的是对算法进行微调，将之前的对每个点求邻居个数改为，将每行与上下两行进行叠加，这样每个元素就是三个点和。这就把对一个「九宫格」的计算改成了两次对三个元素的加和。这样并不能减少计算量，但是能减少访存上的开销。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这样做的目的还有简化代码逻辑，方便编译器生成 SIMD 指令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在一番取舍之后没有使用前缀和算法来，这是因为担心在改变数据类型后，数据类型不够宽，无法存放前缀和。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实这是后话，后面把 &lt;code&gt;int&lt;/code&gt; 改成了 &lt;code&gt;uint8_t&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;核心代码改成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; iter = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; iter &amp;lt; max_iter; ++iter) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Iter %d...&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, iter);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    memcpy(sum, a, Nx * Ny * &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &amp;lt; Ny - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; j &amp;lt; Nx - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++j) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum[i][j] += a[i + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &amp;lt; Ny - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; j &amp;lt; Nx; ++j) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum[i][j] += a[i - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &amp;lt; Ny - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; j &amp;lt; Nx - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++j) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; neighbors = sum[i][j] + sum[i][j - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;] + sum[i][j + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;] - a[i][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (neighbors == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          tmp[i][j] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (neighbors &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; || neighbors &amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          tmp[i][j] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          tmp[i][j] = a[i][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    memcpy(a, tmp, Nx * Ny * &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在本地的 64 核心集群上运行时间为 &lt;strong&gt;293731.276000 ms&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在北京超级云计算中心上运行时间为 &lt;strong&gt;260813.238000 ms&lt;/strong&gt; ，加速比约为 &lt;strong&gt;2.4x&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;openmp--合并循环&#34;&gt;openmp &amp;amp;&amp;amp; 合并循环&lt;/h3&gt;
&lt;p&gt;之后就是最喜欢的「&lt;strong&gt;openmp，启动！&lt;/strong&gt;」环节了。openmp 相对其他的并行框架来说非常好用，无脑推荐。&lt;/p&gt;
&lt;p&gt;在敲代码时又突然发现叠加的两个循环其实可以合并，&lt;del&gt;这下傻逼了&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;所以核心代码变成了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Iter %d...&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, iter);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    memcpy(sum, a, Nx * Ny * &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel for
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &amp;lt; Ny - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; j &amp;lt; Nx - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++j) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum[i][j] += a[i + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum[i][j] += a[i - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel for
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在本地的 64 核心集群上运行时间为 &lt;strong&gt;18918.941000 ms&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在北京超级云计算中心上运行时间为 &lt;strong&gt;18864.766000 ms&lt;/strong&gt; ，加速比约为 &lt;strong&gt;33x&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;o3--simd&#34;&gt;O3 &amp;amp;&amp;amp; SIMD&lt;/h3&gt;
&lt;p&gt;之前使用的编译参数都是 &lt;code&gt;-O0&lt;/code&gt; 现在改成 &lt;code&gt;-O3&lt;/code&gt; ，大量的整数运算操作可以向量化。&lt;/p&gt;
&lt;p&gt;在本地的 64 核心集群上运行时间为 &lt;strong&gt;10292.194000 ms&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在北京超级云计算中心上运行时间为 &lt;strong&gt;15419.145000 ms&lt;/strong&gt; ，加速比约为 &lt;strong&gt;41x&lt;/strong&gt; 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里就可以看到本地集群和云计算中心集群机器性能的差别，本地集群单核性能弱于计算中心（体现在 baseline 本地跑了更久），但是计算中心的核心少于本地，因此使用 openmp 的情况下本地加速更明显。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;改变数据类型&#34;&gt;改变数据类型&lt;/h3&gt;
&lt;p&gt;由于在九宫格中的计算结果在 0-9 之间，因此不需要很宽的数据类型来存储，而且也不需要考虑负数，因此我使用了 &lt;code&gt;uint8_t&lt;/code&gt; 类型来替换 &lt;code&gt;int&lt;/code&gt; ，这样操作之后加速比又提高了不少。&lt;/p&gt;
&lt;p&gt;在本地的 64 核心集群上运行时间为 &lt;strong&gt;3004.615000 ms&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在北京超级云计算中心上运行时间为 &lt;strong&gt;3858.775000 ms&lt;/strong&gt; ，加速比约为 &lt;strong&gt;164x&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;去掉不必要的拷贝&#34;&gt;去掉不必要的拷贝&lt;/h3&gt;
&lt;p&gt;最后再看看自己的代码，发现很多细节还可以处理。例如数据的拷贝，为了计算与相邻两行的和，我新增了一个数组，由于这个数组可以存储中间过程，我可以去掉 &lt;code&gt;tmp&lt;/code&gt; 数组，直接对 &lt;code&gt;a&lt;/code&gt; 数组进行操作，这样减少了 &lt;code&gt;memcpy&lt;/code&gt; 的开销。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小插曲：baseline 对边缘的处理非常差，导致第一次迭代(iter=0)时需要将 &lt;code&gt;a&lt;/code&gt; 数组的边缘全部置为 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有就是在一开始将 &lt;code&gt;a&lt;/code&gt; 数组拷贝到 &lt;code&gt;sum&lt;/code&gt; 数组，这个其实也可以带到第一次的循环中进行，这对访存没有什么副作用，而且可以并行执行。&lt;/p&gt;
&lt;p&gt;最后的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; iter = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; iter &amp;lt; max_iter; ++iter) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel for proc_bind(spread)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; Ny - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; j &amp;lt; Nx - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++j) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum[i][j] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum[i][j] += a[i + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum[i][j] += a[i][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum[i][j] += a[i - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel for proc_bind(spread)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &amp;lt; Ny - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; j &amp;lt; Nx - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++j) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; neighbors = sum[i][j] + sum[i][j - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;] + sum[i][j + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;] - a[i][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (neighbors == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          a[i][j] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (neighbors &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; || neighbors &amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          a[i][j] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (iter == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      memset(a[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(a[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;]));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      memset(a[Ny - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(a[Ny - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;]));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; Ny; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        a[i][Nx - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        a[i][&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在本地的 64 核心集群上运行时间为 &lt;strong&gt;247.119000 ms&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本地由于单核弱而核数多，跑到 3000x 没什么鸟用，不具备参考价值😭&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在北京超级云计算中心上运行时间为 &lt;strong&gt;318.769000 ms&lt;/strong&gt; ，加速比约为 &lt;strong&gt;1990x&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;之前打高性能比赛都是组队参加，总是需要大佬的指导和安排任务，这次个人赛暴露了很多不足，完全没有发挥出机器的全部性能。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;不过往好处想，整体的优化思路是短时间内就想出来了的，都怪愚蠢的 baseline ，我花了很多时间在解决正确性的问题。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;这次比赛没有机会尝试使用 MPI ，有时间的话用 MPI 继续做做这道题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据库复习之关系代数</title>
      <link>https://vaaandark.top/posts/review-for-database-on-relation-algebra/</link>
      <pubDate>Mon, 19 Jun 2023 16:19:07 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/review-for-database-on-relation-algebra/</guid>
      <description>&lt;h1 id=&#34;关系代数&#34;&gt;关系代数&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0_(%E6%95%B0%E6%8D%AE%E5%BA%93)&#34;&gt;关系代数（数据库）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;计算机科学家 Codd 对关系代数的形成作出了很大的贡献，他的代数的六个原始运算是「选择」、「投影」、「笛卡尔积」、「并集」、「差集」、「重命名」。&lt;/p&gt;
&lt;h2 id=&#34;select&#34;&gt;Select&lt;/h2&gt;
&lt;p&gt;相当于 sql 中 &lt;code&gt;where&lt;/code&gt; 的功能。&lt;/p&gt;
&lt;p&gt;一般形式：&lt;/p&gt;
&lt;p&gt;$$
\sigma_{verb}(relationship)
$$&lt;/p&gt;
&lt;p&gt;选择谓词一般是逻辑表达式，可以是连词连接（也可以没有连词）的多个比较语句。&lt;/p&gt;
&lt;h2 id=&#34;projection&#34;&gt;Projection&lt;/h2&gt;
&lt;p&gt;相当于 sql 中 &lt;code&gt;select&lt;/code&gt; 的功能。&lt;/p&gt;
&lt;p&gt;一般形式：&lt;/p&gt;
&lt;p&gt;$$
\Pi_{fields}(relationship)
$$&lt;/p&gt;
&lt;p&gt;从关系中选出若干属性列组成新的关系，在这种选择过程中可能会减少一些列（没有被选中或者出现了重复）。&lt;/p&gt;
&lt;h2 id=&#34;join&#34;&gt;Join&lt;/h2&gt;
&lt;p&gt;连接可以分为自然连接、等值连接、外连接等。&lt;/p&gt;
&lt;p&gt;等值连接，从关系 R 和 S 的广义笛卡尔积中选取 A 、B 属性值相等的那些元组，一般形式：&lt;/p&gt;
&lt;p&gt;$$
R\bowtie_{A=B}S
$$&lt;/p&gt;
&lt;p&gt;自然连接， 连接时两个关系中比较的分量必须是同名的属性组，并在结果中把重复的属性列去掉。一般形式：&lt;/p&gt;
&lt;p&gt;$$
R\bowtie{S}
$$&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;join&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/join.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;自然连接时会出现 R 中的某些元组在 S 中不存在公共属性上值相等的元组，所以出现了「悬浮元组」，如果保留它们，未知的属性填上 NULL ，这就是「外连接」。如果只保留左边关系中的悬浮元组就是「左外连接」，反之就是「右外连接」。&lt;/p&gt;
&lt;h2 id=&#34;divsion&#34;&gt;Divsion&lt;/h2&gt;
&lt;p&gt;其结果由 R 中元组到唯一于 R 的属性名字（就是说只在 R 表头中而不在 S 表头中的属性）的限制构成，并且它们与 S 中的元组的所有组合都存在于 R 中。一般形式：&lt;/p&gt;
&lt;p&gt;$$
R\div{S}
$$&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;divsion&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/divsion.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;rename&#34;&gt;Rename&lt;/h2&gt;
&lt;p&gt;一般形式：&lt;/p&gt;
&lt;p&gt;$$
\rho_{a/b}(R)
$$&lt;/p&gt;
&lt;p&gt;把所有元组中的 b 字段改成 a 字段。相当于 sql 中的 &lt;code&gt;as&lt;/code&gt; 。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;PS:&lt;/p&gt;
&lt;p&gt;关系的完整性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实体完整性（主码不能为空）&lt;/li&gt;
&lt;li&gt;参照完整性（外码要么为空要么存在于参照关系中）&lt;/li&gt;
&lt;li&gt;用户定义完整性（要遵照用户的定义，例如人数不能为小数等）&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CPU 流水线</title>
      <link>https://vaaandark.top/posts/cpu-pipeline/</link>
      <pubDate>Sat, 22 Apr 2023 17:29:49 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/cpu-pipeline/</guid>
      <description>&lt;h1 id=&#34;流水线级&#34;&gt;流水线级&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一条流水线的每个分步骤被称为流水线级。它们被流水线寄存器分开。下文中没有说明是流水线寄存器的都是普通 CPU 寄存器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;现代计算机流水线级数已经达到了 10-20 级，在 2000-2010 年间，流水线级数的竞赛达到了最高峰，那时候的处理器甚至可以有高达 31 级的流水线。但是超深的流水线带来的是结构上的复杂和显著增大的动态调度模块设计难度，因此，从那以后就没有再出现过使用这么多级流水线的 CPU 了。&lt;/p&gt;
&lt;p&gt;我们只是稍微介绍（或者说是为已经知道的同学前情回顾）一下最基础的 CPU 流水线，它有助于我们理解更为复杂的流水线实现。同时，这个最基础的 CPU 流水线并不基于某一架构，因此并不会涉及操作数的数量、对立即数的操作等信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;取指instruction-fetch&#34;&gt;取指(Instruction Fetch)&lt;/h2&gt;
&lt;p&gt;从内存中获取指令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个周期从指令缓存中取一条指令&lt;/li&gt;
&lt;li&gt;将状态写入流水线寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;译码instruction-decode&#34;&gt;译码(Instruction Decode)&lt;/h2&gt;
&lt;p&gt;读取寄存器并解码指令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解码操作数，为后续阶段设置不同标志&lt;/li&gt;
&lt;li&gt;从寄存器文件中读取输入操作数，由所需操作数或指令指定（例如 push 隐含了对栈顶寄存器的操作）&lt;/li&gt;
&lt;li&gt;将状态写入流水线寄存器（例如操作数、寄存器内容、立即数等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;执行execute&#34;&gt;执行(Execute)&lt;/h2&gt;
&lt;p&gt;执行指令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行 ALU 运算，计算指令结果&lt;/li&gt;
&lt;li&gt;将状态写入流水线寄存器（例如 ALU 计算结果等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;访存memory-access&#34;&gt;访存(Memory Access)&lt;/h2&gt;
&lt;p&gt;访问内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行数据缓存访问&lt;/li&gt;
&lt;li&gt;将状态写入流水线寄存器（例如上一步得到的 ALU 计算结果和这一步获得的数据等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;写回write-back&#34;&gt;写回(Write-Back)&lt;/h2&gt;
&lt;p&gt;将结果写入寄存器（如果该指令需要这么做的话）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将加载的数据写入目标寄存器&lt;/li&gt;
&lt;li&gt;将 ALU 计算结果写入目标寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;设计和实现的问题&#34;&gt;设计和实现的问题&lt;/h1&gt;
&lt;h2 id=&#34;冒险hazard&#34;&gt;冒险(Hazard)&lt;/h2&gt;
&lt;p&gt;在流水线中我们希望当前每个时钟周期都有一条指令进入流水线可以执行。但&lt;strong&gt;在某些情况下，下一条指令无法按照预期开始执行，这种情况就被称为冒险&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;数据冒险&#34;&gt;数据冒险&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一条指令需要某数据而该数据正在被之前的指令操作&lt;/strong&gt;，这条指令就无法执行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mov eax, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;add ebx, eax
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假设 CPU  不管任何数据冒险。那么当指令 &lt;code&gt;add ebx, eax&lt;/code&gt; 来到译码阶段时，它的上一条指令，&lt;code&gt;mov eax, 1&lt;/code&gt; ，还处在执行阶段中。此时 &lt;code&gt;mov  eax, 1&lt;/code&gt; 还没有将立即数写入 CPU 寄存器，因此 &lt;code&gt;add ebx, eax&lt;/code&gt; 无法读取到正确的 &lt;code&gt;eax&lt;/code&gt; 内容。这时就出现了数据冒险。&lt;/p&gt;
&lt;h3 id=&#34;控制冒险&#34;&gt;控制冒险&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;当前应该执行的指令需要之前的指令运行结果来决定&lt;/strong&gt;，这条指令就无法执行。&lt;/p&gt;
&lt;p&gt;例如，当需要当前指令进入流水线时，上一条指令 &lt;code&gt;je l1&lt;/code&gt; 尚未通过译码阶段，尚未读取条件码寄存器，不能确定下一条执行的指令。&lt;/p&gt;
&lt;h3 id=&#34;结构冒险&#34;&gt;结构冒险&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一条指令需要的硬件部件还在为之前的指令工作&lt;/strong&gt;，这条指令就无法执行。&lt;/p&gt;
&lt;p&gt;例如，如果指令和数据放在同一个存储器中，则不能同时读存储器（一条指令正在从内存中取指令，另一条正在访存）。实际上，虽然冯诺依曼结构不区分指令和数据，但是在现代 CPU 的一级高速缓存(L1 cache)上，其实区分了指令(icache)和数据(dcache)。&lt;/p&gt;
&lt;p&gt;又例如，读寄存器和写寄存器同时发生（一条指令正在写回，另一条正在译码）。可以通过前半个周期写，后半个周期读，并且设置独立的读写端口的方式来解决。&lt;/p&gt;
&lt;h2 id=&#34;解决&#34;&gt;解决&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;解决冒险问题，很多时候采取的是给 CPU 增加更多的支路将不同流水线阶段连接起来的方法，但是由于不能将未来的数据传递到过去，所以除了「转发」操作还不得不使用「暂停」操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;转发forwarding&#34;&gt;转发(Forwarding)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;转发有时又叫旁路(Bypassing)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;将结果值直接从一个流水线阶段传到较早阶段&lt;/strong&gt;的技术就是数据转发。数据转发需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;数据依赖&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/reg-dep.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，数据依赖导致了数据冒险，箭头表示依赖关系，红色箭头表示所依赖的数据此时尚未写回，黑色数据表示所依赖数据此时已经写回。&lt;/p&gt;
&lt;p&gt;对于红色箭头，当 &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 处于译码阶段，需要读取寄存器文件时，CPU 能发现在之前的 &lt;code&gt;sub&lt;/code&gt; 指令中还有没有完成的寄存器写操作，然后通过数据转发直接获得 &lt;code&gt;$2&lt;/code&gt; 的值。&lt;/p&gt;
&lt;h3 id=&#34;暂停stall--bubble&#34;&gt;暂停(Stall &amp;amp; Bubble)&lt;/h3&gt;
&lt;p&gt;暂停时，处理器会&lt;strong&gt;停止流水线的一条或多条指令，直到冒险条件不再满足&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;无法转发&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/cannot-forward.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，&lt;code&gt;lw $2 20($3)&lt;/code&gt; 将内存中的数据加载到寄存器 &lt;code&gt;$2&lt;/code&gt; 中，下一条指令使用了 &lt;code&gt;$2&lt;/code&gt; 的值，因此产生了数据冒险。值得注意的是，这里寄存器的值最早也要在访存阶段获得，因此 &lt;code&gt;and&lt;/code&gt; 指令无法通过数据转发的方式获得 &lt;code&gt;$2&lt;/code&gt; 的值。&lt;/p&gt;
&lt;p&gt;此时就不得不使用暂停的方法来处理冒险了。在这里处理器要暂停已经进入流水线的 &lt;code&gt;lw&lt;/code&gt; 以后的所有指令。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;bubble&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/bubble.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;特别需要提醒的是，暂停虽然和指令 &lt;code&gt;nop&lt;/code&gt; 有相同之处，但其本质是处理器内部处理数据冒险时自动添加的，而不是由编译器产生的。如果需要编译器产生 &lt;code&gt;nop&lt;/code&gt; 指令来暂停，那代码将不能在相同平台的不同流水线级数的处理器上通用（比如有的需要 7 个 &lt;code&gt;nop&lt;/code&gt; 指令能等待到冒险条件不满足，有的需要 9 个 &lt;code&gt;nop&lt;/code&gt; 指令）。&lt;/p&gt;
&lt;h3 id=&#34;分支预测&#34;&gt;分支预测&lt;/h3&gt;
&lt;p&gt;为什么要预测分支？&lt;/p&gt;
&lt;p&gt;假设我们不预测分支，每当我们遇到控制冒险时都采用暂停的方法，我们需要等待一条指令完成执行阶段再对下一条取指。在前文的五段流水线 CPU 中，这会浪费两个周期。&lt;/p&gt;
&lt;p&gt;而当我们预测分支时，当我们进入了错误的分支时，我们需要抛弃已经运行的结果重新取指（一般叫 flush），这样也是浪费两个周期。但是只要我们预测正确一次，那就必然比暂停的方法快。&lt;/p&gt;
&lt;p&gt;目前所有的 CPU 都采用了分支预测的方法来处理控制冒险，现代 CPU 的分支预测准确率可以达到 90% 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CS246 Finding Similar Items: Locality Sensitive Hashing</title>
      <link>https://vaaandark.top/posts/cs246-finding-similar-itemslocality-sensitive-hashing/</link>
      <pubDate>Wed, 15 Mar 2023 16:44:34 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/cs246-finding-similar-itemslocality-sensitive-hashing/</guid>
      <description>&lt;p&gt;最近在上大数据分析的课程，老师使用的是斯坦福大学的教材和 PPT ，感觉挺有趣的，记录一下其中的一些算法。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;很多问题可以被归化为寻找相似集合的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;论文差重&lt;/li&gt;
&lt;li&gt;寻找购买相似商品的人群&lt;/li&gt;
&lt;li&gt;寻找有相似特征的图片&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不妨将这次的目的设置为：&lt;strong&gt;给定大量的文档，发现其中有抄袭嫌疑的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但问题是，一个集合中的元素非常多，如果要直接比对，其复杂度可以达到 $O(N^2)$ ，这在大数据尺度明显是不能接受的。&lt;/p&gt;
&lt;h2 id=&#34;前置知识&#34;&gt;前置知识&lt;/h2&gt;
&lt;p&gt;数据之间的距离：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也可以说是用数据之间的相似度，一般距离越远，相似度越低&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;向量的思想：使用角度度量&lt;/li&gt;
&lt;li&gt;集合的思想：使用雅卡尔距离度量&lt;/li&gt;
&lt;li&gt;点的思想：使用欧氏距离度量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;雅卡尔指数&lt;/strong&gt;可以度量有限样本集合的相似度，定义为两个集合交集大小和并集大小之比：&lt;/p&gt;
&lt;p&gt;$$
J(A, B) = \frac{\lvert A \cap B\rvert}{\lvert B \cup A\rvert} = \frac{\lvert A \cap B\rvert}{\lvert A \rvert + \lvert B \rvert - \lvert A \cap B \rvert}
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;雅卡尔距离&lt;/strong&gt;用于度量样本集之间的不相似度，定义为 1 减去雅卡尔系数：&lt;/p&gt;
&lt;p&gt;$$
d_J(A, B) = 1 - J(A, B) = \frac{\lvert A \cup B \rvert - \lvert A \cap B \rvert}{\lvert A \cup B \rvert}
$$&lt;/p&gt;
&lt;p&gt;也可以叫雅卡尔距离为两集合的对称差。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;哈希函数是一种从任何数据中创建小的数字「指纹」的方法。&lt;/p&gt;
&lt;p&gt;我们如果能够找到一种哈希函数，可以在压缩集合成为「指纹」的同时保留其特征，能够用于比较集合之间的相似度，就可以减小计算量了。这也就引出了 Min-Hash 这个算法。&lt;/p&gt;
&lt;h2 id=&#34;shingling&#34;&gt;Shingling&lt;/h2&gt;
&lt;h3 id=&#34;何为-shingling&#34;&gt;何为 Shingling&lt;/h3&gt;
&lt;p&gt;将文档转化为单词的集合。&lt;/p&gt;
&lt;p&gt;如何转化是个问题，可以有以下的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接将文档拆分成很多个单个单词的集合&lt;/li&gt;
&lt;li&gt;从文章中提取出关键单词&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但以上两种方法都会损失掉单词的顺序信息。而这里要介绍的方法 Shingling 就可以避免。&lt;/p&gt;
&lt;p&gt;这里使用的单词 Shingling 意思为「叠瓦」，非常有意思。说起「叠瓦」，可能会让人想到「叠瓦盘」。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SMR 叠瓦式磁盘是一种采用新型磁存储技术的高容量磁盘。SMR 盘将盘片上的数据磁道部分重叠，就像屋顶上的瓦片一样，这种技术被称为叠瓦式磁记录技术。该技术在制造工艺方面的变动非常微小，但却可以大幅提高磁盘存储密度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;SMR&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/SMR.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;在这里的 Shingling 也是类似的，举个例子：&lt;/p&gt;
&lt;p&gt;文档 $D_1 = abcab$ ，使用 2-shingles 就可以获得 $S(D_1) = {ab, bc, ca}$&lt;/p&gt;
&lt;p&gt;如此一来就可以保留原来文档中单词的顺序信息。&lt;/p&gt;
&lt;h3 id=&#34;对-shingle-压缩&#34;&gt;对 Shingle 压缩&lt;/h3&gt;
&lt;p&gt;由于两篇文档大部分的 Shingle 都会是不同的，因此可以使用 Hash 压缩 Shingle 到相同的宽度的数字类型。&lt;/p&gt;
&lt;p&gt;之后当我们需要比较两个 Shingle 集合的相似程度时，就可以使用之前的雅卡尔距离来估算。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不过这样还是有很大的计算量，我们需要下文说的 Min-Hash 算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对于短篇，k 可以取 5&lt;/li&gt;
&lt;li&gt;对于长篇，k 可以取 10&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;仅作参考，要依据具体情况取舍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;min-hash-算法&#34;&gt;Min-Hash 算法&lt;/h2&gt;
&lt;h3 id=&#34;需求&#34;&gt;需求&lt;/h3&gt;
&lt;p&gt;使用雅卡尔算法比较 Shingle 的哈希依然是缓慢的。假设有 N 篇文档，则需要比较 $N(N-1)/2$ 次，当 $N = 1 million$ 时，需要比较 $5 * 10 ^11$ 次，以一天有 $10^5$ 秒，每秒可以比较 $10^6$ 估算，这将花费五天。如果 N 再大一个数量级，将会花费超过一年的时间。&lt;/p&gt;
&lt;p&gt;Min-Hash 的思想，将大的集合转换成小的「签名」，每个签名中都包含了可以计算相似程度的信息。&lt;/p&gt;
&lt;p&gt;首先需要将集合转换为位数组（0 和 1 组成），0 代表集合中没有这个元素，1 代表集合中有这个元素。&lt;/p&gt;
&lt;p&gt;如此一来，交集就是「按位与运算」，并集就是「按位或运算」。&lt;/p&gt;
&lt;p&gt;再将集合转换为矩阵，每一行表示某一元素（shingles）在不同集合（documents）中是否存在。换言之，每一列表示某一集合包含了哪些元素。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;D1&lt;/th&gt;
          &lt;th&gt;D2&lt;/th&gt;
          &lt;th&gt;&amp;hellip;&lt;/th&gt;
          &lt;th&gt;Dn&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;E1&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;E2&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;En&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;假设有一个哈希函数 h ，可以满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$h(C)$ 足够小，可以将大量的 shingles 放入内存中&lt;/li&gt;
&lt;li&gt;签名 $h(C_1)$ 与 $h(C_2)$ 的相似程度等同于 $sim(C_1, C_2)$&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;$sim(C_1, C_2)$ 表示 $C_1$ 和 $C_2$ 的雅卡尔系数 $\frac{\lvert A \cap B\rvert}{\lvert B \cup A\rvert}$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理想状态下，我们找到的函数 $h(\cdot)$ 满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 $sim(C_1, C_2)$ 很高时，有很大概率 $h(C_1) = h(C_2)$&lt;/li&gt;
&lt;li&gt;当 $sim(C_1, C_2)$ 很低时，有很大概率 $h(C_1) \neq h(C_2)$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基本思路&#34;&gt;基本思路&lt;/h3&gt;
&lt;p&gt;选择一个可以将集合打乱的随机函数 $\pi$ ，它做到 $Pr(h_{\pi}(C_1) = h_{\pi}(C_2)) = sim(C_1, C_2)$ ，满足了我们的需求。&lt;/p&gt;
&lt;h3 id=&#34;证明&#34;&gt;证明&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;证明一&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;集合 $X$ 是一个文档，$y \in X$&lt;/p&gt;
&lt;p&gt;$Pr[\pi(y) = min(\pi(X))] = 1/\lvert X \rvert$&lt;/p&gt;
&lt;p&gt;这里的 $\pi(y) = min(\pi(X))$ 表示在使用 $\pi$ 打乱 X 后，X 中的元素 y 排在第一位。由于每个元素在随机打乱后排在第一位的概率都是均等的，因此等式右边是 $1/\lvert X \rvert$ 。&lt;/p&gt;
&lt;p&gt;容易得到 $Pr(min({\pi}(C_1)) = min({\pi}(C_2))) = \frac{\lvert A \cap B\rvert}{\lvert B \cup A\rvert} = sim(C_1, C_2)$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;证明二&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;可以将两个集合中是否有某种公共元素的情况分为四类&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;D1&lt;/th&gt;
          &lt;th&gt;D2&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;A&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;B&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;C&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;D&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;假设 [a-d] 表示这四类情况的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以发现 $sim(C_1, C_2) = a/(a +b +c)$&lt;/p&gt;
&lt;p&gt;如果将两个集合以相同的方式打乱，再从上向下扫描，第一个碰到的含有 1 的行是 A 类，则说明 $h(D_1) = h(D_2)$ 。&lt;/p&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;example&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/min-hashing-example.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果我们取 100 个 $\pi$ 函数用来打乱，可以为每个文档生成 100 个签名，那就可以把大量的数据压缩到可以接受的程度了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在书中有关于 Min-Hash 实现时需要注意的问题，可以以后再水一篇博客&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;locality-sensitive-hashing&#34;&gt;Locality Sensitive Hashing&lt;/h2&gt;
&lt;h3 id=&#34;基本思路-1&#34;&gt;基本思路&lt;/h3&gt;
&lt;p&gt;找到相似度至少为 $s$ 的文档。&lt;/p&gt;
&lt;p&gt;即使我们已经将所有的文档转换成了很小的签名，然而文档一一配对比较的数量还是太多了，我们依然需要「哈希」和「桶」这两位老朋友。&lt;/p&gt;
&lt;p&gt;可以使用一个函数 $f(\cdot)$ ，$f(x, y)$ 可以分辨 x 和 y 是不是相似文档的候选者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用哈希函数将矩阵的列分装到不同的「桶」中&lt;/li&gt;
&lt;li&gt;所有装在相同的「桶」中的文档是候选者&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以把一列分成不同的条带（band），然后进行多次哈希操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分成更小的条带作用是提高效率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;lsh-bands&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/lsh-bands.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;只要有一次被分配到相同的「桶」，就可以成为候选者&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;lsh-bands1&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/lsh-bands_1.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;假阴性和假阳性&#34;&gt;「假阴性」和「假阳性」&lt;/h3&gt;
&lt;p&gt;「假阴性」：本应被选入而没有被选入&lt;/p&gt;
&lt;p&gt;「假阳性」：本不应被选入而被选入&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在一个条带中的 r 行都匹配的概率为 $s^r$&lt;/li&gt;
&lt;li&gt;在一个条带中至少有一行不匹配的概率为 $1 - s^r$&lt;/li&gt;
&lt;li&gt;在所有条带中都有至少一行不匹配的概率为 $(1 - s^r)^b$&lt;/li&gt;
&lt;li&gt;至少有一个条带的 r 行都匹配（成为候选者）的概率为 $1 - (1 - s^r)^b$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以 s 为横坐标，成为候选者的概率为纵座标，b 和 r 为常量，可以获得一条 S 型曲线。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;lsh-s-curve&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/lsh-s-curve.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当 b 取值为 1 时，S 型曲线将会退化成为过原点的直线&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;取候选者概率为 0.5 ，即 $1 - (1 - s^r)^b = 1/2$&lt;/p&gt;
&lt;p&gt;计算得到 $s = (1 - (\frac{1}{2})^{\frac{1}{b}})^{\frac{1}{r}}$&lt;/p&gt;
&lt;p&gt;由于 $(\frac{1}{2})^{\frac{1}{b}}$ 比较接近 0 ，可以利用等价无穷小来估算 $s \sim (\frac{1}{b})^{\frac{1}{r}}$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在我们的场景下（不可放过抄袭），好的条带划分应该减少假阴性并平衡假阳性的数量。&lt;/p&gt;
&lt;p&gt;假设划分成为 b 个条带，每个条带有 r 行，假设需要比较的两列相似度为 s 。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;lsh-s-curve1&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/lsh-s-curve_1.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mmds.org&#34;&gt;CS246&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Jaccard_index&#34;&gt;Jaccard index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/MinHash&#34;&gt;MinHash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Shingled_magnetic_recording&#34;&gt;SMR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols&#34;&gt;Latex mathematical symbols&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MIT6.S081 Lab: Xv6 and Unix Utilities</title>
      <link>https://vaaandark.top/posts/mit6.s081-labxv6-and-unix-utilities/</link>
      <pubDate>Thu, 02 Mar 2023 23:14:38 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/mit6.s081-labxv6-and-unix-utilities/</guid>
      <description>&lt;p&gt;这是 MIT6.S081 的第一个 Lab ，目的是为了让学生熟悉 Xv6 和 Unix 的一些实用程序，例如 &lt;code&gt;sleep&lt;/code&gt; &lt;code&gt;find&lt;/code&gt; &lt;code&gt;xargs&lt;/code&gt; 等。&lt;/p&gt;
&lt;h2 id=&#34;sleep&#34;&gt;sleep&lt;/h2&gt;
&lt;p&gt;这一关是实现 &lt;code&gt;sleep&lt;/code&gt; 命令。由于在 &lt;code&gt;user/user.h&lt;/code&gt; 目录中给出来了可以直接由 C 语言调用的函数 &lt;code&gt;int sleep(int)&lt;/code&gt; ，这一关非常简单：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/types.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/stat.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;user/user.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *argv[])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; sec;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (argc != &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fprintf(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Usage: sleep secends&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    exit(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  sec = atoi(argv[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (sec &amp;gt;= &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sleep(sec);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fprintf(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Usage: sleep secends&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  exit(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;pingpong&#34;&gt;pingpong&lt;/h2&gt;
&lt;p&gt;这一关是为了让我们熟悉管道的使用，文档中强调了 &lt;code&gt;uses UNIX system calls to &#39;&#39;ping-pong&#39;&#39; a byte between two processes over a pair of pipes, one for each direction&lt;/code&gt; ，所以我们应该创建两个管道，将父子进程的读写交叉连接：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/types.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/stat.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;user/user.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *argv[])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;100&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// parent to child
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; p2c[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// child to parent
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; c2p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  pipe(p2c);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  pipe(c2p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (fork()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// parent
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    close(p2c[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    close(c2p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    write(p2c[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;ping&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    read(c2p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;], buf, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;%d: received pong&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, getpid());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    close(p2c[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    close(c2p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// child
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    close(p2c[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    close(c2p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    read(p2c[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;], buf, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;%d: received ping&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, getpid());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    write(p2c[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;pong&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    close(p2c[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    close(c2p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  exit(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;primes&#34;&gt;primes&lt;/h2&gt;
&lt;p&gt;这一关是使用多进程来实现筛法。本来一开始没懂他是什么意思，结果看到了文档中的一幅图就懂了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;sieve&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/sieve.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;写了个递归调用的函数，但是又不想再包装一层，所以当传入的文件描述符为 &lt;code&gt;-1&lt;/code&gt; 时表示初始化：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/types.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/stat.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;user/user.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define UPPER_BOUND 35
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; send_and_close(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; fd, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; *num, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; count) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  write(fd, num, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt;) * count);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  close(fd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; receive_and_close(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; fd, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; *num) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; res = read(fd, num, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt;) * UPPER_BOUND);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  close(fd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; res / &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; sieve(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; fd) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; num[UPPER_BOUND];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; rec_count = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// if fd &amp;lt; 0, init by building the array first
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (fd &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;; i &amp;lt;= UPPER_BOUND; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      num[rec_count++] = i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    rec_count = receive_and_close(fd, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (rec_count &amp;lt;= &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  pipe(p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (fork() &amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// parent: send numbers
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    close(p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; filter_num = num[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;prime %d&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, filter_num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; send_count = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; rec_count; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (num[i] % filter_num != &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        num[send_count++] = num[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    send_and_close(p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;], num, send_count);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    wait(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// child: receive numbers
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    close(p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sieve(p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *argv[]) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  sieve(-&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  exit(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;find&#34;&gt;find&lt;/h2&gt;
&lt;p&gt;文档中提示了可以参考 &lt;code&gt;user/ls.c&lt;/code&gt; ，所以完全可以照着它抄抄改改，连函数 &lt;code&gt;fmtname&lt;/code&gt; 都可以改写成 &lt;code&gt;filename&lt;/code&gt; 复用。而且由于是改写的 &lt;code&gt;ls&lt;/code&gt; 命令，所以错误处理就不用自己动手了。值得注意的是，在递归调用中要忽略掉 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;..&lt;/code&gt; 目录，不然会有无限递归的情况。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/types.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/stat.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;user/user.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/fs.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *filename(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *path) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; buf[DIRSIZ + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *p;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (p = path + strlen(path); p &amp;gt;= path &amp;amp;&amp;amp; *p != &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;; --p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  p++;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (strlen(p) &amp;gt;= DIRSIZ) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; p;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  memmove(buf, p, strlen(p));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  buf[strlen(p)] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; buf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; find(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *path, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *pattern) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; fd;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; ((fd = open(path, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;)) &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fprintf(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;find: cannot open %s&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, path);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (strcmp(filename(path), pattern) == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, path);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; stat st;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (fstat(fd, &amp;amp;st) &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fprintf(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;find: cannot stat %s&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, path);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;512&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; dirent de;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (st.type == T_DIR) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt;(strlen(path) + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; + DIRSIZ + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt; buf){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;ls: path too long&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      strcpy(buf, path);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *p = buf + strlen(buf);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      *p++ = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt; (read(fd, &amp;amp;de, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(de)) == &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(de)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (de.inum == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (strcmp(de.name, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;) == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt; || strcmp(de.name, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;..&amp;#34;&lt;/span&gt;) == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        memmove(p, de.name, strlen(de.name));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        p[strlen(de.name)] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        find(buf, pattern);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  close(fd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *argv[])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (argc != &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;find: wrong argumens&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  find(argv[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;], argv[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  exit(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当我删掉对 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;..&lt;/code&gt; 目录的判断时，发现 Xv6 可以在崩溃后报错这是个无限递归，有时间可以研究一下是怎么实现的。我猜测是对栈和 &lt;code&gt;call&lt;/code&gt; 指令进行了统计。&lt;/p&gt;
&lt;h2 id=&#34;xargs&#34;&gt;xargs&lt;/h2&gt;
&lt;p&gt;这一关是完成命令 &lt;code&gt;xargs&lt;/code&gt; ，文档对这个实现的要求很低，不要求实现 &lt;code&gt;-n&lt;/code&gt; 选项。所以可以直接将所有的 &lt;code&gt;&#39; &#39;&lt;/code&gt; 和 &lt;code&gt;&#39;\t&#39;&lt;/code&gt; 换成 &lt;code&gt;&#39;\0&#39;&lt;/code&gt; ，这样一来就可以复用缓冲区，直接将 &lt;code&gt;cmd&lt;/code&gt; 数组的每个元素指向 &lt;code&gt;buf&lt;/code&gt; 的某个位置即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/param.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;kernel/types.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;user/user.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *argv[])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *cmd[MAXARG];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1024&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; cmd_cnt = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &amp;lt; argc; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cmd[cmd_cnt++] = argv[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; len = read(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, buf, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt; buf);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  buf[len] = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (len &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fprintf(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;xargs: input error&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    exit(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *start = buf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *p = buf; *p != &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;; ++p) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (*p == &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; || *p == &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\t&amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      *p++ = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      cmd[cmd_cnt++] = start;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      start = p;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (*p == &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      *p++ = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      cmd[cmd_cnt++] = start;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      cmd[cmd_cnt] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      start = p;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      cmd_cnt = argc - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (fork() == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        exec(cmd[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;], cmd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        wait(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  exit(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Awesome WM 基于迭代器的小组件</title>
      <link>https://vaaandark.top/posts/awesomewm-widget-with-iterator/</link>
      <pubDate>Sat, 25 Feb 2023 13:26:44 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/awesomewm-widget-with-iterator/</guid>
      <description>&lt;p&gt;由于 i3wm 支持的功能有限，定制性并没有那么强大，最近换成使用 Awesome WM 了，它使用 Lua 作为配置语言，所以可配置性极强。举个例子，i3wm 配置无法像真正的编程语言一样使用 &lt;code&gt;if ... else&lt;/code&gt; 语句等，但 Awesome WM 可以，对于同一个快捷键就可以在不同时候有不同的功能。&lt;/p&gt;
&lt;p&gt;Awesome WM 对多显示器支持很好，在官网上还有一个便捷切换显示器的&lt;a href=&#34;https://awesomewm.org/recipes/xrandr/&#34;&gt;脚本&lt;/a&gt;。这个脚本写得非常地巧妙，可以绑定到一个快捷键，每次按都能弹出通知，显示即将使用的显示器布局，当切换到想要的布局后停止按键就可以应用这一布局了。这利用的是 Notification 弹窗如果没有被响应时调用回调函数的特性。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;demo&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/notify.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;Awesome WM 的通知使用的是 &lt;code&gt;naughty&lt;/code&gt; 模块，它包装了一系列很有用的功能，在 Awesome WM 的 API 文档中介绍了 &lt;code&gt;naughty.notify&lt;/code&gt; 的&lt;a href=&#34;https://awesomewm.org/doc/api/libraries/naughty.html#notify&#34;&gt;用法&lt;/a&gt;，如下是传入参数的一些字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;replaces_id&lt;/code&gt;: (int) Replace the notification with the given ID. (optional)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;destroy&lt;/code&gt;: (func) Function to run when notification is destroyed. (optional)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;replaces_id&lt;/code&gt; 可以用于替代上一个 Notification ，这样就有一种轮换的效果了；&lt;code&gt;destroy&lt;/code&gt; 是当这个通知消失时的动作，它有一个传入的参数 &lt;code&gt;reason&lt;/code&gt; 表示它消失的原因，可以通过这个来过滤非超时消失的情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; naughty_destroy_callback(reason)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; reason == naughty.notificationClosedReason.expired &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以照猫画虎，实现一个 &lt;code&gt;exit.lua&lt;/code&gt; ，在模块内部实现一个类似迭代的效果，每次调用 &lt;code&gt;exit&lt;/code&gt; 函数都会改变模组内部变量的状态：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; spawn = require(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;awful.spawn&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; naughty = require(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;naughty&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; icon_path = os.getenv(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;HOME&amp;#34;&lt;/span&gt;) .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;/.config/awesome/images/power.png&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; state = { cid = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;nil&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; lock_command = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;$HOME/.local/bin/fancy-lock &amp;amp;&amp;amp; sleep 1 &amp;amp;&amp;amp; &amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; lock = { &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Lock&amp;#34;&lt;/span&gt;, lock_command }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; shutdown = { &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Shut down&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;shutdown now&amp;#34;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; reboot = { &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Reboot&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;systemctl reboot&amp;#34;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; suspend = { &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Suspend&amp;#34;&lt;/span&gt;, lock_command .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;systemctl suspend&amp;#34;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; hibernate = { &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Hibernate&amp;#34;&lt;/span&gt;, lock_command .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;systemctl hibernate&amp;#34;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; menu()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; { lock, shutdown, reboot, suspend }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; naughty_destroy_callback(reason)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; reason == naughty.notificationClosedReason.expired &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; action = state.index and state.menu[state.index - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;][&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; action &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      spawn(string.format(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;sh -c &lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, action), &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;false&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      state.index = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; exit()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; not state.index &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    state.menu = menu()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    state.index = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; label, action
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; next = state.menu[state.index]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  state.index = state.index + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; not next &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    label = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;Do nothing&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    state.index = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    label, action = next[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;], next[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  state.cid = naughty.notify({
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    title = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Awesome WM Exit&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    text = string.format(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;  &amp;lt;span color=&amp;#39;yellow&amp;#39; weight=&amp;#39;bold&amp;#39;&amp;gt;%-10s ?&amp;lt;/span&amp;gt;&amp;#34;&lt;/span&gt;, label),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    icon = icon_path,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    timeout = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    screen = mouse.screen,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    replaces_id = state.cid,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    destroy = naughty_destroy_callback
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }).id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  exit = exit,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  commands = {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    lock = lock,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    shutdown = shutdown,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    reboot = reboot,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    suspend = suspend,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    hibernate = hibernate
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Btrfs 为什么是神？</title>
      <link>https://vaaandark.top/posts/why-btrfs-is-awesome/</link>
      <pubDate>Sat, 25 Feb 2023 13:06:17 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/why-btrfs-is-awesome/</guid>
      <description>&lt;p&gt;最近发现 Windows 这几个月开机不超过 10 次，寻思着将 Windows 中的空间挪一点到 Linux 中来。说干就干，在 Windows 里面划出来了 80 GB 的空间。&lt;/p&gt;
&lt;p&gt;遗憾地，这 80 GB 空间物理上在我需要扩容的空间的前面，由于开头的扇区存放有很多元数据，因此是不能简单扩容的，只能寻求其他的方法。&lt;/p&gt;
&lt;p&gt;多亏了我使用的文件系统是 Btrfs ，直接一条命令就可以了 &lt;code&gt;btrfs device add /dev/nvme0n1p9 /home&lt;/code&gt; ，根本不需要修改 &lt;code&gt;/etc/fstab&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;Btrfs 的其他特性，就留到以后探索吧！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rust 自引用结构</title>
      <link>https://vaaandark.top/posts/rust-self-referencing-structure/</link>
      <pubDate>Thu, 23 Feb 2023 21:44:37 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/rust-self-referencing-structure/</guid>
      <description>&lt;p&gt;今天和朋友交流的时候遇到了自引用问题，之前就在看 &lt;em&gt;Rust Bible&lt;/em&gt; 的时候看到过，但是一直没用 Rust 写过什么数据结构，所以没有使用这个的机会，所以今天就来尝试一下。&lt;/p&gt;
&lt;p&gt;首先需要实现的结构体如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; Person {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;String&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    first_name: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;str&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    last_name: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;str&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 &lt;code&gt;first_name&lt;/code&gt; 和 &lt;code&gt;last_name&lt;/code&gt; 的生命周期应该短于 &lt;code&gt;name&lt;/code&gt; 和整个结构体的生命周期。这里使用不同的生命周期标注其实意义不大，它怎么也不能在一个函数中成功创建并返回。因为想要生成一个 slice 必须借用一个 String ，但当这个 String 被 move 进入 &lt;code&gt;Person&lt;/code&gt; 结构体时，与之相关的 slice 全部失效了。&lt;/p&gt;
&lt;p&gt;所以软的不行只能来硬的，直接使用 &lt;code&gt;unsafe&lt;/code&gt; ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#[derive(Debug)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#[allow(unused)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; Person&amp;lt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt;&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;String&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    first_name: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;str&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    last_name: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;str&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;impl&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt;&amp;gt; Person&amp;lt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt;&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; new(s: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;String&lt;/span&gt;) -&amp;gt; Person&amp;lt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt;&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; (first, last) = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;match&lt;/span&gt; s.find(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Some&lt;/span&gt;(pos) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                s.split_at(pos)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;None&lt;/span&gt; =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                (s.as_str(), s.as_str())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; first = first &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;as&lt;/span&gt; *&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;str&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; last = last &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;as&lt;/span&gt; *&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;str&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsafe&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Person { name: s, first_name: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;*first, last_name: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;*last }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; main() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; p = Person::new(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Linus Torvalds&amp;#34;&lt;/span&gt;.to_string());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    println!(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;{:?}&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;先将引用转成 raw point ，这就避免了它在 ponitee 被移动后失效。之后直接使用 unsafe ，再将指针转成引用即可。&lt;/p&gt;
&lt;p&gt;虽然很蛋疼，但这就是 Rust ，&lt;strong&gt;Love it or leave it!&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MIT6.S081 实验环境配置</title>
      <link>https://vaaandark.top/posts/mit6.s081-setup-environment/</link>
      <pubDate>Tue, 21 Feb 2023 14:59:14 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/mit6.s081-setup-environment/</guid>
      <description>&lt;p&gt;最近开始学习操作系统的相关知识，选择学 MIT6.S081 的课程。&lt;/p&gt;
&lt;p&gt;首先在 &lt;a href=&#34;https://pdos.csail.mit.edu/6.S081/2020/labs/util.html&#34;&gt;课程官方网站&lt;/a&gt; 上拉取仓库配置环境。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ git clone git://g.csail.mit.edu/xv6-labs-2020
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;cd&lt;/span&gt; xv6-labs-2020
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ git checkout util
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make qemu
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;make&lt;/code&gt; 时发现有报错：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user/sh.c: In function ‘runcmd’:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user/sh.c:58:1: error: infinite recursion detected [-Werror=infinite-recursion]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   58 | runcmd(struct cmd *cmd)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      | ^~~~~~
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;打开该文件发现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// Execute cmd.  Never returns.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;runcmd(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; cmd *cmd)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里已经注释说明了这个函数不返回，但是并没有告诉编译器，因此应该加上注解：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// Execute cmd.  Never returns.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;__attribute__ ((noreturn))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;runcmd(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; cmd *cmd)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在就可以 &lt;code&gt;make&lt;/code&gt; 成功了。&lt;/p&gt;
&lt;p&gt;但是又有了新的问题， &lt;code&gt;qemu&lt;/code&gt; 无法加载系统，发现该项目最好在 Ubuntu20.04 上运行，我查看了一下 Ubuntu20.04 的 qemu 版本，是 4.2.1 ，比 Fedora 36 的低很多，我干脆直接编译安装得了。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://download.qemu.org/&#34;&gt;qemu 官网&lt;/a&gt; 安装 4.2.1 ，并安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ./configure --prefix=/home/vandark/.local
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make -j8 &amp;amp;&amp;amp; make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;报错没有选项 &lt;code&gt;-nopie&lt;/code&gt; 很明显是 &lt;code&gt;GCC&lt;/code&gt; 的版本高了，现在的选项是 &lt;code&gt;--no-pie&lt;/code&gt; ，在 &lt;code&gt;config-host.mak&lt;/code&gt; 修改就可以编译成功了。&lt;/p&gt;
&lt;p&gt;最后就可以进入了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make qemu
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xv6 kernel is booting
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;hart 1 starting
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;hart 2 starting
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;init: starting sh
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Lua 打印 Table</title>
      <link>https://vaaandark.top/posts/lua-print-table/</link>
      <pubDate>Sat, 11 Feb 2023 14:36:27 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/lua-print-table/</guid>
      <description>&lt;p&gt;之前在 Lua 代码的编写中写过一些打印表的函数用于调试，这次在看 z.lua 的实现中看到了非常完美的打印表的方法，于是在将代码改得更规范后记录一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;luacheck&lt;/code&gt; 检查 Lua 代码中的错误和不规范之处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; print_table(table, level)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; key = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; func
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  func = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt;(t, l)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    l = l or &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; indent = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; _ = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, l &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt; indent = indent .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;  &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; key ~= &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      print(indent .. key .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;{&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      print(indent .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;{&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    key = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; k, v &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;in&lt;/span&gt; pairs(t) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; type(v) == &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;table&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        key = k
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        func(v, l + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; content = string.format(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;%s%s = %s&amp;#34;&lt;/span&gt;, indent .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;  &amp;#34;&lt;/span&gt;, tostring(k),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                      tostring(v))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(content)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(indent .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  func(table, level)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print_table({{&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;}, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    1 = {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      1 = 1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      2 = 2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      3 = 3
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    2 = 4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    3 = 5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Lua 中的三目运算</title>
      <link>https://vaaandark.top/posts/lua-ternary-arithmetic/</link>
      <pubDate>Thu, 09 Feb 2023 13:52:51 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/lua-ternary-arithmetic/</guid>
      <description>&lt;p&gt;在看 &lt;a href=&#34;https://github.com/skywind3000&#34;&gt;skywind3000&lt;/a&gt; 大神写的 z.lua 时发现了神秘写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;os.argv = arg ~= &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;nil&lt;/span&gt; and arg or {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;os.path.sep = windows and &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;&lt;/span&gt; or &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不需要怎么思考就能知道这个是三目运算。但是在我认知中，Lua 是不支持三目运算符的，定睛一看才发现这个是通过 Lua 布尔运算中的短路特性模拟的三目运算。&lt;/p&gt;
&lt;h2 id=&#34;lua-中的短路特性&#34;&gt;Lua 中的短路特性&lt;/h2&gt;
&lt;p&gt;短路运算的意思是只有在需要的情况下才去检查条件，例如 &lt;code&gt;a and b&lt;/code&gt; 当 &lt;code&gt;a = false&lt;/code&gt; 时就不需要检查 &lt;code&gt;b&lt;/code&gt; 了，或者是 &lt;code&gt;a or b&lt;/code&gt; 当 &lt;code&gt;a = true&lt;/code&gt; 时也不用检查 &lt;code&gt;b&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;Lua 中的短路特性与 C 不同点在于，Lua 的布尔操作结果并不只是「真」和「假」。&lt;/p&gt;
&lt;p&gt;例如在 C 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; a = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt; || &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#007f7f&#34;&gt;// a 的值是 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而在 Lua 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; a = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt; or &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;-- a 的值是 4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; b = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt; and &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#007f7f&#34;&gt;-- a 的值是 2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Lua 将 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 当作「假」，其余值都视作「真」（包括 0 ）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而，Lua 的布尔运算返回的是原值，而不是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。我推测这与 Lua 将 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 都当作「假」有关，如果布尔运算返回了 &lt;code&gt;false&lt;/code&gt; ，那 &lt;code&gt;nil&lt;/code&gt; 的语意就变化了。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nil 是 Lua 特殊的类型，它可能的值只有 nil ，它不在本文讨论范围之中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;lua-三目运算的原理&#34;&gt;Lua 三目运算的原理&lt;/h2&gt;
&lt;p&gt;下面可以通过例子来说明 &lt;code&gt;a and b or c&lt;/code&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;a = true&lt;/code&gt; 时，这时 &lt;code&gt;a and b&lt;/code&gt; 的值为 a ，由于后续是 &lt;code&gt;or&lt;/code&gt; ，所以可以直接是 c&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;a = false&lt;/code&gt; 时，这时 &lt;code&gt;a and b&lt;/code&gt; 的值为 b ，由于后续是 &lt;code&gt;or&lt;/code&gt; ，&lt;del&gt;所以可以直接是 b&lt;/del&gt; ，&lt;strong&gt;注意这里有个坑等下说&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lua-三目运算的陷阱&#34;&gt;Lua 三目运算的陷阱&lt;/h2&gt;
&lt;p&gt;在前文中提到，当 &lt;code&gt;a = true&lt;/code&gt; 时有坑。当 b 为 false 时，后续是 &lt;code&gt;or&lt;/code&gt; 所以最后的值是 c 。这就是 Lua 的三目运算模拟方法失效的场景。&lt;/p&gt;
&lt;p&gt;由于 Lua 是一门与 table 结合非常深的语言，我们可以想到利用 table 来解决这一问题，因为 table 在布尔运算中只可能是 &lt;code&gt;nil&lt;/code&gt; 和 非&lt;code&gt;nil&lt;/code&gt; （表是否为空），只要创造出一个不为空的表，就可以避免之前的 &lt;code&gt;b = false&lt;/code&gt; 的情况出现了。&lt;/p&gt;
&lt;p&gt;所以最后的解决办法就是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(a and {b} or {c})[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于表 &lt;code&gt;{b}&lt;/code&gt; 和 &lt;code&gt;{c}&lt;/code&gt; 不可能是空表，所以就不会「掉坑」。&lt;/p&gt;
&lt;p&gt;最后说一句，Lua 真是太奇妙了！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 Rust 重写星际译王</title>
      <link>https://vaaandark.top/posts/rewrite-stardict-in-rust/</link>
      <pubDate>Wed, 25 Jan 2023 13:21:35 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/rewrite-stardict-in-rust/</guid>
      <description>&lt;p&gt;我经常有在终端查单词的需求，之前使用的是自己写的网络爬虫，原理是构造网址 &amp;ldquo;&lt;a href=&#34;https://www.youdao.com/result?word=%7B%7D&amp;amp;lang=en%22&#34;&gt;https://www.youdao.com/result?word={}&amp;amp;lang=en&amp;quot;&lt;/a&gt; 并访问，再通过解析 Html 文件获得单词解释。一个朋友说他用的是 sdcv ，星际译王的终端版本，可以支持离线词典。我也时常脱机工作，对离线词典的需求也不小，所以打算自己写一个支持 StarDict 格式离线词典的软件。&lt;/p&gt;
&lt;p&gt;代码仓库：https://github.com/vaaandark/rmall&lt;/p&gt;
&lt;h2 id=&#34;stardict-格式&#34;&gt;StarDict 格式&lt;/h2&gt;
&lt;p&gt;以朗道英汉字典为例，在解压下载得到的压缩包之后可以看到其目录结构为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;langdao-ec-gb
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── langdao-ec-gb.dict.dz
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── langdao-ec-gb.idx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└── langdao-ec-gb.ifo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1 directory, 3 files
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中有三种文件：&lt;code&gt;.dict.dz&lt;/code&gt; 是压缩后的字典文件，&lt;code&gt;.idx&lt;/code&gt; 是索引文件，&lt;code&gt;.ifo&lt;/code&gt; 保存了该字典的信息。&lt;/p&gt;
&lt;h3 id=&#34;ifo-文件&#34;&gt;.ifo 文件&lt;/h3&gt;
&lt;p&gt;首先可以看一下 &lt;code&gt;langdao-ec-gb.ifo&lt;/code&gt; 文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;StarDict&amp;#39;s dict ifo file
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;version=2.4.2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wordcount=435468
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;idxfilesize=10651674
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bookname=朗道英汉字典5.0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;author=上海朗道电脑科技发展有限公司
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;description=罗小辉破解文件格式，胡正制作转换程序。
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;date=2003.08.26
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sametypesequence=m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在查找相关资料后可以看到这些字段的填写要求：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bookname=      // required
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wordcount=     // required
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;synwordcount=  // required if &amp;#34;.syn&amp;#34; file exists.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;idxfilesize=   // required
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;idxoffsetbits= // New in 3.0.0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;author=
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;email=
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;website=
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;description=    // You can use &amp;lt;br&amp;gt; for new line.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;date=
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sametypesequence= // very important.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dicttype=
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最为重要的是 &lt;code&gt;version&lt;/code&gt; 字段，因为如今只支持 &lt;code&gt;2.4.2&lt;/code&gt; 和 &lt;code&gt;3.0.0&lt;/code&gt; 两个版本，而这两个版本索引文件格式又略有不同。&lt;/p&gt;
&lt;h3 id=&#34;idx-文件&#34;&gt;.idx 文件&lt;/h3&gt;
&lt;p&gt;再看看 &lt;code&gt;.idx&lt;/code&gt; 的索引文件，StarDict 的文档说它是由很多条目(entries)组成，每个条目由一个不定长的单词字符串加两个数字组成。其中字符串以 &lt;code&gt;\0&lt;/code&gt; 结尾，两个数字分别为该单词在字典文件中的偏移(offset)和大小(size)。&lt;/p&gt;
&lt;p&gt;上文提到了不同版本的索引文件略有不同，在 &lt;code&gt;2.4.2&lt;/code&gt; 中数字是 32 位的无符号整型，在 &lt;code&gt;3.0.0&lt;/code&gt; 中数字是 64 位的无符号整型。&lt;/p&gt;
&lt;p&gt;所以我可以先用 Lua 脚本大致看一下它的结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#!/usr/bin/env lua&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- Usage: ./idx.lua path/to/idx&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;--        or version 3.0.0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;--        ./idx.lua path/to/idx -3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; f = arg[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; pattern = arg[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;] == &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;-3&amp;#39;&lt;/span&gt; and &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;gt;zI8I8&amp;#34;&lt;/span&gt; or &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&amp;gt;zI4I4&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;f = assert(io.open(f, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;rb&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; contents = f:read(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; now
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; word, offset, size
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt; not now or now &amp;lt; #contents &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  word, offset, size, now = string.unpack(pattern, contents, now)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  print(string.format(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;%-50s | %8d | %4d&amp;#34;&lt;/span&gt;, word, offset, size))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;f:close()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行这个小工具可以看到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ./idx.lua ~/.config/rmall/00-langdao-ec-gb/langdao-ec-gb.idx | head
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a                                                  |        0 |  132
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;A and B agglutinogens                              |      132 |   24
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;A AND NOT B gate                                   |      156 |   19
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;A as well as B                                     |      175 |   28
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;A B. S. pill                                       |      203 |   45
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a back number                                      |      248 |   29
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a bad actor                                        |      277 |   20
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a bad egg                                          |      297 |    6
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a bad hat                                          |      303 |    6
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a bad job                                          |      309 |   15
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;dictdz-文件&#34;&gt;.dict.dz 文件&lt;/h3&gt;
&lt;p&gt;这个文件本质是由 gzip 压缩后的文件，所以只需使用 &lt;code&gt;gzip -d&lt;/code&gt; 解压之后就可以看到它其实是一个文本文件。&lt;/p&gt;
&lt;p&gt;当我们需要查词时，根据上文提到的索引文件中的 &lt;code&gt;offset&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; 就直接知道了单词释义的位置。&lt;/p&gt;
&lt;h2 id=&#34;小插曲&#34;&gt;小插曲&lt;/h2&gt;
&lt;h3 id=&#34;使用-rust-读取-idx&#34;&gt;使用 Rust 读取 .idx&lt;/h3&gt;
&lt;p&gt;使用 Rust 读取二进制文件并不是件很难的事情，但是由于有两种版本的 StarDict 文件，如果使用两个函数分别解析就很麻烦，所以需要使用 Rust 的泛型特性。&lt;/p&gt;
&lt;p&gt;首先弄明白需求，需求就是该函数同时支持读取 4 个字节和 8 个字节的数字，同时要满足读取不定长的字符串。&lt;/p&gt;
&lt;p&gt;由于使用了函数 &lt;code&gt;from_be_bytes&lt;/code&gt; 来通过大端序读入，它是 &lt;code&gt;u32&lt;/code&gt; 和 &lt;code&gt;u64&lt;/code&gt; 等数字类型的方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u32::from_be_bytes&lt;/code&gt; 的函数签名是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Rust&#34; data-lang=&#34;Rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; from_be_bytes(bytes: [&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u8&lt;/span&gt;; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;]) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;u64::from_be_bytes&lt;/code&gt; 的函数签名是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Rust&#34; data-lang=&#34;Rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; from_be_bytes(bytes: [&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u8&lt;/span&gt;; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;]) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;遗憾地，由于这个函数签名的原因，我没有想到只使用一个泛型参数的方法，只能使用两个，一个是类型 T ，一个是表示数组长度的常量 N 。&lt;/p&gt;
&lt;p&gt;更加遗憾地，标准库中的 &lt;code&gt;from_be_bytes&lt;/code&gt; 不属于任何一个 trait ，想要将 &lt;code&gt;u32&lt;/code&gt; 和 &lt;code&gt;u64&lt;/code&gt; 这样能从字节读入的数据抽象到一起还并不简单。好在经过 Google 找到了一个叫做 &lt;code&gt;eio&lt;/code&gt; 的 crate ，它有着 trait &lt;code&gt;FromBytes&lt;/code&gt; ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Rust&#34; data-lang=&#34;Rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;trait&lt;/span&gt; FromBytes&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; N: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;usize&lt;/span&gt;&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; from_be_bytes(bytes: [&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u8&lt;/span&gt;; N]) -&amp;gt; Self;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; from_le_bytes(bytes: [&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u8&lt;/span&gt;; N]) -&amp;gt; Self;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以我的 &lt;code&gt;read_bytes&lt;/code&gt; 函数终于成型了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Rust&#34; data-lang=&#34;Rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; read_bytes&amp;lt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; N: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;usize&lt;/span&gt;, T&amp;gt;(path: PathBuf) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Result&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Vec&lt;/span&gt;&amp;lt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;String&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;usize&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;usize&lt;/span&gt;)&amp;gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    T: FromBytes&amp;lt;N&amp;gt; + TryInto&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;usize&lt;/span&gt;&amp;gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &amp;lt;T &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;as&lt;/span&gt; TryInto&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;usize&lt;/span&gt;&amp;gt;&amp;gt;::Error: Debug,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; f = File::open(path).map_err(|_| Error::CannotOpenIdxFile)?;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; f = BufReader::new(f);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; items: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Vec&lt;/span&gt;&amp;lt;_&amp;gt; = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Vec&lt;/span&gt;::new();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; buf: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Vec&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u8&lt;/span&gt;&amp;gt; = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Vec&lt;/span&gt;::new();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Ok&lt;/span&gt;(n) = f.read_until(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &amp;amp;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; buf) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; n == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        buf.pop();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; word = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;String&lt;/span&gt;::new();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        buf.iter().for_each(|x| word.push(*x &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        buf.clear();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; b = [&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; N];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        f.read(&amp;amp;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; b).map_err(|_| Error::IdxFileParsingError)?;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; offset = T::from_be_bytes(b).try_into().unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; b = [&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; N];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        f.read(&amp;amp;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; b).map_err(|_| Error::IdxFileParsingError)?;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; size = T::from_be_bytes(b).try_into().unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        items.push((word, offset, size))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Ok&lt;/span&gt;(items)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里将 &lt;code&gt;u32&lt;/code&gt; 和 &lt;code&gt;u64&lt;/code&gt; 类型 &lt;code&gt;try_into&lt;/code&gt; 成 usize ，使用了 &lt;code&gt;unwrap()&lt;/code&gt; ，因此需要 &lt;code&gt;&amp;lt;T as TryInto&amp;lt;usize&amp;gt;&amp;gt;::Error: Debug&lt;/code&gt; ，而实际上这里的转换是并不会 panic 的。&lt;/p&gt;
&lt;h3 id=&#34;关于字典序的乌龙&#34;&gt;关于「字典序」的乌龙&lt;/h3&gt;
&lt;p&gt;字典序是指按照单词出现在字典的顺序进行排序的方法。&lt;/p&gt;
&lt;p&gt;学过离散数学的都知道字典序是一种全序，学过任何一种编程语言的也知道，在编程语言中比较两个字符串的大小一般都是利用字典序。&lt;/p&gt;
&lt;p&gt;在 C 语言中，&lt;code&gt;strcmp()&lt;/code&gt; 函数就是对每个字符的大小进行比较，如果当前字符相同就比较下一个，直到比较出来大小。&lt;/p&gt;
&lt;p&gt;这样的严格按 ASCII 表的字典序其实不是现实世界中字典的样子。举个例子，单词 China 和 china 这两个单词如果按照编程语言的字典序来排绝不会在相邻的地方。因为 C 是 103 而 c 是 143 ，对以 c(C) 开头的单词排序，一定是所有以大写 C 开头的单词排列完成后再是以小写 c 开头的单词，这和我们经常看到的英文词典实际情况不同。&lt;/p&gt;
&lt;p&gt;因此现实世界中的「字典序」应该是先忽略大小写进行排序，相同单词再考虑大小写，这样能保证只是大小写不同的单词会在一起。&lt;/p&gt;
&lt;p&gt;在一开始写查找单词的时候，我直接使用 &lt;code&gt;binary_search_by_key&lt;/code&gt; 来查找：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Rust&#34; data-lang=&#34;Rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; lookup(&amp;amp;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt; self, word: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;str&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;str&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Ok&lt;/span&gt;(pos) = self.idx.items.binary_search_by_key(&amp;amp;word, |x| &amp;amp;x.&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; (_, offset, size) = self.idx.items[pos];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self.dict.get(offset, size)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        panic!();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样做的后果就是查不到大部分的单词，我还以为是 &lt;code&gt;.idx&lt;/code&gt; 文件不规范，但我仔细思考后发现了「字典序」的乌龙后就改变了写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Rust&#34; data-lang=&#34;Rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; lookup(&amp;amp;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt; self, word: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;str&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Result&lt;/span&gt;&amp;lt;&amp;amp;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;a&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;str&lt;/span&gt;&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Ok&lt;/span&gt;(pos) = self.idx.items.binary_search_by(|probe| {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        probe
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .to_lowercase()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .cmp(&amp;amp;word.to_lowercase())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .then(probe.&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.&lt;/span&gt;as_str().cmp(&amp;amp;word))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; (_, offset, size) = self.idx.items[pos];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Ok&lt;/span&gt;(self.dict.get(offset, size))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Err&lt;/span&gt;(Error::WordNotFound(self.ifo.bookname.to_string()))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;多字典支持&#34;&gt;多字典支持&lt;/h3&gt;
&lt;p&gt;之前暂时没有在程序中集成多字典，但是可以通过 Shell 脚本实现类似的效果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;word=&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;$1&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; i in langdao-ec-gb oxford-gb cdict-gb kdic-computer-gb; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; rmall lookup -l &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;$HOME&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;/.config/rmall/&lt;/span&gt;$i&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;$word&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;exit&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rmall lookup &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;$word&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查词时就会按照相应的离线词典优先级查找，如果都没找到则使用电子词典。&lt;/p&gt;
&lt;p&gt;现在集成了多字典功能，可以将词典目录分别命名为 &lt;code&gt;00-XXX&lt;/code&gt;, &lt;code&gt;01-YYY&lt;/code&gt;, &amp;hellip;, &lt;code&gt;99-ZZZ&lt;/code&gt; 这样的格式来实现优先级。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ rmall -L terraria
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error: WordNotFound(&amp;#34;朗道英汉字典5.0&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error: WordNotFound(&amp;#34;牛津现代英汉双解词典&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error: WordNotFound(&amp;#34;CDICT5英汉辞典&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error: WordNotFound(&amp;#34;计算机词汇&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;terraria
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;英 / tɛˈrɛːrɪə / 美 / tɛˈrɛːrɪə /
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 泰拉瑞亚（游戏名）
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; Xbox Live ArcadeMarch 27, 2013PlayStation VitaLate Fall 2013iOSAugust 29, 2013http://www.terrariaonline.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/huzheng001/stardict-3/blob/master/dict/doc/StarDictFileFormat&#34;&gt;StarDict 字典格式&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mailx 和 Swaks 的使用</title>
      <link>https://vaaandark.top/posts/mailx-and-swaks/</link>
      <pubDate>Wed, 18 Jan 2023 21:12:39 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/mailx-and-swaks/</guid>
      <description>&lt;p&gt;按照 Mailx 自己的介绍，它是一个增强了的 Mail 命令，提供了更多的功能。&lt;/p&gt;
&lt;p&gt;常规用法是： &lt;code&gt;mailx -s &amp;quot;{{subject}}&amp;quot; {{to_addr}}&lt;/code&gt;，通过配置之后可以使用邮箱运营商的服务器发送邮件。&lt;/p&gt;
&lt;p&gt;以使用 QQ 邮箱为例，可以编辑 &lt;code&gt;/etc/mail.rc&lt;/code&gt; 的全局配置文件，也可以编辑 &lt;code&gt;~/.mailrc&lt;/code&gt; 的本地配置文件。&lt;/p&gt;
&lt;p&gt;如果使用本地的配置文件，首先要将全局配置文件复制到本地：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cp /etc/mail.rc .mailrc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后编辑 &lt;code&gt;.mailrc&lt;/code&gt; 文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# ~/.mailrc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set from={{your_email_address}}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set smtp=smtps://smtp.qq.com:465
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set smtp-auth=login
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set smtp-auth-user={{your_email_address}}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set smtp-auth-password={{authorization_code}}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set ssl-verify=ignore
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的授权码是 QQ 邮箱用于登录第三方客户端的，并不是 QQ 邮箱密码：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;mailx&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/mailx.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后可以发个邮件测试一下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ mailx -s &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;Mailx Test&amp;#39;&lt;/span&gt; {{to_addr}} &amp;lt;&amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;This is a test to check if mailx works well.&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在朋友的推荐下，我知道了有另一个功能强大而且 standalone 的包 &lt;code&gt;swaks&lt;/code&gt; ，它只依赖于 perl 解释器：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;swaks&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/swaks.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;和 &lt;code&gt;mailx&lt;/code&gt; 的配置类似，它需要修改 &lt;code&gt;.swaksrc&lt;/code&gt; 文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--from {{your_email_address}}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--server smtp.qq.com
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--auth-user {{your_qq}}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--auth-password {{authorization_code}}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样可以发个邮件测试一下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;swaks --to {{to_addr}} --h-Subject &amp;#39;Swaks Test&amp;#39; --body &amp;#39;This is a test for swaks&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>SQLite 入门（持续更新）</title>
      <link>https://vaaandark.top/posts/sqlite-introduction/</link>
      <pubDate>Thu, 05 Jan 2023 17:37:03 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/sqlite-introduction/</guid>
      <description>&lt;p&gt;最近想写一个小工具，需要用到 SQLite 。之前只会一点点的 &lt;code&gt;INSERT&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; ，现在想正式入门。&lt;/p&gt;
&lt;h2 id=&#34;点命令&#34;&gt;点命令&lt;/h2&gt;
&lt;p&gt;点命令不以 &lt;code&gt;;&lt;/code&gt; 结束，它们一般并不直接操作数据库。&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;.help&lt;/code&gt; 来看可以使用的点命令。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/sqlite/sqlite-commands.html&#34;&gt;菜鸟教程 SQLite 点命令&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;sqlite-语句&#34;&gt;SQLite 语句&lt;/h2&gt;
&lt;p&gt;这些与数据库直接进行交互的命令包括 &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, 和 &lt;code&gt;DROP&lt;/code&gt; ，可以根据操作性质分为三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DDL - 数据定义语言&lt;/li&gt;
&lt;li&gt;DML - 数据操作语言&lt;/li&gt;
&lt;li&gt;DQL - 数据查询语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的 SQLite 语言可以以任何关键字开始，以 &lt;code&gt;;&lt;/code&gt; 结束。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/sqlite/sqlite-intro.html&#34;&gt;菜鸟教程 SQLite&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.sqlite.org/index.html&#34;&gt;SQLite 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.sqlitetutorial.net/&#34;&gt;SQLite Tutorial&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>内联汇编</title>
      <link>https://vaaandark.top/posts/inline-assembly/</link>
      <pubDate>Mon, 02 Jan 2023 16:27:19 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/inline-assembly/</guid>
      <description>&lt;p&gt;高中第一次看到在 C 语言中嵌入汇编语言时，我就觉得它非常好玩，到大学刚开学的时候，我甚至有使用它的需求，可惜直到现在我才抽出时间开始学习它。&lt;/p&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;p&gt;在 GNU 的 GCC 中，内联汇编被分为两类：&lt;strong&gt;Basic asm&lt;/strong&gt; 和 &lt;strong&gt;Extended asm&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;GCC 的官方文档中写到，在函数中混合使用 C 语言和汇编语言时，最好使用扩展形式；但是要在顶层(top level)包含汇编语言，则必须使用基本形式。&lt;/p&gt;
&lt;p&gt;这里的 &lt;strong&gt;top level&lt;/strong&gt; 一词非常诡异，让我摸不着头脑，之后我在官方文档的后文发现了蛛丝马迹：&lt;/p&gt;
&lt;p&gt;两种必须使用 Basic asm 的情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extended asm 声明必须在 C 函数内，所以如果在文件作用域(top-level)，在函数之外使用汇编，必须使用 Basic asm 。你可以使用此技术发出汇编程序指令，定义可在文件的其他位置调用的汇编语言宏，或用汇编语言编写整个函数。&lt;/li&gt;
&lt;li&gt;函数的属性(attribute)被声明为 naked 时必须使用 Basic asm 。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;naked attribute 在此不做展开。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;谜底揭开了，原来 top level 指的就是文件这一层。&lt;/p&gt;
&lt;h2 id=&#34;basic-asm&#34;&gt;Basic asm&lt;/h2&gt;
&lt;p&gt;可以使用关键字 &lt;code&gt;asm&lt;/code&gt; 来声明一段内联汇编，不过这是 GNU 的拓展，如果在编译条件中使用了 &lt;code&gt;-std&lt;/code&gt; 或者 &lt;code&gt;-ansi&lt;/code&gt; 时，必须使用 &lt;code&gt;__asm__&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;修饰&#34;&gt;修饰&lt;/h3&gt;
&lt;p&gt;可以使用 &lt;code&gt;volatile&lt;/code&gt; 和 &lt;code&gt;inline&lt;/code&gt; 来修饰，不过 &lt;code&gt;volatile&lt;/code&gt; 没有作用，所有的内联汇编代码段都是默认 &lt;code&gt;volatile&lt;/code&gt; 的。如果使用 &lt;code&gt;inline&lt;/code&gt; ，那么为了内联的目的，内联汇编语句的大小被当作是可能的最小大小。&lt;/p&gt;
&lt;p&gt;这里涉及到了内联汇编的大小估计，这是因为内联汇编生成的最终代码只由汇编器(Assembler)知晓，所以编译器需要自己估算，通过查找 &lt;code&gt;&#39;\n\t&#39;&lt;/code&gt;, &lt;code&gt;&#39;;&#39;&lt;/code&gt; 等符号来估计指令数（行数），再乘以可能的最长指令长度来获得估算大小。所以如果在 &lt;code&gt;inline&lt;/code&gt; 的 Basic asm 中使用了伪指令等能生成汇编语句的成分，汇编器可能会报错 unreachable 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;是否需要估计内联汇编的大小，这个与平台有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;参数&#34;&gt;参数&lt;/h3&gt;
&lt;p&gt;又被称为 &lt;code&gt;AssemblerTemplate&lt;/code&gt; ，由字符串字面值组成，该字符串由汇编语句组成，可以包括伪指令，GCC 的编译器并不检查它们的有效性，指令会被直接传递到汇编器中。&lt;/p&gt;
&lt;p&gt;在一段内联汇编中使用多条汇编语句时要注意自己使用的是什么汇编器（以及它们使用的是何种汇编方言），一般都可以用 &lt;code&gt;&#39;\n\t&#39;&lt;/code&gt; 来分隔，有些汇编器可以使用 &lt;code&gt;&#39;;&#39;&lt;/code&gt; ，但要注意在这种汇编方言中分号是不是注释开始的符号。&lt;/p&gt;
&lt;h3 id=&#34;注意&#34;&gt;注意&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由于调用函数以及访问 C 数据可能很复杂，在这种情况下使用 Extended asm 是更好的选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在编译器优化后连续的 asm 声明可能不再连续，所以如要需要连续语句，请写在同一个 asm 语句中。尤其是两个 asm 声明中包含了跳转时，如果被编译器调整顺序则会产生意想不到的后果。如果要跳转到 C 标签，还是使用 Extended asm 更好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果在汇编语句中定义了符号或者标签，可能会导致重复符号的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;extended-asm&#34;&gt;Extended asm&lt;/h2&gt;
&lt;p&gt;拓展内联汇编有两种模板：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;asm&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;asm&lt;/span&gt;-qualifiers ( AssemblerTemplate 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 : OutputOperands 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 [ : InputOperands
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 [ : Clobbers ] ])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;asm&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;asm&lt;/span&gt;-qualifiers ( AssemblerTemplate 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      : OutputOperands
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      : InputOperands
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      : Clobbers
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      : GotoLabels)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样地，在不使用 GNU 拓展时要用 &lt;code&gt;__asm__&lt;/code&gt; 代替 &lt;code&gt;asm&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;修饰-1&#34;&gt;修饰&lt;/h3&gt;
&lt;p&gt;除了 &lt;code&gt;volatile&lt;/code&gt; 和 &lt;code&gt;inline&lt;/code&gt; 外，还有 &lt;code&gt;goto&lt;/code&gt; ，表示这段内联汇编代码可能会跳转到 &lt;code&gt;GotoLabels&lt;/code&gt; 中的某一个标签上。&lt;/p&gt;
&lt;h3 id=&#34;参数-1&#34;&gt;参数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;input&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;goto&lt;/code&gt; 的操作数加起来不能超过 30 个。&lt;/p&gt;
&lt;h4 id=&#34;assemblertemplate&#34;&gt;AssemblerTemplate&lt;/h4&gt;
&lt;p&gt;同样是由字符串字面值组成，但是里面包含了一些标识符，它们指向了 &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;goto&lt;/code&gt; 中的操作数。&lt;/p&gt;
&lt;h4 id=&#34;outputoperands&#34;&gt;OutputOperands&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;不能将其单纯理解为输出，而是理解为会被修改的变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由 &lt;code&gt;AssemblerTemplate&lt;/code&gt; 中的指令修改的 C 变量列表，由逗号分隔，可以为空。&lt;/p&gt;
&lt;p&gt;结构一般为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[ [asmSymbolicName]  ] constraint (cvariablename)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;asmsymbolicname&#34;&gt;asmSymbolicName&lt;/h5&gt;
&lt;p&gt;可以理解为在这段拓展内联汇编中的符号别名，它可以和上下文中的 C 语言符号重复，也可以和其他内联汇编代码中的符号名重复。在 &lt;code&gt;AssemblerTemplate&lt;/code&gt; 中的使用方法为 &lt;code&gt;%[Value]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果不使用符号别名，则必须使用位置编号来指示符号，例如 &lt;code&gt;OutputOperands&lt;/code&gt; 中有三项，则用 &lt;code&gt;%0&lt;/code&gt;, &lt;code&gt;%1&lt;/code&gt; 和 &lt;code&gt;%2&lt;/code&gt; 表示。&lt;/p&gt;
&lt;h5 id=&#34;constraint&#34;&gt;constraint&lt;/h5&gt;
&lt;p&gt;Output 的约束修饰符必须是以 &lt;code&gt;&#39;=&#39;&lt;/code&gt; 开始（表示将会覆写这个变量），如果这个变量既被读也被写就需要 &lt;code&gt;&#39;+&#39;&lt;/code&gt; 。当使用 &lt;code&gt;&#39;=&#39;&lt;/code&gt; 时不要假定可以读取到将被覆写的变量的当前值，除非这个变量也在 Input 列表中。&lt;/p&gt;
&lt;p&gt;使用了 &lt;code&gt;&#39;+&#39;&lt;/code&gt; 的操作数视作两个（在计算总个数及位置时）。&lt;/p&gt;
&lt;p&gt;还需要对值所在的位置进行约束，例如 &lt;code&gt;&#39;r&#39;&lt;/code&gt; 表示寄存器，&lt;code&gt;&#39;m&#39;&lt;/code&gt; 表示在内存。如果使用了一个以上的位置约束修饰符，编译器会选择它认为最好的方式进行优化。&lt;/p&gt;
&lt;p&gt;也可以使用数字进行约束，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;asm&lt;/span&gt; (&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;incl %0&amp;#34;&lt;/span&gt; :&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;=a&amp;#34;&lt;/span&gt;(var):&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;(var));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;表示输入中的 &lt;code&gt;var&lt;/code&gt; 使用的是和输出中的 &lt;code&gt;var&lt;/code&gt; 相同的约束，这里的 0 表示为编号为 0 的操作数。&lt;/p&gt;
&lt;p&gt;常用的约束：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;符号&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;I&lt;/td&gt;
          &lt;td&gt;a constant&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;a&lt;/td&gt;
          &lt;td&gt;use eax&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;b&lt;/td&gt;
          &lt;td&gt;use ebx&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;c&lt;/td&gt;
          &lt;td&gt;use ecx&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;d&lt;/td&gt;
          &lt;td&gt;use edx&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;S&lt;/td&gt;
          &lt;td&gt;use esi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;D&lt;/td&gt;
          &lt;td&gt;use edi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;r&lt;/td&gt;
          &lt;td&gt;use one of eax, ebx, ecx or edx&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;q&lt;/td&gt;
          &lt;td&gt;use one of eax, ebx, ecx, edx, esi or edi&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其余见 GCC 文档。&lt;/p&gt;
&lt;h5 id=&#34;cvariablename&#34;&gt;cvariablename&lt;/h5&gt;
&lt;p&gt;一个 C 左值表达式，一般为变量。&lt;/p&gt;
&lt;h4 id=&#34;inputoperands&#34;&gt;InputOperands&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;不能将其单纯理解为输入，而是理解为会被读取的变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由 &lt;code&gt;AssemblerTemplate&lt;/code&gt; 中的指令读取的 C 表达式列表，由逗号分隔，可以为空。&lt;/p&gt;
&lt;p&gt;结构也为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[ [asmSymbolicName]  ] constraint (cvariablename)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;asmsymbolicname-1&#34;&gt;asmSymbolicName&lt;/h5&gt;
&lt;p&gt;如果有两个输入操作数，三个输出操作数，则第一个输入操作数为 &lt;code&gt;%2&lt;/code&gt; ，第二个为 &lt;code&gt;%3&lt;/code&gt; ，第三个为 &lt;code&gt;%4&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;一个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;asm&lt;/span&gt; (&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;cmoveq %1, %2, %[result]&amp;#34;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        : [result] &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;=r&amp;#34;&lt;/span&gt;(result) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt; (test), &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt; (new), &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;[result]&amp;#34;&lt;/span&gt; (old));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;clobbers&#34;&gt;Clobbers&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;In software engineering and computer science, clobbering a file, processor register or a region of computer memory is the process of overwriting its contents completely, whether intentionally or unintentionally, or to indicate that such an action will likely occur.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以逗号分隔的寄存器列表，一般为 &lt;code&gt;AssemblerTemplate&lt;/code&gt; 更改的其他值（没有被列入 &lt;code&gt;OutputOperands&lt;/code&gt; 的部分）。例如一些汇编指令（例如 &lt;code&gt;cld&lt;/code&gt; ）有副作用，会使用到额外的寄存器。&lt;/p&gt;
&lt;p&gt;有两个特殊的 clobber ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cc&lt;/code&gt; - 表示将会修改 flag 寄存器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;memory&lt;/code&gt; - 这个 clobber 可以告诉编译器，这段内联汇编代码将对输入和输出操作数之外的项执行内存读取或写入操作（例如，输入操作数是一个指针，需要访问它指向的内存）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 &lt;code&gt;memory&lt;/code&gt; 时，为了确保内存中包含正确的值，GCC 可能需要在执行这段内联汇编之前，将特定的寄存器值刷新到内存中。&lt;/p&gt;
&lt;p&gt;此外，在执行一个提前读取操作之前，编译器不会假定从内存中读取的值在执行该提前读取操作之后保持不变，而是会根据需要重新加载这些值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;memory&lt;/code&gt; 这个 clobber 有效地为编译器形成了读/写内存障碍。但这并不能阻止处理器在内联汇编语句之后执行推测性读操作。这种情况下还是需要 &lt;code&gt;fence&lt;/code&gt; 指令。&lt;/p&gt;
&lt;h4 id=&#34;gotolabels&#34;&gt;GotoLabels&lt;/h4&gt;
&lt;p&gt;此部分包含 C 标签的列表，当使用 &lt;code&gt;goto&lt;/code&gt; 形式时，&lt;code&gt;AssemblerTemplate&lt;/code&gt; 中的代码可以跳转到这些标签。&lt;/p&gt;
&lt;p&gt;要引用汇编程序模板中的标签，需要在它前面加上 &lt;code&gt;&#39;l&#39;&lt;/code&gt; ，后面加上它在 &lt;code&gt;GotoLabels&lt;/code&gt; 中的位置与输入和输出操作数的数目之和。带约束修饰符 &lt;code&gt;&#39;+&#39;&lt;/code&gt; 的输出操作数被视为两个操作数。例如，如果有三个输入操作数，一个输出操作数带有约束修饰符 &lt;code&gt;&#39;+&#39;&lt;/code&gt;，一个输出操作数带有约束修饰符 &lt;code&gt;&#39;=&#39;&lt;/code&gt; ，那么 &lt;code&gt;GotoLabels&lt;/code&gt; 的第一个标签称为 &lt;code&gt;%l6&lt;/code&gt; ，第二个称为 &lt;code&gt;%l7&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;也可以使用实际的 C 标签名，例如如果要引用 &lt;code&gt;GotoLabels&lt;/code&gt; 中的 &lt;code&gt;carry&lt;/code&gt; 标签，可以使用 &lt;code&gt;%l[carry]&lt;/code&gt; ，这也是推荐的方法，避免了对编号的计算。&lt;/p&gt;
&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;
&lt;p&gt;两数之和：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; foo = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;10&lt;/span&gt;, bar = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;15&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    __asm__ __volatile__(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;addl  %%ebx,%%eax&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         :&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;=a&amp;#34;&lt;/span&gt;(foo)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         :&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;(foo), &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;(bar)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         );
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;foo+bar=%d&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, foo);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; __asm__ __volatile__(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;   lock       ;&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;   addl %1,%0 ;&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;=m&amp;#34;&lt;/span&gt;  (my_var)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;ir&amp;#34;&lt;/span&gt;  (my_int), &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;m&amp;#34;&lt;/span&gt; (my_var)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      :                                 &lt;span style=&#34;color:#007f7f&#34;&gt;/* no clobber-list */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      );
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;lock&lt;/code&gt; 表示这是个原子操作。&lt;/p&gt;
&lt;p&gt;字符串复制：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; * strcpy(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; * dest,&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *src)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; d0, d1, d2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;__asm__ __volatile__(  &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;1:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;lodsb&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;stosb&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;testb %%al,%%al&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                       &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;jne 1b&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;=&amp;amp;S&amp;#34;&lt;/span&gt; (d0), &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;=&amp;amp;D&amp;#34;&lt;/span&gt; (d1), &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;=&amp;amp;a&amp;#34;&lt;/span&gt; (d2)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; (src),&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt; (dest) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;memory&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; dest;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define mov_blk(src, dest, numwords) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;__asm__ __volatile__ (                                          \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;                       &amp;#34;cld\n\t&amp;#34;                                \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;                       &amp;#34;rep\n\t&amp;#34;                                \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;                       &amp;#34;movsl&amp;#34;                                  \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;                       :                                        \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;                       : &amp;#34;S&amp;#34; (src), &amp;#34;D&amp;#34; (dest), &amp;#34;c&amp;#34; (numwords)  \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;                       : &amp;#34;%ecx&amp;#34;, &amp;#34;%esi&amp;#34;, &amp;#34;%edi&amp;#34;                 \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;                       )
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Linux 系统调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;type name(type1 arg1,type2 arg2,type3 arg3) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;{ \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;long __res; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;__asm__ volatile (  &amp;#34;int $0x80&amp;#34; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;                  : &amp;#34;=a&amp;#34; (__res) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;                  : &amp;#34;0&amp;#34; (__NR_##name),&amp;#34;b&amp;#34; ((long)(arg1)),&amp;#34;c&amp;#34; ((long)(arg2)), \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;                    &amp;#34;d&amp;#34; ((long)(arg3))); \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;__syscall_return(type,__res); \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Linux 退出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;asm&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;movl $1,%%eax;         /* SYS_exit is 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         xorl %%ebx,%%ebx;      &lt;span style=&#34;color:#007f7f&#34;&gt;/* Argument is in ebx, it is 0 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x80&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;            /* Enter kernel mode */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         );
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;内联汇编深入起来非常繁杂，有些功能需要使用的时候可以直接查看 GNU 的文档。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html&#34;&gt;GCC Inline Assembly HOWTO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://web.archive.org/web/20110514100544/http://gcc.gnu.org/onlinedocs/gnat_ugn_unw/Inline-Assembler.html&#34;&gt;GCC doc in web archive&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C&#34;&gt;How to Use Inline Assembly Language in C Code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Basic-Asm.html#Basic-Asm&#34;&gt;Basic Asm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html&#34;&gt;Extended Asm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dmalcolm.fedorapeople.org/gcc/2015-08-31/rst-experiment/how-to-use-inline-assembly-language-in-c-code.html&#34;&gt;How to Use Inline Assembly Language in C Code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dmalcolm.fedorapeople.org/gcc/2015-08-31/rst-experiment/declaring-attributes-of-functions.html&#34;&gt;Declaring Attributes of Functions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Local-Register-Variables.html&#34;&gt;Local Register Variables&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2022 Bilibili 年度报告</title>
      <link>https://vaaandark.top/posts/2022-bilibili-report/</link>
      <pubDate>Sat, 31 Dec 2022 00:34:32 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/2022-bilibili-report/</guid>
      <description>&lt;p&gt;看这年终总结，发现几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是我借别人号的原因还是我真的严重手机上瘾了，怎么看了这么多视频，一天的持续上线时间这么长？不过当我看到我看了 153 部电影，26 部电视剧，21 部动画，21 部纪录片，就可以确定了应该是借号的原因，我除了吃饭睡觉外都没有这么多时间来看。&lt;/li&gt;
&lt;li&gt;是不是什么视频都要弄个知识的标签？回顾一年搞得像我是来b站上课了，知识区我看得最多的一个 UP 竟然是「君在西安」，他是一位美食 UP 。&lt;/li&gt;
&lt;li&gt;成分有没有必要这么明显？看得最多标签是「皇马」、「C罗」、「足球」、「历史」、「战争」，投币最多的 UP 是「皇马Nino」和「比不中说篮球」，感觉自己的罗迷、詹黑成分非常明显。&lt;/li&gt;
&lt;li&gt;确实熬夜太多了，最近几天有把b站当作抖音刷的趋势，狂看小视频。&lt;/li&gt;
&lt;li&gt;看了挺多电影赏析（不是那种“注意看，这个男人叫小美”的剧情介绍），但是实际看的完整电影并不多，而且类型很狭隘。不过好在我算是系统性地过完了黑帮片和西部片，以及一些经典科幻片。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>校园网自动认证</title>
      <link>https://vaaandark.top/posts/hust-network-login/</link>
      <pubDate>Fri, 25 Nov 2022 16:01:20 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/hust-network-login/</guid>
      <description>&lt;p&gt;自己的 Wi-Fi6 漏油器用着还行，校园网带宽可以跑满，但是我的这个型号并不能刷 openwrt ，所以不能 ssh 连接，更不能在上面跑同学们写的那些自动认证脚本。&lt;/p&gt;
&lt;p&gt;去年折腾 Arduino 和 nodemcu 时想到可以利用 esp8266 的联网功能让它来代替进行认证工作。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;说干就干&lt;/del&gt;，其实并不是，我今天凌晨看葡萄牙比赛的时候才开始写代码。&lt;/p&gt;
&lt;p&gt;认证的流程大概是这样的，首先访问一个可以被跳转到认证页面的网站，我选择的是百度。在返回的字段中找到以&lt;code&gt;&amp;quot;wlanuerip&amp;quot;&lt;/code&gt;开头，直到（但不包括）&lt;code&gt;&#39;&amp;lt;/scripts&amp;gt;&lt;/code&gt;的部分，然后根据某种方式（详见代码）和帐号密码等参数组合在一起，发给&lt;code&gt;192.168.50.3&lt;/code&gt;的&lt;code&gt;8080&lt;/code&gt;端口就可以完成认证了。&lt;/p&gt;
&lt;p&gt;代码见 GitHub 仓库 &lt;a href=&#34;https://github.com/vaaandark/hust-network-login-esp&#34;&gt;vaaandark/hust-network-login-esp&lt;/a&gt; ，里面也含有使用 arduino-cli 的编译烧录脚本。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;hust-network-login-esp&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/hust-network-login-esp.png&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>量子计算机</title>
      <link>https://vaaandark.top/posts/quantum-computer/</link>
      <pubDate>Mon, 21 Nov 2022 11:51:23 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/quantum-computer/</guid>
      <description>&lt;h2 id=&#34;representation-of-data&#34;&gt;Representation of Data&lt;/h2&gt;
&lt;h3 id=&#34;qubits&#34;&gt;Qubits&lt;/h3&gt;
&lt;p&gt;A bit of data is represented by a single atom that is in one of two states denoted by $\ket0$ and $\ket1$.  A single bit of this form is known as a &lt;strong&gt;qubit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在量子计算机中，一个原子可以通过 $\ket0$ 和 $\ket1$ 其中之一的状态来表示一个比特位的数据。一个形如这样的比特位被称为&lt;strong&gt;量子位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;A physical implementation of a qubit could use the two energy levels of an atom.  An excited state representing $\ket1$ and a ground state representing $\ket0$.&lt;/p&gt;
&lt;p&gt;量子位的物理实现可以通过一个原子的两个能级来表示。激发态表示 $\ket1$ 而基态表示 $\ket0$ 。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;qubitstate&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/qubitstate.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;superposition&#34;&gt;Superposition&lt;/h3&gt;
&lt;p&gt;A single qubit can be forced into a superposition of the two states denoted by the addition of the state vectors:&lt;/p&gt;
&lt;p&gt;我们用一组向量表示两个状态的叠加，从而可以强制通过量子叠加表示单个量子位。&lt;/p&gt;
&lt;p&gt;$$\ket\psi=\alpha_1\ket0+\alpha_2\ket1$$&lt;/p&gt;
&lt;p&gt;Where $\alpha_1$ and $\alpha_2$ are complex numbers and $|\alpha_1|^2+|\alpha_2|^2 = 1$&lt;/p&gt;
&lt;p&gt;这里的 $\alpha_1$ 和 $\alpha_2$ 是复数，而且满足 $|\alpha_1|^2+|\alpha_2|^2 = 1$&lt;/p&gt;
&lt;p&gt;A qubit in superposition is in both of the states $\ket1$ and $\ket0$ at the same time&lt;/p&gt;
&lt;p&gt;一个量子叠加的量子位同时处于 $\ket1$ 和 $\ket0$ 的状态&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;superposition&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/superposition.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Consider a 3 bit qubit register.  An equally weighted superposition of all possible states would be denoted by:&lt;/p&gt;
&lt;p&gt;考虑一个 3-bit 大小的寄存器，量子叠加所有状态的一个等价表示如下：&lt;/p&gt;
&lt;p&gt;$$\ket\psi = 1/\sqrt8\ket{000}+1/\sqrt8\ket{001}+&amp;hellip;+1/\sqrt8\ket{111}$$&lt;/p&gt;
&lt;h3 id=&#34;data-retrieval&#34;&gt;Data Retrieval&lt;/h3&gt;
&lt;p&gt;In general, an n qubit register can represent the numbers $0$ through $2^n-1$ simultaneously.&lt;/p&gt;
&lt;p&gt;总而言之，一个 n-bit 的寄存器的寄存器可以同时表示 $0$ 到 $2^n-1$ 。&lt;/p&gt;
&lt;p&gt;Sound too good to be true?…It is!&lt;/p&gt;
&lt;p&gt;听起来是不是过于美妙了？但是这就是事实。&lt;/p&gt;
&lt;p&gt;If we attempt to retrieve the values represented within a superposition, the &lt;strong&gt;superposition randomly collapses&lt;/strong&gt; to represent just one of the original values.&lt;/p&gt;
&lt;p&gt;如果我们尝试去查看处于叠加状态的值，叠加状态会随机地坍缩，仅仅会表示原值中的一个。&lt;/p&gt;
&lt;p&gt;In our equation: $\ket\psi=\alpha_1\ket0+\alpha_2\ket1$ , $\alpha_1$ represents the probability of the superposition collapsing to $\ket0$.  The $\alpha_n$&amp;rsquo;s are called probability amplitudes. In a balanced superposition, $\alpha_n=1/\sqrt2$ where n is the number of qubits.&lt;/p&gt;
&lt;p&gt;在我们的方程中：$\ket\psi=\alpha_1\ket0+\alpha_2\ket1$ ，$\alpha_1$ 表示坍缩到 $\ket0$ 的概率。$\alpha_n$ 被称为概率幅。在平衡叠加状态，满足 $\alpha_n=1/\sqrt2$ ，n 是量子位的数量。&lt;/p&gt;
&lt;h3 id=&#34;entanglement&#34;&gt;Entanglement&lt;/h3&gt;
&lt;p&gt;Entanglement is the ability of quantum systems to exhibit correlations between states within a superposition.&lt;/p&gt;
&lt;p&gt;纠缠是量子系统在叠加态之间展现相互关系的能力。&lt;/p&gt;
&lt;p&gt;Imagine two qubits, each in the state $\ket0$ + $\ket1$ (a superposition of the 0 and 1.)  We can entangle the two qubits such that the measurement of one qubit is always correlated to the measurement of the other qubit.&lt;/p&gt;
&lt;p&gt;想象两个比特，每一个都在 0 和 1 的量子叠加状态，我们可以将两个量子位纠缠在一起，使得一个量子位的测量总是与另一个量子位的测量相关联。&lt;/p&gt;
&lt;h2 id=&#34;operations-on-qubits&#34;&gt;Operations on Qubits&lt;/h2&gt;
&lt;h3 id=&#34;reversible-logic&#34;&gt;Reversible Logic&lt;/h3&gt;
&lt;p&gt;Due to the nature of quantum physics, the destruction of information in a gate will cause heat to be evolved which can destroy the superposition of qubits.&lt;/p&gt;
&lt;p&gt;由于量子物理学的性质，门中信息的破坏将导致放出热量，从而破坏量子比特的叠加。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;traditional-gate&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/traditional-gate.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;This type of gate cannot be used.  We must use Quantum Gates.&lt;/p&gt;
&lt;p&gt;因此不能使用这种类型的门，我们必须使用量子门。&lt;/p&gt;
&lt;h3 id=&#34;quantum-gates&#34;&gt;Quantum Gates&lt;/h3&gt;
&lt;p&gt;Quantum Gates are similar to classical gates, but do not have a degenerate output. i.e. their original input state can be derived from their output state, uniquely.  &lt;strong&gt;They must be reversible.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;量子门类似于经典门，但没有退化输出。 也就是说，它们的原始输入状态可以唯一地从它们的输出状态中导出。 它们必须是可逆的。&lt;/p&gt;
&lt;p&gt;This means that a deterministic computation can be performed on a quantum computer only if it is reversible.  Luckily, it has been shown that any deterministic computation can be made reversible.(Charles Bennet, 1973)&lt;/p&gt;
&lt;p&gt;这意味着只有在可逆的情况下，才能在量子计算机上执行确定性计算。 幸运的是，已经证明任何确定性计算都可以实现可逆。（Charles Bennet，1973）&lt;/p&gt;
&lt;h4 id=&#34;hadamard&#34;&gt;Hadamard&lt;/h4&gt;
&lt;p&gt;Simplest gate involves one qubit and is called a &lt;strong&gt;Hadamard Gate&lt;/strong&gt; (also known as a square-root of NOT gate.)  Used to put qubits into superposition.&lt;/p&gt;
&lt;p&gt;最简单的门涉及一个量子位，称为 Hadamard 门（也称为 NOT 门的平方根），用于将量子位叠加。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;hadamard&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/hadamard.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Note: Two Hadamard gates used in succession can be used as a NOT gate&lt;/p&gt;
&lt;p&gt;注意：连续使用的两个 Hadamard 门可以作为一个非门&lt;/p&gt;
&lt;h4 id=&#34;controlled-not&#34;&gt;Controlled NOT&lt;/h4&gt;
&lt;p&gt;A gate which operates on two qubits is called a &lt;strong&gt;Controlled-NOT (CN) Gate&lt;/strong&gt;.  If the bit on the control line is 1, invert the bit on the target line.&lt;/p&gt;
&lt;p&gt;在两个量子位上运行的门称为受控非 (CN) 门。 如果控制线上的位为 1，则将目标线上的位反转。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;controlled-not&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/controlled-not.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Note: The CN gate has a similar behavior to the XOR gate with some extra information to make it reversible.&lt;/p&gt;
&lt;p&gt;注意：CN 门与 XOR 门具有相似的行为，但有一些额外的信息使其可逆。&lt;/p&gt;
&lt;h4 id=&#34;multiplication-by-2&#34;&gt;Multiplication By 2&lt;/h4&gt;
&lt;p&gt;We can build a reversible logic circuit to calculate multiplication by 2 using CN gates arranged in the following manner:&lt;/p&gt;
&lt;p&gt;我们可以构建一个可逆逻辑电路，使用按以下方式排列的 CN 门来计算 2 的乘法：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;multiplication-by-2&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/multiplication-by-2.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;controlled-controlled-not-ccn&#34;&gt;Controlled Controlled NOT (CCN)&lt;/h4&gt;
&lt;p&gt;A gate which operates on three qubits is called a Controlled Controlled NOT (CCN) Gate.  Iff the bits on both of the control lines is 1,then the target bit is inverted.&lt;/p&gt;
&lt;p&gt;在三个量子位上运行的门称为受控受控非 (CCN) 门。 如果两条控制线上的位都是 1，则目标位被反转。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;controlled-controlled-not&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/controlled-controlled-not.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;a-universal-quantum-computer&#34;&gt;A Universal Quantum Computer&lt;/h3&gt;
&lt;p&gt;The CCN gate has been shown to be a universal reversible logic gate as it can be used as a NAND gate.&lt;/p&gt;
&lt;p&gt;CCN 门已被证明是一种通用的可逆逻辑门，因为它可以用作与非门。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;universal&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/universal.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;When our target input is 1, our target output is a result of a NAND of B and C.&lt;/p&gt;
&lt;p&gt;当我们的目标 A 输入为 1 时，我们的目标输出 A 是 B 和 C 的 NAND 的结果。&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Joseph Stelmach&lt;/em&gt;, &lt;em&gt;Quantum Computer&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.eecis.udel.edu/~saunders/courses/879-03s/quantumComputers.ppt&#34;&gt;https://www.eecis.udel.edu/~saunders/courses/879-03s/quantumComputers.ppt&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wikipedia, &lt;em&gt;probability amplitudes&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Probability_amplitude&#34;&gt;https://en.wikipedia.org/wiki/Probability_amplitude&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wikipedia, &lt;em&gt;Quantum superposition&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_superposition&#34;&gt;https://en.wikipedia.org/wiki/Quantum_superposition&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ps&#34;&gt;PS&lt;/h2&gt;
&lt;p&gt;感谢 &lt;a href=&#34;https://note.qidong.name/2018/03/hugo-mathjax/&#34;&gt;https://note.qidong.name/2018/03/hugo-mathjax/&lt;/a&gt; 这篇博客，我终于找到了在 hugo 中使用公式的完美方案。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>物理双偏振实验画图</title>
      <link>https://vaaandark.top/posts/dual-polarization-experiment-drawing/</link>
      <pubDate>Sun, 20 Nov 2022 12:32:04 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/dual-polarization-experiment-drawing/</guid>
      <description>&lt;p&gt;上次物理实验做的是双偏振，实验资料中推荐使用 origin 画图，我既不想使用 Windows 也不想多下载一个软件，因此我打算用 matplotlib 画图。&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;p&gt;第一个实验画图是很简单的线性回归计算：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;import&lt;/span&gt; numpy &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;as&lt;/span&gt; np
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;as&lt;/span&gt; plt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;import&lt;/span&gt; math
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.rcParams[&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;font.sans-serif&amp;#39;&lt;/span&gt;]=[&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;SimHei&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;angles = [&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;90&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;80&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;70&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;60&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;40&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;30&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x = []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; a in angles:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x.append(math.cos(a / &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;180&lt;/span&gt; * math.pi) ** &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;y1 = [&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.6&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;6.8&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;21.0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;41.8&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;68.9&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;94.1&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;118.2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;136.1&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;149.7&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;152.8&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;y2 = [&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.6&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;6.8&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;15.7&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;39.6&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;68.4&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;92.2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;119.2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;130.8&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;142.9&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;147.7&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x = np.array(x)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;y1 = np.array(y1)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;y2 = np.array(y2)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.scatter(x, y1, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;black&amp;#34;&lt;/span&gt;, marker = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;o&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.scatter(x, y2, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;black&amp;#34;&lt;/span&gt;, marker = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;v&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a1, b1 = np.polyfit(x, y1, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a2, b2 = np.polyfit(x, y2, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.plot(x, a1 * x + b1, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;blue&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.plot(x, a2 * x + b2, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;red&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.title(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;光强 I 与透光轴夹角 θ 的关系&amp;#34;&lt;/span&gt;, fontsize = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;13&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.xlabel(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;$cos^2θ$&amp;#39;&lt;/span&gt;, fontsize = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;12&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.ylabel(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;$I/*10^{-7}$&amp;#39;&lt;/span&gt;, fontsize = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;12&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.tick_params(labelsize = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;11&lt;/span&gt;)  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.grid(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;True&lt;/span&gt;, linestyle = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;--&amp;#34;&lt;/span&gt;, color = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;g&amp;#34;&lt;/span&gt;, linewidth = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;0.5&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.savefig(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;lab1.png&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.show()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第三个实验画图使用了极座标系和极座标系上的拟合，需要查看 matplotlib 的 API ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;as&lt;/span&gt; plt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;from&lt;/span&gt; scipy.optimize &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;import&lt;/span&gt; curve_fit
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;import&lt;/span&gt; numpy &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;as&lt;/span&gt; np
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.rcParams[&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;font.sans-serif&amp;#39;&lt;/span&gt;]=[&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;SimHei&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;def&lt;/span&gt; form(x, A):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  res = A * A * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; * (np.cos(x) * np.cos(x) * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.75&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  + np.sin(x) * np.sin(x) * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.25&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; res
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;theta = []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; i in &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;range&lt;/span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;360&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;10&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  theta.append(i / &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;180&lt;/span&gt; * np.pi)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;I = [ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;93.9&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;90.7&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;84.4&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;75.6&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;65.0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;54.9&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;45.7&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;38.5&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;34.6&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;33.8&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;37.0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;43.2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;51.0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;61.1&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;71.0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;80.4&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;87.1&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;91.3&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;92.2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;88.9&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;82.6&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;75.8&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;67.2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;56.8&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;47.2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;39.9&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;36.0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;35.2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;38.1&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;44.5&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;53.4&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;63.8&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;72.2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;80.4&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;88.2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;91.9&lt;/span&gt; ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;# 为了最后封口&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;theta.append(theta[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;I.append(I[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fig, ax = plt.subplots(subplot_kw={&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;projection&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;polar&amp;#39;&lt;/span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.scatter(theta, I, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;50&lt;/span&gt;, marker = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;o&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.xlabel(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;$I/*10^{-7}$&amp;#39;&lt;/span&gt;, fontsize = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;12&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ax.set_title(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;椭圆偏振光光强测量数据&amp;#34;&lt;/span&gt;, va = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bottom&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;param, covariance = curve_fit(form, theta, I, method=&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;trf&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.plot(theta, form(theta, *param), &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;blue&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.savefig(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;lab3.png&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plt.show()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在编写代码过程中发现，在&lt;code&gt;form&lt;/code&gt;这个函数里只能使用 numpy 中的函数，而不能使用 math 中的函数，因为这个函数用于拟合，处理的是一堆数据组成的向量，必须要支持向量运算。&lt;/p&gt;
&lt;h2 id=&#34;效果&#34;&gt;效果&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&#34;lab1&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/lab1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;lab3&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/lab3.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;matplotlib API Reference&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://matplotlib.org/stable/api/index.html&#34;&gt;https://matplotlib.org/stable/api/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://matplotlib.org/stable/gallery/pie_and_polar_charts/polar_demo.html&#34;&gt;https://matplotlib.org/stable/gallery/pie_and_polar_charts/polar_demo.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://matplotlib.org/stable/gallery/lines_bars_and_markers/scatter_custom_symbol.html&#34;&gt;https://matplotlib.org/stable/gallery/lines_bars_and_markers/scatter_custom_symbol.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ARM与80X86的异同</title>
      <link>https://vaaandark.top/posts/differences-between-arm-and-80x86/</link>
      <pubDate>Tue, 08 Nov 2022 20:35:20 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/differences-between-arm-and-80x86/</guid>
      <description>&lt;p&gt;今天初步认识了 ARM 汇编。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;cpu-内寄存器&#34;&gt;CPU 内寄存器&lt;/h2&gt;
&lt;p&gt;aarch64 有 31 个 64 位通用寄存器，它们的名字是为 xn（n 为 0-30 的整数），不像 80X86 一样暗示了它们的用途。&lt;/p&gt;
&lt;p&gt;类似 rax 和 eax 的关系，它们对应的 32 位寄存器叫做 wn（n 为 0-30 的整数）。&lt;/p&gt;
&lt;p&gt;还有几个特殊寄存器和 80X86 类似，不过多出来了链接寄存器。&lt;/p&gt;
&lt;h2 id=&#34;段的定义方法&#34;&gt;段的定义方法&lt;/h2&gt;
&lt;p&gt;段的定义方法与 80X86 有很大区别，但是和 nasm 语法基本一致。&lt;/p&gt;
&lt;h2 id=&#34;指令语句及其格式&#34;&gt;指令语句及其格式&lt;/h2&gt;
&lt;p&gt;目前学到的一些区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;格式上更类似于 Intel 的语法，第一个操作数是目的寄存器（目的存储器）。&lt;/li&gt;
&lt;li&gt;ARM 的很多指令都是三操作数的，这给编码带来了更多的灵活性。&lt;/li&gt;
&lt;li&gt;ARM 指令是定长的，每一条指令都是固定的 4 字节长度。&lt;/li&gt;
&lt;li&gt;立即数表示不一样，使用了&lt;code&gt;#&lt;/code&gt;作为前缀。&lt;/li&gt;
&lt;li&gt;寄存器基址变址寻址不需要加号，使用&lt;code&gt;[R1, #8]&lt;/code&gt;这样的格式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LDR.W  R0,  [R1,#20]!&lt;/code&gt;相当于 x86 汇编的&lt;code&gt;mov eax [ebx, 20]&lt;/code&gt; &lt;code&gt;mov eax [eax]&lt;/code&gt;两句。&lt;/li&gt;
&lt;li&gt;寄存器列表&lt;code&gt;{}&lt;/code&gt;语法。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4005f4:     a9be7bfd        stp     x29, x30, [sp, #-32]!
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4005f8:     910003fd        mov     x29, sp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到机器指令&lt;code&gt;a9be7bfd&lt;/code&gt;和&lt;code&gt;910003fd&lt;/code&gt;是定长的&lt;/p&gt;
&lt;h3 id=&#34;一些特殊的指令&#34;&gt;一些特殊的指令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LDR  字数据加载指令&lt;/li&gt;
&lt;li&gt;LDRB 字节数据加载指令&lt;/li&gt;
&lt;li&gt;LDRH 半字数据加载指令&lt;/li&gt;
&lt;li&gt;STR  字数据存储指令&lt;/li&gt;
&lt;li&gt;TRB  字节数据存储指令&lt;/li&gt;
&lt;li&gt;STRH 半字数据存储指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;子程序调用&#34;&gt;子程序调用&lt;/h2&gt;
&lt;p&gt;ARM 使用 bl 跳转进入子程序，并不像 80X86 一样使用 call 。&lt;/p&gt;
&lt;h3 id=&#34;参数传递&#34;&gt;参数传递&lt;/h3&gt;
&lt;p&gt;提供了 8 个通用寄存器（r0-r7）用于传递函数参数，一次对应&lt;code&gt;arg1&lt;/code&gt;到&lt;code&gt;arg8&lt;/code&gt;，超过 8 个的参数会存放在堆栈中。&lt;/p&gt;
&lt;p&gt;GCC 生成的汇编依然是 Caller Save 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 GCC 编译时，发现虽然传递到寄存器的顺序不会对函数调用有影响，但是 GCC 还是逆序传入寄存器，可能是为了结构化生成代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;返回值&#34;&gt;返回值&lt;/h3&gt;
&lt;p&gt;如果返回值是整型，则是 x0 。&lt;/p&gt;
&lt;h2 id=&#34;与-c-语言混合编程&#34;&gt;与 C 语言混合编程&lt;/h2&gt;
&lt;p&gt;将&lt;code&gt;.s&lt;/code&gt;和&lt;code&gt;.c&lt;/code&gt;文件分开编程与 80X86 没有区别，内联汇编也没有区别，区别主要在于 ARM 汇编的语法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>QEMU配置openEuler的aarch64开发环境</title>
      <link>https://vaaandark.top/posts/setup-qemu-for-openeuler-aarch64/</link>
      <pubDate>Mon, 07 Nov 2022 16:43:28 +0800</pubDate>
      
      <guid>https://vaaandark.top/posts/setup-qemu-for-openeuler-aarch64/</guid>
      <description>&lt;p&gt;还是计算机系统基础，即将对 arm 架构展开学习，使用的是华为的打开欧拉(openEuler)操作发行版。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;进入镜像&#34;&gt;进入镜像&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;首先下载虚拟机镜像，老师发的我安装不了，就在清华的镜像站下载了。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ aria2c -x &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;15&lt;/span&gt; -s &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;https://mirrors.tuna.tsinghua.edu.cn/openeuler/openEuler-20.03-LTS/virtual_machine_img/aarch64/openEuler-20.03-LTS.aarch64.qcow2.xz&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;先调整一下镜像的磁盘大小。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-img resize openEuler-20.03-LTS.aarch64.qcow2 +20G
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;启动镜像，注意需要使用引导文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-system-aarch64 -m 4096 \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        -cpu cortex-a57 \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        -smp 4 \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        -M virt \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        -bios edk2-aarch64-code.fd \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        -hda openEuler-20.03-LTS.aarch64.qcow2 \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        -nographic \
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;配置网络&#34;&gt;配置网络&lt;/h2&gt;
&lt;p&gt;配置网络这部分，尤其是网卡那部分我不是很懂，基本上是照着教程来做。&lt;/p&gt;
&lt;p&gt;虽然 QEMU 的字符界面用起来很顺手，几乎和使用了 ssh 连接一样，但是在一些 curses 库的 TUI 界面中显示不佳，我还是准备使用 ssh 。&lt;/p&gt;
&lt;p&gt;总所周知，虚拟机有多种连接网络的方式，这次配置我使用的是“用户网络”的方式，然后将端口 22 和主机端口 10021 绑定。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;qemu-system-aarch64 -m &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4096&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&lt;/span&gt;        -cpu cortex-a57 &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&lt;/span&gt;        -smp &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&lt;/span&gt;        -M virt &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&lt;/span&gt;        -bios edk2-aarch64-code.fd &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&lt;/span&gt;        -net nic,model=e1000 &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&lt;/span&gt;        -net user,hostfwd=tcp::10021-:22 &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&lt;/span&gt;        -hda openEuler-20.03-LTS.aarch64.qcow2 &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&lt;/span&gt;        -nographic
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用脚本进入后发现没有 ip ，说明网卡配置还不正确。&lt;/p&gt;
&lt;p&gt;创建并编辑&lt;code&gt;/etc/sysconfig/newwork-scipts/ifcfg-eth0&lt;/code&gt;文件。使用&lt;code&gt;nmcli c&lt;/code&gt;查看 UUID ，使用&lt;code&gt;ifconfig&lt;/code&gt;查看 MAC 地址。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;DEVICE=eth0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HWADDR=52:54:00:12:34:56
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;UUID=e449c48a-45a7-3db7-8cf3-349bd209b064
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NM_CONTROLLED=yes
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ONBOOT=yes
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BOOTPROTO=dhcp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;type=Ethernet
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;IPV6INIT=no
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;USERCTL=no
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;重启 NetworkManager 和使 ssh 自启动。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ systemctl restart NetworkManager
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ systemctl &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;enable&lt;/span&gt; sshd
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;打开网卡并测试。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ifup eth0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ping baidu.com
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 ssh 连接。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ssh -p &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;10021&lt;/span&gt; root@localhost
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;配置软件&#34;&gt;配置软件&lt;/h2&gt;
&lt;p&gt;创建并编辑&lt;code&gt;/etc/yum.repos.d/openEuler.repo&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[OS]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name=openEuler-$releasever - OS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;baseurl=https://repo.openeuler.org/openEuler-20.03-LTS/OS/$basearch/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;enabled=1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gpgcheck=1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gpgkey=https://repo.openeuler.org/openEuler-20.03-LTS/OS/$basearch/RPM-GPG-KEY-openEuler
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[update]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name=openEuler-$releasever - Update
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;baseurl=http://repo.openeuler.org/openEuler-20.03-LTS/update/$basearch/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;enabled=1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gpgcheck=1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gpgkey=http://repo.openeuler.org/openEuler-20.03-LTS/update/$basearch/RPM-GPG-KEY-openEuler
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[extras]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name=openEuler-$releasever - Extras
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;baseurl=http://repo.openeuler.org/openEuler-20.03-LTS/extras/$basearch/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;enabled=0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gpgcheck=1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gpgkey=http://repo.openeuler.org/openEuler-20.03-LTS/extras/$basearch/RPM-GPG-KEY-openEuler
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装常用软件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ dnf install gcc gcc-c++ libstdc++-devel gdb nasm
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;新建用户，配置管理员权限之类的都是常规操作了，就不用赘述了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2022.11.6 维拉 3 : 1 曼联</title>
      <link>https://vaaandark.top/posts/2022.11.6-man-utd-vs-aston-villa/</link>
      <pubDate>Sun, 06 Nov 2022 23:50:00 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/2022.11.6-man-utd-vs-aston-villa/</guid>
      <description>&lt;p&gt;腾哈格今天不知道在干嘛，没有了大B哥就完全不会踢球了。虽然之前总是批评大B哥传球毛躁冒险，但是他还是有后插上和威胁球的能力的。今天的范德贝克完全隐身，活该坐板凳；而爱神就像是野球场上的老大爷，看似技术高一档，实际上已经被对面年轻人强傻了冲烂了，他今天上场主要是给客场球迷展示自己的斜长传水平的。胖虎今天略有不在状态，又成了背锅侠，中场失控他也分身乏术。&lt;/p&gt;
&lt;p&gt;后场更是重量级，利马今天乍一看像个野兽，非常具有侵略性。但是也就只有侵略性了，两次失球与他有关，下半场甚至两连肘击对面球员。我每次看到他都是怒气冲冲地上去，奔着打架去对抗。不过这安东尼泰勒果然是盲侠。&lt;/p&gt;
&lt;p&gt;前场众前锋拿不到球，边路的组合完全没有配合，加纳乔有小技术但是没有配合，爆发力也很欠缺。C罗还是在打中锋位置，看得他急我也急。&lt;/p&gt;
&lt;p&gt;简而言之，今天的曼联很像当时范大厨的“大圈战术”，中场没人或者只有一个人，然而边路的推进十分便秘，每次都只能再斜长传打到弱侧，弱侧球员也没有维尼修斯一样的爆边能力。&lt;/p&gt;
&lt;p&gt;这支曼联还有救吗？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSAPP Bomb Lab</title>
      <link>https://vaaandark.top/posts/csapp-bomb-lab/</link>
      <pubDate>Sat, 29 Oct 2022 22:24:22 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/csapp-bomb-lab/</guid>
      <description>&lt;p&gt;之前的 Bomb Lab 没有做，现在刚好在上计算机系统基础这门课，学校使用了 CSAPP 的 Bomb Lab ，可以补交一下 CSAPP 的作业，也可以学习一下 GDB 的使用。&lt;/p&gt;
&lt;h2 id=&#34;实验简述&#34;&gt;实验简述&lt;/h2&gt;
&lt;p&gt;遗憾地，CSAPP 的 Bomb Lab 早已提供的是 Linux 的 64 位可执行程序，而我校的 Lab 还是 32 位的 Windows PE32 。不过我还是找老师要到了它的 Linux 版本，不过也是 ELF32 ，可执行文件的名字叫&lt;code&gt;bomb_32&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该 Lab 是 CSAPP Bomb Lab 的老版 32 位程序，所以之后我还是看一下新版的 Bomb Lab 较好，不能完全不了解 64 位汇编嘛 :(&lt;/p&gt;
&lt;h2 id=&#34;实验环境&#34;&gt;实验环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GNU gdb (GDB) Fedora 12.1-2.fc36&lt;/li&gt;
&lt;li&gt;GNU objdump version 2.37-36.fc36&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实验过程&#34;&gt;实验过程&lt;/h2&gt;
&lt;p&gt;首先反汇编生成汇编代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ objdump -S -C bomb_32 &amp;gt; bomb.disas
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于我不是很会看 AT&amp;amp;T 的汇编代码，所以我的 objdump 是 aliased 的，默认使用 Intel 的语法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ which objdump
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;objdump=&amp;#39;objdump --disassembler-options=intel&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        /usr/bin/objdump
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gdb 也默认使用 Intel 的语法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cat ~/.gdbinit
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set disassembly-flavor intel
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再使用 gdb 开始调试程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ gdb --args ./bomb_32 input
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;phase_1&#34;&gt;phase_1&lt;/h3&gt;
&lt;p&gt;由于老师给了这个程序运行的流程图，我也看过 Bomb Lab 中提供的 .c 文件，所以我知道每个字符串都在&lt;code&gt;phase_n&lt;/code&gt;的函数中输入或者检验。&lt;/p&gt;
&lt;p&gt;可以直接查看&lt;code&gt;phase_1&lt;/code&gt;函数的反汇编代码，并注意到这个函数中的一个函数调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) disas phase_1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Dump of assembler code for function phase_1:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ......
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   0x08048b2c &amp;lt;+12&amp;gt;:	push   0x80497c0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   0x08048b31 &amp;lt;+17&amp;gt;:	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   0x08048b32 &amp;lt;+18&amp;gt;:	call   0x8049030 &amp;lt;strings_not_equal&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ......
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到它在压入两个参数之后调用了一个函数&lt;code&gt;strings_not_equal&lt;/code&gt;，我们直接查看&lt;code&gt;0x80497c0&lt;/code&gt;里面是什么内容，我首先猜测它是一个字符串：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) p (char *)0x80497c0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$1 = 0x80497c0 &amp;#34;Public speaking is very easy.&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在之后的测试中，这个字符串也让我过了第一关。&lt;/p&gt;
&lt;h3 id=&#34;phase_2&#34;&gt;phase_2&lt;/h3&gt;
&lt;p&gt;直接查看&lt;code&gt;phase_2&lt;/code&gt;的汇编代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;; phase_2 的参数为字符串 input ，在 [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;08048b48 &amp;lt;phase_2&amp;gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b48:	55                   	push   ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b49:	89 e5                	mov    ebp,esp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 为局部变量腾出空间
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b4b:	83 ec 20             	sub    esp,0x20
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 可能是内部调用的函数需要使用这两个寄存器
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 所以根据 caller save 在这里保存
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b4e:	56                   	push   esi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b4f:	53                   	push   ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 将 input 放入 edx 中
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b50:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 等于 sub esp, 0x8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b53:	83 c4 f8             	add    esp,0xfffffff8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 将局部变量的地址 [ebp-0x18] 放入 eax 中
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 不妨给它起名为变量 A
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 由于给局部变量预留的位置很大，猜测 A 是一个数组
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b56:	8d 45 e8             	lea    eax,[ebp-0x18]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 压栈传参，传入的是 input, A
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b59:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b5a:	52                   	push   edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 调用函数 read_six_numbers 根据名字合理怀疑这里是读入六个数字，A 可能有 6 个元素
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b5b:	e8 78 04 00 00       	call   8048fd8 &amp;lt;read_six_numbers&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 这里 esp 加了 0x10 相当于把之前的参数退栈了，还把之前 add esp,0xfffffff8 的加回去了。我猜测之前的 add 可能和内存对齐有关
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b60:	83 c4 10             	add    esp,0x10
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 将 A[0] 与 1 比较
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 由于之前传递的是地址，这个变量应该在 read_six_numbers 中被修改了
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b63:	83 7d e8 01          	cmp    DWORD PTR [ebp-0x18],0x1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 如果是 1 则成功，不是 1 则引爆炸弹
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b67:	74 05                	je     8048b6e &amp;lt;phase_2+0x26&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b69:	e8 8e 09 00 00       	call   80494fc &amp;lt;explode_bomb&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; ebx &amp;lt;- 0x1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b6e:	bb 01 00 00 00       	mov    ebx,0x1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 将 A 放入 esi 中
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b73:	8d 75 e8             	lea    esi,[ebp-0x18]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; eax &amp;lt;- 0x2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b76:	8d 43 01             	lea    eax,[ebx+0x1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 这步骤操作之后 eax 的值为 (ebx + 1) * A[ebx - 1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; ebx 初始为 1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b79:	0f af 44 9e fc       	imul   eax,DWORD PTR [esi+ebx*4-0x4]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 相当于判断 A[ebx] 是不是 A[ebx - 1] 两倍
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b7e:	39 04 9e             	cmp    DWORD PTR [esi+ebx*4],eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b81:	74 05                	je     8048b88 &amp;lt;phase_2+0x40&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b83:	e8 74 09 00 00       	call   80494fc &amp;lt;explode_bomb&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b88:	43                   	inc    ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b89:	83 fb 05             	cmp    ebx,0x5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 我读到这里才发现是一个循环，终止条件为 ebx &amp;gt; 5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b8c:	7e e8                	jle    8048b76 &amp;lt;phase_2+0x2e&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 所以根据递推公式可知字符串为 1 2 6 24 120 720
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b8e:	8d 65 d8             	lea    esp,[ebp-0x28]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b91:	5b                   	pop    ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b92:	5e                   	pop    esi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b93:	89 ec                	mov    esp,ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b95:	5d                   	pop    ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b96:	c3                   	ret    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b97:	90                   	nop
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它调用了函数&lt;code&gt;read_six_numbers&lt;/code&gt;，所以我们也分析一下它：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;; 参数为字符串 input 和数组 A
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;08048fd8 &amp;lt;read_six_numbers&amp;gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048fd8:	55                   	push   ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048fd9:	89 e5                	mov    ebp,esp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048fdb:	83 ec 08             	sub    esp,0x8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 传入的输入字符串
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048fde:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 传入的数组 A
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048fe1:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; A[5]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048fe4:	8d 42 14             	lea    eax,[edx+0x14]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048fe7:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; A[4]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048fe8:	8d 42 10             	lea    eax,[edx+0x10]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048feb:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; A[3]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048fec:	8d 42 0c             	lea    eax,[edx+0xc]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048fef:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; A[2]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ff0:	8d 42 08             	lea    eax,[edx+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ff3:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; A[1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ff4:	8d 42 04             	lea    eax,[edx+0x4]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ff7:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; A[0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ff8:	52                   	push   edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; format 字符串 &amp;#34;%d %d %d %d %d %d&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ff9:	68 1b 9b 04 08       	push   0x8049b1b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; input 输入字符串
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ffe:	51                   	push   ecx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048fff:	e8 5c f8 ff ff       	call   8048860 &amp;lt;sscanf@plt&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8049004:	83 c4 20             	add    esp,0x20
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8049007:	83 f8 05             	cmp    eax,0x5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 804900a:	7f 05                	jg     8049011 &amp;lt;read_six_numbers+0x39&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 804900c:	e8 eb 04 00 00       	call   80494fc &amp;lt;explode_bomb&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8049011:	89 ec                	mov    esp,ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8049013:	5d                   	pop    ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8049014:	c3                   	ret    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8049015:	8d 76 00             	lea    esi,[esi+0x0]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用字符串&lt;code&gt;1 2 6 24 120 720&lt;/code&gt;成功通过第二关。&lt;/p&gt;
&lt;h3 id=&#34;phase_3&#34;&gt;phase_3&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;; phase_3 的参数为字符串 input ，在 [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;08048b98 &amp;lt;phase_3&amp;gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b98:	55                   	push   ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b99:	89 e5                	mov    ebp,esp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 预留 20 个字节
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b9b:	83 ec 14             	sub    esp,0x14
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b9e:	53                   	push   ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 将 input 放入 edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048b9f:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; sub esp, 0x4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ba2:	83 c4 f4             	add    esp,0xfffffff4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; int_b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ba5:	8d 45 fc             	lea    eax,[ebp-0x4]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ba8:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; char_c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ba9:	8d 45 fb             	lea    eax,[ebp-0x5]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bac:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; int_a
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bad:	8d 45 f4             	lea    eax,[ebp-0xc]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bb0:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 通过 GBD 调试可以知道这个地址内容为 &amp;#34;%d %c %d&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bb1:	68 de 97 04 08       	push   0x80497de
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; input
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bb6:	52                   	push   edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bb7:	e8 a4 fc ff ff       	call   8048860 &amp;lt;sscanf@plt&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bbc:	83 c4 20             	add    esp,0x20
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 如果 sscanf 匹配并赋值的个数不多于 2 ，则爆炸
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bbf:	83 f8 02             	cmp    eax,0x2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bc2:	7f 05                	jg     8048bc9 &amp;lt;phase_3+0x31&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bc4:	e8 33 09 00 00       	call   80494fc &amp;lt;explode_bomb&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 将 int_a 与 0x7 比较
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 怀疑是一个防止数组越界的操作
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bc9:	83 7d f4 07          	cmp    DWORD PTR [ebp-0xc],0x7
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 如果大于则爆炸
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bcd:	0f 87 b5 00 00 00    	ja     8048c88 &amp;lt;phase_3+0xf0&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 将 int_a 赋值给 eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bd3:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 这里存在一个跳转表，对应到 C 语言中应该是一个 switch-case 结构
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 可以在 gdb 里面查看一下对应的表 `(gdb) p/x *(int *)0x80497e8`
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; [0x80497e8] 对应 8048be0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; [0x80497e8+1*4] 对应 8048c00
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; [0x80497e8+2*4] 对应 8048c16
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; [0x80497e8+3*4] 对应 8048c28
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; [0x80497e8+4*4] 对应 8048c40
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; [0x80497e8+5*4] 对应 8048c52
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; [0x80497e8+6*4] 对应 8048c64
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; [0x80497e8+7*4] 对应 8048c76
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; switch-case(int_a)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bd6:	ff 24 85 e8 97 04 08 	jmp    DWORD PTR [eax*4+0x80497e8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bdd:	8d 76 00             	lea    esi,[esi+0x0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; case 0:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; bl &amp;lt;- 0x71
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048be0:	b3 71                	mov    bl,0x71
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 将 int_b 与 0x309 比较
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048be2:	81 7d fc 09 03 00 00 	cmp    DWORD PTR [ebp-0x4],0x309
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 如果等于就 break
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048be9:	0f 84 a0 00 00 00    	je     8048c8f &amp;lt;phase_3+0xf7&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bef:	e8 08 09 00 00       	call   80494fc &amp;lt;explode_bomb&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bf4:	e9 96 00 00 00       	jmp    8048c8f &amp;lt;phase_3+0xf7&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; eiz 是一个伪寄存器，它始终为 0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048bf9:	8d b4 26 00 00 00 00 	lea    esi,[esi+eiz*1+0x0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 后面几个 case 都是相同的道理
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ......
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; bl 与 char_c 比较
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048c8f:	3a 5d fb             	cmp    bl,BYTE PTR [ebp-0x5]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 所以基本流程就是根据 int_a 的值确定进去哪一个 case ，
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 然后在该分支中将 int_b 和某一值比较，并确定 char_c 应该等于的值
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 所以答案应该不唯一，通过 int_a 的值确定后面两个答案
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ......
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我使用&lt;code&gt;0 q 777&lt;/code&gt;通过了这一关。&lt;/p&gt;
&lt;h3 id=&#34;phase_4&#34;&gt;phase_4&lt;/h3&gt;
&lt;p&gt;这一关包含了递归函数，但是挑战性不是很大。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;; phase_4 的参数为字符串 input ，在 [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;08048ce0 &amp;lt;phase_4&amp;gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ce0:	55                   	push   ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ce1:	89 e5                	mov    ebp,esp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ce3:	83 ec 18             	sub    esp,0x18
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; input -&amp;gt; edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ce6:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; sub esp, 0xc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ce9:	83 c4 fc             	add    esp,0xfffffffc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 不妨令该局部变量为 A
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cec:	8d 45 fc             	lea    eax,[ebp-0x4]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cef:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 根据 GDB `p (char *)0x8049808` 可得该字符串为 `%d`
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cf0:	68 08 98 04 08       	push   0x8049808
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cf5:	52                   	push   edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cf6:	e8 65 fb ff ff       	call   8048860 &amp;lt;sscanf@plt&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cfb:	83 c4 10             	add    esp,0x10
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 判断 sscanf 是否成功
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cfe:	83 f8 01             	cmp    eax,0x1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d01:	75 06                	jne    8048d09 &amp;lt;phase_4+0x29&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 判断 A 和 0x0 ，如果不大于 0 则爆炸
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d03:	83 7d fc 00          	cmp    DWORD PTR [ebp-0x4],0x0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d07:	7f 05                	jg     8048d0e &amp;lt;phase_4+0x2e&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d09:	e8 ee 07 00 00       	call   80494fc &amp;lt;explode_bomb&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; sub esp, 0x4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d0e:	83 c4 f4             	add    esp,0xfffffff4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; A -&amp;gt; eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d11:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 参数入栈并调用 func4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d14:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d15:	e8 86 ff ff ff       	call   8048ca0 &amp;lt;func4&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d1a:	83 c4 10             	add    esp,0x10
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 返回值如果不是 55 则爆炸
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d1d:	83 f8 37             	cmp    eax,0x37
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d20:	74 05                	je     8048d27 &amp;lt;phase_4+0x47&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d22:	e8 d5 07 00 00       	call   80494fc &amp;lt;explode_bomb&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d27:	89 ec                	mov    esp,ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d29:	5d                   	pop    ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d2a:	c3                   	ret    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d2b:	90                   	nop
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们来看看&lt;code&gt;func4&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;; phase_4 的参数为整型 A ，在 [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;08048ca0 &amp;lt;func4&amp;gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ca0:	55                   	push   ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ca1:	89 e5                	mov    ebp,esp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ca3:	83 ec 10             	sub    esp,0x10
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ca6:	56                   	push   esi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ca7:	53                   	push   ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; ebx &amp;lt;- A
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ca8:	8b 5d 08             	mov    ebx,DWORD PTR [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 如果 A 不大于 1 则跳转到 退出，这里应该是递归出口，返回值为 1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cab:	83 fb 01             	cmp    ebx,0x1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cae:	7e 20                	jle    8048cd0 &amp;lt;func4+0x30&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cb0:	83 c4 f4             	add    esp,0xfffffff4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cb3:	8d 43 ff             	lea    eax,[ebx-0x1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cb6:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; func(A - 1)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cb7:	e8 e4 ff ff ff       	call   8048ca0 &amp;lt;func4&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cbc:	89 c6                	mov    esi,eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cbe:	83 c4 f4             	add    esp,0xfffffff4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cc1:	8d 43 fe             	lea    eax,[ebx-0x2]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cc4:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; func(A - 2)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 写到这里可以猜到这是斐波那契数列，
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 之前要求返回值是 55 ，所以输入应该是 9
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cc5:	e8 d6 ff ff ff       	call   8048ca0 &amp;lt;func4&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cca:	01 f0                	add    eax,esi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ccc:	eb 07                	jmp    8048cd5 &amp;lt;func4+0x35&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cce:	89 f6                	mov    esi,esi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cd0:	b8 01 00 00 00       	mov    eax,0x1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cd5:	8d 65 e8             	lea    esp,[ebp-0x18]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cd8:	5b                   	pop    ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cd9:	5e                   	pop    esi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cda:	89 ec                	mov    esp,ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cdc:	5d                   	pop    ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cdd:	c3                   	ret    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048cde:	89 f6                	mov    esi,esi
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输入&lt;code&gt;9&lt;/code&gt;成功通过了这一关。&lt;/p&gt;
&lt;h3 id=&#34;phase_5&#34;&gt;phase_5&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;; phase_5 的参数为字符串 input ，在 [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;08048d2c &amp;lt;phase_5&amp;gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d2c:	55                   	push   ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d2d:	89 e5                	mov    ebp,esp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d2f:	83 ec 10             	sub    esp,0x10
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d32:	56                   	push   esi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d33:	53                   	push   ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; input -&amp;gt; ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d34:	8b 5d 08             	mov    ebx,DWORD PTR [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d37:	83 c4 f4             	add    esp,0xfffffff4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d3a:	53                   	push   ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 计算 input 字符串长度，如果长度不为 6 则爆炸
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d3b:	e8 d8 02 00 00       	call   8049018 &amp;lt;string_length&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d40:	83 c4 10             	add    esp,0x10
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d43:	83 f8 06             	cmp    eax,0x6
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d46:	74 05                	je     8048d4d &amp;lt;phase_5+0x21&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d48:	e8 af 07 00 00       	call   80494fc &amp;lt;explode_bomb&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 小知识：由于两数相同，所以使用 xor 来清零快一些
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d4d:	31 d2                	xor    edx,edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 不妨令这个变量为 str_a
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d4f:	8d 4d f8             	lea    ecx,[ebp-0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 地址 0x804b220 &amp;#34;isrveawhobpnutfg\260\001&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 怀疑是通过一些操作从上述字符串中取出字符重新拼接
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 不妨令这个字符串为 dict
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d52:	be 20 b2 04 08       	mov    esi,0x804b220
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 从这里开始是循环六次，后面的字符串常量长度也刚好为 6
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; al &amp;lt;- input[edx]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d57:	8a 04 1a             	mov    al,BYTE PTR [edx+ebx*1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 取 al 低四位
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d5a:	24 0f                	and    al,0xf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 拓展长度到 32 位
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d5c:	0f be c0             	movsx  eax,al
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; al &amp;lt;- dict[eax]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d5f:	8a 04 30             	mov    al,BYTE PTR [eax+esi*1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; str_a[edx] &amp;lt;- al
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d62:	88 04 0a             	mov    BYTE PTR [edx+ecx*1],al
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d65:	42                   	inc    edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d66:	83 fa 05             	cmp    edx,0x5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d69:	7e ec                	jle    8048d57 &amp;lt;phase_5+0x2b&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 循环结束
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 给字符串 str_a 结尾补上 &amp;#39;\0&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d6b:	c6 45 fe 00          	mov    BYTE PTR [ebp-0x2],0x0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d6f:	83 c4 f8             	add    esp,0xfffffff8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 地址 0x804980b &amp;#34;giants&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d72:	68 0b 98 04 08       	push   0x804980b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d77:	8d 45 f8             	lea    eax,[ebp-0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d7a:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 比较 str_a 和 &amp;#34;giants&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 所以输入字符串只看最低四位应该是 15 0 5 11 13 1 ，十六进制是 f 0 5 b d 1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 查看 ASCII 表，找到方便输入的内容，a-z 及其附近的字符很符合要求
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 所以使用 o`ekma
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048d7b:	e8 b0 02 00 00       	call   8049030 &amp;lt;strings_not_equal&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ......
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输入&lt;code&gt;o`ekma&lt;/code&gt;成功通过了这一关。&lt;/p&gt;
&lt;h3 id=&#34;phase_6&#34;&gt;phase_6&lt;/h3&gt;
&lt;p&gt;这一关比较长，我将它分为几个部分。&lt;/p&gt;
&lt;p&gt;一开始就能看到局部变量被赋值到一个神秘的地址，这应该解这题的关键。之后使用了&lt;code&gt;read_six_numbers&lt;/code&gt;这个函数读入六个数字。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;; phase_6 的参数为字符串 input ，在 [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;08048d98 &amp;lt;phase_6&amp;gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ......
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; input &amp;lt;- edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048da1:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; *(int *)0x804b26c 153
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 不妨令该局部变量为指针 C
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; C &amp;lt;- 0x804b26c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 它直接指向了一个神秘的结构
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048da4:	c7 45 cc 6c b2 04 08 	mov    DWORD PTR [ebp-0x34],0x804b26c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dab:	83 c4 f8             	add    esp,0xfffffff8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 不妨令该局部变量为数组 A
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dae:	8d 45 e8             	lea    eax,[ebp-0x18]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048db1:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048db2:	52                   	push   edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048db3:	e8 20 02 00 00       	call   8048fd8 &amp;lt;read_six_numbers&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;碰到的第一个循环：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; for (int i = 0; i &amp;lt;= 5; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;     if (A[i] &amp;gt; 6)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;         explode_bomb();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;     for (int j = i + 1; j &amp;lt;= 5; ++j) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;        if (A[i] == A[j])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;            explode_bomb();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;     }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; edi &amp;lt;- 0 不妨令其为 i
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048db8:	31 ff                	xor    edi,edi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dba:	83 c4 10             	add    esp,0x10
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dbd:	8d 76 00             	lea    esi,[esi+0x0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; eax &amp;lt;- A
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 循环 6 次
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dc0:	8d 45 e8             	lea    eax,[ebp-0x18]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; eax &amp;lt;- A[i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dc3:	8b 04 b8             	mov    eax,DWORD PTR [eax+edi*4]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; eax &amp;lt;- A[i] - 1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dc6:	48                   	dec    eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 如果 eax 大于 5 就爆炸，不能大于 6
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dc7:	83 f8 05             	cmp    eax,0x5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dca:	76 05                	jbe    8048dd1 &amp;lt;phase_6+0x39&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dcc:	e8 2b 07 00 00       	call   80494fc &amp;lt;explode_bomb&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; ebx &amp;lt;- i + 1 不妨令其为 j
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dd1:	8d 5f 01             	lea    ebx,[edi+0x1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; if (j &amp;lt;= 5)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dd4:	83 fb 05             	cmp    ebx,0x5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dd7:	7f 23                	jg     8048dfc &amp;lt;phase_6+0x64&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; eax &amp;lt;- 4 * edi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dd9:	8d 04 bd 00 00 00 00 	lea    eax,[edi*4+0x0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 不妨令这个局部变量为 B
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; B &amp;lt;- 4 * edi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048de0:	89 45 c8             	mov    DWORD PTR [ebp-0x38],eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; esi &amp;lt;- A
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048de3:	8d 75 e8             	lea    esi,[ebp-0x18]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 内层循环
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048de6:	8b 55 c8             	mov    edx,DWORD PTR [ebp-0x38]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; eax &amp;lt;- A[i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048de9:	8b 04 32             	mov    eax,DWORD PTR [edx+esi*1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 比较 A[i] 和 A[j]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dec:	3b 04 9e             	cmp    eax,DWORD PTR [esi+ebx*4]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 如果相等则引爆炸弹
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048def:	75 05                	jne    8048df6 &amp;lt;phase_6+0x5e&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048df1:	e8 06 07 00 00       	call   80494fc &amp;lt;explode_bomb&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048df6:	43                   	inc    ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048df7:	83 fb 05             	cmp    ebx,0x5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dfa:	7e ea                	jle    8048de6 &amp;lt;phase_6+0x4e&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 结束内层循环
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dfc:	47                   	inc    edi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048dfd:	83 ff 05             	cmp    edi,0x5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e00:	7e be                	jle    8048dc0 &amp;lt;phase_6+0x28&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 结束循环
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至此可以得出初步结论，第一个数字一定不大于 6 ，而且任意两个数字不相等&lt;/p&gt;
&lt;p&gt;碰到第二个循环：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; E = D;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; for (int i = 0, p = C; i &amp;lt;= 5; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;     j = 1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;     while (j &amp;lt; A[i]) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;         p = p-&amp;gt;next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;         j++;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;     }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;     E[i] = p;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; edi &amp;lt;- 0 不妨令其为 i
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e02:	31 ff                	xor    edi,edi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; ecx &amp;lt;- A
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e04:	8d 4d e8             	lea    ecx,[ebp-0x18]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 不妨令该局部变量为数组 D
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e07:	8d 45 d0             	lea    eax,[ebp-0x30]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 不妨令该局部变量为指针 E
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; E &amp;lt;- D
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e0a:	89 45 c4             	mov    DWORD PTR [ebp-0x3c],eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e0d:	8d 76 00             	lea    esi,[esi+0x0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 循环 6 次
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; esi &amp;lt;- C 不妨令其为指针 p
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; C 初值为 0x804b26c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e10:	8b 75 cc             	mov    esi,DWORD PTR [ebp-0x34]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; ebx &amp;lt;- 1 不妨令其为 j
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e13:	bb 01 00 00 00       	mov    ebx,0x1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e18:	8d 04 bd 00 00 00 00 	lea    eax,[edi*4+0x0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e1f:	89 c2                	mov    edx,eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 将 j 与 A[i] 比较
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e21:	3b 1c 08             	cmp    ebx,DWORD PTR [eax+ecx*1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e24:	7d 12                	jge    8048e38 &amp;lt;phase_6+0xa0&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 如果小于则执行下面这段
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; eax &amp;lt;- A[i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e26:	8b 04 0a             	mov    eax,DWORD PTR [edx+ecx*1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e29:	8d b4 26 00 00 00 00 	lea    esi,[esi+eiz*1+0x0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 内层循环
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 感觉是一个链表结构
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 猜测偏移为 0x8 的位置是 next 字段
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; p &amp;lt;- p-&amp;gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e30:	8b 76 08             	mov    esi,DWORD PTR [esi+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; j++
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e33:	43                   	inc    ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; while (j &amp;lt; A[i])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e34:	39 c3                	cmp    ebx,eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e36:	7c f8                	jl     8048e30 &amp;lt;phase_6+0x98&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 结束内层循环
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; edx &amp;lt;- E
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e38:	8b 55 c4             	mov    edx,DWORD PTR [ebp-0x3c]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; E[i] &amp;lt;- p
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e3b:	89 34 ba             	mov    DWORD PTR [edx+edi*4],esi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; i++
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e3e:	47                   	inc    edi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; while (i &amp;lt;= 5)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e3f:	83 ff 05             	cmp    edi,0x5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e42:	7e cc                	jle    8048e10 &amp;lt;phase_6+0x78&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 结束循环
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 GDB 查看一下那个神秘地址果然有了收获：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/3x 0x804b26c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b26c &amp;lt;node1&amp;gt;:	0x000000fd	0x00000001	0x0804b260
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/3x 0x804b260
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b260 &amp;lt;node2&amp;gt;:	0x000002d5	0x00000002	0x0804b254
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/3x 0x804b254
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b254 &amp;lt;node3&amp;gt;:	0x0000012d	0x00000003	0x0804b248
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/3x 0x804b248
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b248 &amp;lt;node4&amp;gt;:	0x000003e5	0x00000004	0x0804b23c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/3x 0x804b23c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b23c &amp;lt;node5&amp;gt;:	0x000000d4	0x00000005	0x0804b230
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/3x 0x804b230
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b230 &amp;lt;node6&amp;gt;:	0x000001b0	0x00000006	0x00000000
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;一共有六个节点
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;猜测三个字段分别为：&lt;code&gt;value&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;碰到第三个循环：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; p = D;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; C = D;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; for (int i = 1; i &amp;lt;= 5; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;     p-&amp;gt;next = D[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;     p = p-&amp;gt;next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; esi &amp;lt;- D 不妨令其为指针 p
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e44:	8b 75 d0             	mov    esi,DWORD PTR [ebp-0x30]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; C &amp;lt;- D
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e47:	89 75 cc             	mov    DWORD PTR [ebp-0x34],esi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; edi &amp;lt;- 1 令其为 i
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e4a:	bf 01 00 00 00       	mov    edi,0x1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; edx &amp;lt;- D
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e4f:	8d 55 d0             	lea    edx,[ebp-0x30]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 循环 6 次
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; eax &amp;lt;- D[i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e52:	8b 04 ba             	mov    eax,DWORD PTR [edx+edi*4]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; p-&amp;gt;next &amp;lt;- D[i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e55:	89 46 08             	mov    DWORD PTR [esi+0x8],eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; p &amp;lt;- p-&amp;gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e58:	89 c6                	mov    esi,eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; i++
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e5a:	47                   	inc    edi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; while (i &amp;lt;= 5)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e5b:	83 ff 05             	cmp    edi,0x5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e5e:	7e f2                	jle    8048e52 &amp;lt;phase_6+0xba&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 结束循环
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; p-&amp;gt;next = NULL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e60:	c7 46 08 00 00 00 00 	mov    DWORD PTR [esi+0x8],0x0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这部分代码相当于把数组&lt;code&gt;D&lt;/code&gt;串起来变为一个链表。&lt;/p&gt;
&lt;p&gt;碰到第四个循环：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; p = C;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; for (int i = 0; i &amp;lt;= 4; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;     if (p-&amp;gt;value &amp;lt; p-&amp;gt;next-&amp;gt;value) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;         explode_bomb();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;     p = p-&amp;gt;next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ;     i++;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 数组 D 组成的数列应该递减
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 所以我们可以将 6 个 node 排序
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 从大到小：node4 node2 node 6 node3 node1 node5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e67:	8b 75 cc             	mov    esi,DWORD PTR [ebp-0x34]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e6a:	31 ff                	xor    edi,edi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e6c:	8d 74 26 00          	lea    esi,[esi+eiz*1+0x0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 循环 5 次
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; edx &amp;lt;- p-&amp;gt;next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e70:	8b 56 08             	mov    edx,DWORD PTR [esi+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; eax &amp;lt;- p-&amp;gt;value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e73:	8b 06                	mov    eax,DWORD PTR [esi]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 将 p-&amp;gt;value 和 p-&amp;gt;next-&amp;gt;value 比较
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 即如果小于，则爆炸
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e75:	3b 02                	cmp    eax,DWORD PTR [edx]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e77:	7d 05                	jge    8048e7e &amp;lt;phase_6+0xe6&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e79:	e8 7e 06 00 00       	call   80494fc &amp;lt;explode_bomb&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; p &amp;lt;- p-&amp;gt;next 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e7e:	8b 76 08             	mov    esi,DWORD PTR [esi+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; i++
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e81:	47                   	inc    edi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; while (i &amp;lt;= 4)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e82:	83 ff 04             	cmp    edi,0x4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e85:	7e e9                	jle    8048e70 &amp;lt;phase_6+0xd8&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 结束循环
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于从大到小是&lt;code&gt;node4&lt;/code&gt;, &lt;code&gt;node2&lt;/code&gt;, &lt;code&gt;node6&lt;/code&gt;, &lt;code&gt;node3&lt;/code&gt;, &lt;code&gt;node1&lt;/code&gt;, &lt;code&gt;node5&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;输入字符串&lt;code&gt;4 2 6 3 1 5&lt;/code&gt;便能通过这关。&lt;/p&gt;
&lt;h3 id=&#34;secret_phase&#34;&gt;secret_phase&lt;/h3&gt;
&lt;p&gt;其实在 6 关之后还有一个隐藏关卡，需要一定的条件触发。&lt;/p&gt;
&lt;p&gt;可以直接在&lt;code&gt;bomb.disas&lt;/code&gt;里面查找函数&lt;code&gt;secret_phase&lt;/code&gt;，然后可以发现它在函数&lt;code&gt;phase_defused&lt;/code&gt;中被调用。&lt;/p&gt;
&lt;p&gt;首先在&lt;code&gt;phase_6&lt;/code&gt;打上断点，发现在&lt;code&gt;phase_defused&lt;/code&gt;中发现有怪异之处：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8049543:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 格式化字符串
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; (gdb) x/s 0x8049d03
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 0x8049d03:	&amp;#34;%d %s&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8049544:	68 03 9d 04 08       	push   0x8049d03
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 没有解锁隐藏关卡时，输入字符串只有一个 9 ，这与两个占位符的不相符
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 所以我们应该在 9 后面补上一个字符串
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 在 phase_6 打上断点
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; (gdb) break phase_6
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; (gdb) run
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; (gdb) x/s 0x804b770
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 0x804b770 &amp;lt;input_strings+240&amp;gt;:	&amp;#34;9&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8049549:	68 70 b7 04 08       	push   0x804b770
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 804954e:	e8 0d f3 ff ff       	call   8048860 &amp;lt;sscanf@plt&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8049553:	83 c4 10             	add    esp,0x10
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发现这里有个用于调试的标签&lt;code&gt;input_strings&lt;/code&gt;，我们可以看看&lt;code&gt;input_strings&lt;/code&gt; +0 +80 +160 都是什么：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/s 0x804b770-240
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b680 &amp;lt;input_strings&amp;gt;:	&amp;#34;Public speaking is very easy.&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/s 0x804b770-240+80
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b6d0 &amp;lt;input_strings+80&amp;gt;:	&amp;#34;1 2 6 24 120 720&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/s 0x804b770-240+160
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b720 &amp;lt;input_strings+160&amp;gt;:	&amp;#34;0 q 777&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发现是前三关输入的字符，所以&amp;quot;9&amp;quot;对应的是我们第四关的输入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 如果成功给两个参数赋值
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8049556:	83 f8 02             	cmp    eax,0x2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8049559:	75 37                	jne    8049592 &amp;lt;phase_defused+0x66&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 804955b:	83 c4 f8             	add    esp,0xfffffff8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 字符串比对
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; (gdb) x/s 0x8049d09
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 0x8049d09:	&amp;#34;austinpowers&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 可以得知第四关时后面应该添加一个&amp;#34;austinpowers&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 由此可以进入隐藏关卡
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ......
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 804958d:	e8 56 f9 ff ff       	call   8048ee8 &amp;lt;secret_phase&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们开始看函数&lt;code&gt;secret_phase&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;08048ee8 &amp;lt;secret_phase&amp;gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ee8:	55                   	push   ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ee9:	89 e5                	mov    ebp,esp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048eeb:	83 ec 14             	sub    esp,0x14
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048eee:	53                   	push   ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 将输入的字符串转换为数字
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 返回值在 eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048eef:	e8 08 03 00 00       	call   80491fc &amp;lt;read_line&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ef4:	6a 00                	push   0x0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ef6:	6a 0a                	push   0xa
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ef8:	6a 00                	push   0x0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048efa:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048efb:	e8 f0 f8 ff ff       	call   80487f0 &amp;lt;__strtol_internal@plt&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f00:	83 c4 10             	add    esp,0x10
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f03:	89 c3                	mov    ebx,eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f05:	8d 43 ff             	lea    eax,[ebx-0x1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 如果 input-1 大于 0x3e8 则爆炸
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f08:	3d e8 03 00 00       	cmp    eax,0x3e8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f0d:	76 05                	jbe    8048f14 &amp;lt;secret_phase+0x2c&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f0f:	e8 e8 05 00 00       	call   80494fc &amp;lt;explode_bomb&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f14:	83 c4 f8             	add    esp,0xfffffff8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f17:	53                   	push   ebx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 该地址可能指向一个数组或者结构
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f18:	68 20 b3 04 08       	push   0x804b320
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f1d:	e8 72 ff ff ff       	call   8048e94 &amp;lt;fun7&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f22:	83 c4 10             	add    esp,0x10
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 如果返回值为 7 则成功
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f25:	83 f8 07             	cmp    eax,0x7
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048f28:	74 05                	je     8048f2f &amp;lt;secret_phase+0x47&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ......
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于调用了函数&lt;code&gt;fun7&lt;/code&gt;，我们直接来看它。&lt;code&gt;func7&lt;/code&gt;是一个比较简单的递归函数，主要是结构体较为复杂：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;08048e94 &amp;lt;fun7&amp;gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e94:	55                   	push   ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e95:	89 e5                	mov    ebp,esp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e97:	83 ec 08             	sub    esp,0x8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e9a:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048e9d:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ea0:	85 d2                	test   edx,edx
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ea2:	75 0c                	jne    8048eb0 &amp;lt;fun7+0x1c&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ea4:	b8 ff ff ff ff       	mov    eax,0xffffffff
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ea9:	eb 37                	jmp    8048ee2 &amp;lt;fun7+0x4e&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048eab:	90                   	nop
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048eac:	8d 74 26 00          	lea    esi,[esi+eiz*1+0x0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048eb0:	3b 02                	cmp    eax,DWORD PTR [edx]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048eb2:	7d 11                	jge    8048ec5 &amp;lt;fun7+0x31&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048eb4:	83 c4 f8             	add    esp,0xfffffff8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048eb7:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 类似链表的结构
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048eb8:	8b 42 04             	mov    eax,DWORD PTR [edx+0x4]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ebb:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ebc:	e8 d3 ff ff ff       	call   8048e94 &amp;lt;fun7&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ec1:	01 c0                	add    eax,eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ec3:	eb 1d                	jmp    8048ee2 &amp;lt;fun7+0x4e&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ec5:	3b 02                	cmp    eax,DWORD PTR [edx]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ec7:	74 17                	je     8048ee0 &amp;lt;fun7+0x4c&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ec9:	83 c4 f8             	add    esp,0xfffffff8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ecc:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; ; 类似链表的结构
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ecd:	8b 42 08             	mov    eax,DWORD PTR [edx+0x8]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ed0:	50                   	push   eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ed1:	e8 be ff ff ff       	call   8048e94 &amp;lt;fun7&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ed6:	01 c0                	add    eax,eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ed8:	40                   	inc    eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ed9:	eb 07                	jmp    8048ee2 &amp;lt;fun7+0x4e&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048edb:	90                   	nop
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048edc:	8d 74 26 00          	lea    esi,[esi+eiz*1+0x0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ee0:	31 c0                	xor    eax,eax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ee2:	89 ec                	mov    esp,ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ee4:	5d                   	pop    ebp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ee5:	c3                   	ret    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 8048ee6:	89 f6                	mov    esi,esi
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到有类似链表的结构，但是它拥有两个指针域，我们可以把它想象为一棵树：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// fun7 输入参数：指针 p 和 整型 n
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// p 可以理解为二叉树的节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; TreeNode {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; TreeNode *left;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; TreeNode *right;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} TreeNode;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样一来&lt;code&gt;fun7&lt;/code&gt;马上可以写成 C 语言：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; fun7(TreeNode *p, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; n) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (p == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; -&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (n-&amp;gt;value &amp;lt; p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;]) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; * fun7(p-&amp;gt;left, n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (n == p[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;]) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; * fun7(p-&amp;gt;right, n) + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于需要递归函数返回 7 (参数&lt;code&gt;(p, n)&lt;/code&gt;)，所以内一层只能返回 3 (参数&lt;code&gt;(p-&amp;gt;right, n)&lt;/code&gt;)， 再内一层只能返回 1 &lt;code&gt;(p-&amp;gt;right-&amp;gt;right, n)&lt;/code&gt;，最里面一层返回 0 &lt;code&gt;(p-&amp;gt;right-&amp;gt;right-&amp;gt;right, n)&lt;/code&gt;。 所以第一次调用时&lt;code&gt;p-&amp;gt;righ-&amp;gt;right-&amp;gt;right-&amp;gt;value&lt;/code&gt;应该与&lt;code&gt;n&lt;/code&gt;相等&lt;/p&gt;
&lt;p&gt;可以通过 GDB 很快找到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;#                   value         left          right
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/3x 0x804b320
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b320 &amp;lt;n1&amp;gt;:     0x00000024    0x0804b314    0x0804b308
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/3x 0x0804b308
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b308 &amp;lt;n22&amp;gt;:    0x00000032    0x0804b2f0    0x0804b2d8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/3x 0x0804b2d8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b2d8 &amp;lt;n34&amp;gt;:    0x0000006b    0x0804b2b4    0x0804b278
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(gdb) x/3x 0x0804b278
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x804b278 &amp;lt;n48&amp;gt;:    0x000003e9    0x00000000    0x00000000
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以应该输入&lt;code&gt;3e9&lt;/code&gt;也就是十进制&lt;code&gt;1001&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入文件&#34;&gt;输入文件&lt;/h3&gt;
&lt;p&gt;如下是最后通过测试的输入文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cat input
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Public speaking is very easy.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1 2 6 24 120 720
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0 q 777
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;9 austinpowers
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;o`ekma
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4 2 6 3 1 5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1001
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;实验感受&#34;&gt;实验感受&lt;/h2&gt;
&lt;p&gt;这六关分别涉及了字符串常量、循环、switch-case（跳转表）、递归、数组、链表等知识，难度没有想象中那么大，耐心看汇编代码其实是很容易看懂的。而隐藏关卡需要细心或者运气发现，但是解决它并不是问题。&lt;/p&gt;
&lt;p&gt;做 Lab 时没有动态调试这个程序，感觉也没有动态调试的必要，只要看到了“魔法”地址就可以直接 GDB 查看它。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>稍微深入VLA</title>
      <link>https://vaaandark.top/posts/dive-in-vla/</link>
      <pubDate>Thu, 20 Oct 2022 10:50:10 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/dive-in-vla/</guid>
      <description>&lt;p&gt;最近在学习汇编语言，和朋友聊天时聊到了 C 语言中的变长数组，想知道在汇编后是什么样子的。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;变长数组variable-length-array&#34;&gt;变长数组(Variable-length array)&lt;/h2&gt;
&lt;p&gt;可变长数组是指在计算机程序设计中，数组对象的长度在运行时（而不是编译时）确定。&lt;/p&gt;
&lt;p&gt;C/C++的灵活数组类型（又称柔性数组成员）是另外一个语言特性。&lt;/p&gt;
&lt;h2 id=&#34;反汇编-vla&#34;&gt;反汇编 VLA&lt;/h2&gt;
&lt;p&gt;C 语言代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; n;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; a[n];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;反汇编代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mov    eax,DWORD PTR [ebp-0x14] &lt;span style=&#34;color:#007f7f&#34;&gt;; eax &amp;lt;- [n]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;lea    edx,[eax-0x1]            &lt;span style=&#34;color:#007f7f&#34;&gt;; edx &amp;lt;- [n - 1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;mov    DWORD PTR [ebp-0xc],edx  &lt;span style=&#34;color:#007f7f&#34;&gt;; [n - 8] &amp;lt;- edx
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;lea    edx,[eax*&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x0&lt;/span&gt;]          &lt;span style=&#34;color:#007f7f&#34;&gt;; edx &amp;lt;- [n * 4 + 0] VLA 的长度
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;mov    eax,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x10&lt;/span&gt;                 &lt;span style=&#34;color:#007f7f&#34;&gt;; eax &amp;lt;- 16
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;sub    eax,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x1&lt;/span&gt;                  &lt;span style=&#34;color:#007f7f&#34;&gt;; eax -= 1 =&amp;gt; eax = 15
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;add    eax,edx                  &lt;span style=&#34;color:#007f7f&#34;&gt;; eax += edx =&amp;gt; eax = 15 + nbytes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;mov    ecx,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x10&lt;/span&gt;                 &lt;span style=&#34;color:#007f7f&#34;&gt;; ecx &amp;lt;- 16
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;mov    edx,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x0&lt;/span&gt;                  &lt;span style=&#34;color:#007f7f&#34;&gt;; edx &amp;lt;- 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;div    ecx                      &lt;span style=&#34;color:#007f7f&#34;&gt;; eax /= 16
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;imul   eax,eax,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x10&lt;/span&gt;             &lt;span style=&#34;color:#007f7f&#34;&gt;; eax *= 16
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;                                &lt;span style=&#34;color:#007f7f&#34;&gt;; (15 + nbytes) / 16 * 16 用于对齐
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;                                &lt;span style=&#34;color:#007f7f&#34;&gt;; 因此上面几条指令没有抵消
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;sub    esp,eax                  &lt;span style=&#34;color:#007f7f&#34;&gt;; esp -= eax 在栈中为 VLA 预留空间
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;mov    eax,esp                  &lt;span style=&#34;color:#007f7f&#34;&gt;; eax &amp;lt;- esp VLA 的地址
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;add    eax,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x3&lt;/span&gt;                  &lt;span style=&#34;color:#007f7f&#34;&gt;; eax += 3 =&amp;gt; eax = 18 + nbytes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;shr    eax,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x2&lt;/span&gt;                  &lt;span style=&#34;color:#007f7f&#34;&gt;; eax &amp;gt;&amp;gt;= 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;shl    eax,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x2&lt;/span&gt;                  &lt;span style=&#34;color:#007f7f&#34;&gt;; eax &amp;lt;&amp;lt;= 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;                                &lt;span style=&#34;color:#007f7f&#34;&gt;; (eax + 3) / 2 * 2 用于对齐
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;                                &lt;span style=&#34;color:#007f7f&#34;&gt;; 因此上面几条指令没有抵消
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;mov    DWORD PTR [ebp-0x10],eax &lt;span style=&#34;color:#007f7f&#34;&gt;; [n + 4] &amp;lt;- eax 给 a 赋上 VLA 的地址
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因此在创建 VLA 时先在栈上分配内存同时要注意对齐，再将分配好的内存地址赋值给数组。&lt;/p&gt;
&lt;p&gt;与直接创建在栈上的定长数组不同，变长数组访问元素时需要两次寻址。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>80X86汇编语言学习</title>
      <link>https://vaaandark.top/posts/80x86-learning/</link>
      <pubDate>Tue, 27 Sep 2022 14:47:57 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/80x86-learning/</guid>
      <description>&lt;p&gt;汇编语言学习笔记&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;预备知识&#34;&gt;预备知识&lt;/h2&gt;
&lt;h3 id=&#34;intel-机器&#34;&gt;Intel 机器&lt;/h3&gt;
&lt;h4 id=&#34;微型计算机的构成&#34;&gt;微型计算机的构成&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&#34;微型计算机的构成&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/asm-intel-x86.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;80x86-微处理器的基本结构&#34;&gt;80X86 微处理器的基本结构&lt;/h4&gt;
&lt;p&gt;&lt;img alt=&#34;80X86微处理器的基本结构&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/asm-80x86.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据寄存器组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;数据寄存器组&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/asm-data-registers.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;段寄存器组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;段寄存器组&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/asm-seg-registers.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;80x86-的三种工作方式&#34;&gt;80X86 的三种工作方式&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;实地址模式&lt;/li&gt;
&lt;li&gt;保护模式&lt;/li&gt;
&lt;li&gt;虚拟 8086 方式（V86方式）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据在计算机内的表示形式&#34;&gt;数据在计算机内的表示形式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有符号数、无符号数、浮点数等相关知识见 CSAPP&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;bcd-码&#34;&gt;BCD 码&lt;/h4&gt;
&lt;p&gt;使用二进制数表示十进制数，即使用 4 位二进制数表示一位 10 进制数。&lt;/p&gt;
&lt;p&gt;在 8086 中有两种存放 BCD 码的方式，压缩和非压缩。&lt;/p&gt;
&lt;h3 id=&#34;标志寄存器&#34;&gt;标志寄存器&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;标志寄存器&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/asm-flag-reg.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;主要需要掌握 SF ZF OF CF AF PF&lt;/p&gt;
&lt;h2 id=&#34;寻址方式&#34;&gt;寻址方式&lt;/h2&gt;
&lt;h3 id=&#34;寄存器寻址&#34;&gt;寄存器寻址&lt;/h3&gt;
&lt;p&gt;使用格式：&lt;code&gt;R&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inc bx&lt;/code&gt; 操作数地址为寄存器 BX 。&lt;/p&gt;
&lt;h3 id=&#34;寄存器间接寻址&#34;&gt;寄存器间接寻址&lt;/h3&gt;
&lt;p&gt;使用格式：&lt;code&gt;[R]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;寄存器 R 的内容为操作数的偏移地址。&lt;/p&gt;
&lt;p&gt;可以指明操作数所在的段，如&lt;code&gt;ss:[R]&lt;/code&gt;。如果没有指定段，当 R 选用 BP, EBP, ESP ，则默认在堆栈段中，如果选用其他寄存器则默认在 DS 所指示的段中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mov ax, [si]&lt;/code&gt; 将数据段上偏移&lt;code&gt;[si]&lt;/code&gt;的数据传送到 AX 中。&lt;/p&gt;
&lt;h3 id=&#34;变址寻址&#34;&gt;变址寻址&lt;/h3&gt;
&lt;p&gt;使用格式：&lt;code&gt;[R * F + V]&lt;/code&gt;, &lt;code&gt;[R * F] + V&lt;/code&gt;, &lt;code&gt;V[R * F]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;功能：寄存器 R 的内容乘以指定的比例因子 F （可以为 1, 2, 4, 8）后加上给定的位移量 V 作为操作数的偏移地址。&lt;/p&gt;
&lt;p&gt;当 R 为 16 为寄存器或 ESP 时，F 只能为 1 并省略不写。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mov al, [ebx * 2] + 5&lt;/code&gt; 由于使用的变址寄存器是 EBX ，故默认段寄存器 DS 。&lt;/p&gt;
&lt;h3 id=&#34;基址加变址寻址&#34;&gt;基址加变址寻址&lt;/h3&gt;
&lt;p&gt;使用格式：&lt;code&gt;[BR + IR * F + V]&lt;/code&gt;, &lt;code&gt;V[BR][IR * F]&lt;/code&gt;, &lt;code&gt;V[BR + IR * F]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;功能：将变址寄存器 IR 的内容乘以比例因子 F ，与基址寄存器 BR 的内容和位移量 V 相加，作为操作数的偏移地址 EA 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mov ax, 8[bx][si]&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;立即寻址&#34;&gt;立即寻址&lt;/h3&gt;
&lt;p&gt;使用格式：&lt;code&gt;n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;功能：指定指令最后一部分单元中的内容为操作数，即在当前执行到的机器代码部分找到操作数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mov word ptr [si], 12h&lt;/code&gt; WORD PTR 说明操作数的类型为字。&lt;/p&gt;
&lt;h3 id=&#34;直接寻址&#34;&gt;直接寻址&lt;/h3&gt;
&lt;p&gt;使用格式：&lt;code&gt;段寄存器名: [n]&lt;/code&gt;, &lt;code&gt;变量&lt;/code&gt;, &lt;code&gt;变量 + 常量&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;一些问题&#34;&gt;一些问题&lt;/h3&gt;
&lt;p&gt;有一些指令显式地指定操作数，另一些隐含地指定操作数。如&lt;code&gt;CBW&lt;/code&gt;将 AL 寄存器中的符号位扩展到 AH 中，又如&lt;code&gt;push bufa&lt;/code&gt;压入栈顶，隐含了目的操作数，是使用 SP/ESP 的寄存器间接寻址方式。&lt;/p&gt;
&lt;p&gt;双操作数指令的源操作数和目的操作数的寻址方式必须满足以下五种组合之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寄存器对寄存器；&lt;/li&gt;
&lt;li&gt;寄存器对存储器；&lt;/li&gt;
&lt;li&gt;存储器对寄存器；&lt;/li&gt;
&lt;li&gt;立即方式对寄存器，立即方式只能用于源操作数；&lt;/li&gt;
&lt;li&gt;立即方式对存储器，立即方式只能用于源操作数；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;源操作数和目的操作数不能同时用存储器方式表示。&lt;/p&gt;
&lt;p&gt;不含变量的存储器方式所表示的操作数类型是不明确的，立即数是没有类型的。如果指令语句中没有一个操作数的类型是明确的，则必须使用属性定义算符 PTR（字节类型 BYTE PTR ，字类型 WORD PTR ，双字类型 DWORD PTR）&lt;/p&gt;
&lt;p&gt;下面几种情况使用的缺省段不受段超越前缀影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取指令（包括立即数）时只能使用 CS 段；&lt;/li&gt;
&lt;li&gt;压栈时目的地址和出栈时源地址只能使用 SS 段；&lt;/li&gt;
&lt;li&gt;串操作指令中的目的串只使用 ES 段；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;宏汇编语言&#34;&gt;宏汇编语言&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>垃圾回收</title>
      <link>https://vaaandark.top/posts/gc/</link>
      <pubDate>Sat, 17 Sep 2022 11:27:19 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/gc/</guid>
      <description>&lt;p&gt;之前学习了 Lua 的 Table 和协程，对 Lua 中另一个重要模块 GC 还有很多疑问，这次就来学习一下。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;gc-简介与策略分类&#34;&gt;GC 简介与策略分类&lt;/h2&gt;
&lt;p&gt;在计算机科学中，垃圾收集(GC)是一种自动内存管理形式。垃圾收集器尝试回收程序分配但不再引用的内存；这样的内存被称为垃圾。&lt;/p&gt;
&lt;h3 id=&#34;追踪tracing&#34;&gt;追踪(Tracing)&lt;/h3&gt;
&lt;p&gt;Tracing 的策略简单讲就是使用一些根对象来遍历所有的引用，可以访问到的就不是垃圾，不能访问到的就是需要回收的垃圾。虽然这个说起来和实现起来很简单，但是想要使其有较好的性能并不是一件很容易的事情。Tracing 有很多需要考虑的问题，例如收集的周期(步进 Pace)是什么，是按照时间片还是按照已经分配过的内存，是否会出现为了收集垃圾程序执行出现明显卡死现象等。&lt;/p&gt;
&lt;p&gt;之后用到的 Lisp 和 Lua 的例子都以 Tracing 策略为主。&lt;/p&gt;
&lt;h3 id=&#34;引用计数reference-counting&#34;&gt;引用计数(Reference counting)&lt;/h3&gt;
&lt;p&gt;引用计数垃圾收集是每个对象都有一个对它的引用数的计数。垃圾通过引用计数为零来标识。对象的引用计数在创建对它的引用时增加，在引用被销毁时减少。当计数达到零时，对象的内存被回收。&lt;/p&gt;
&lt;h4 id=&#34;循环引用&#34;&gt;循环引用&lt;/h4&gt;
&lt;p&gt;如果有两个对象相互引用，就会导致它们的引用计数永远大于等于 1 ，它们永远不会被回收。对于这个问题，一般有两种解决方案。一种比较直观，直接检测是否出现循环，cpython 就使用的这种方法；另一种就是引入弱引用的概念。&lt;/p&gt;
&lt;p&gt;弱引用不会增加引用计数，而且指向的对象可能是已经被回收的，因此可以简单地检测出是否失效，而不是保持引用悬垂。&lt;/p&gt;
&lt;h4 id=&#34;额外空间开销&#34;&gt;额外空间开销&lt;/h4&gt;
&lt;p&gt;明显地，如果使用引用计数的策略就需要额外的空间来存储计数。有的是存在对象中，有的是存在一个表之中。在一些语言例如 objective-c 中，它们将引用计数存在指针地址未使用的位当中（我认为这对不同处理器间可移植性有影响）。&lt;/p&gt;
&lt;h4 id=&#34;额外时间开销&#34;&gt;额外时间开销&lt;/h4&gt;
&lt;p&gt;例如如果使用&lt;code&gt;for item in something&lt;/code&gt;的方法遍历，在每个循环开始都有&lt;code&gt;rc++&lt;/code&gt;每个结尾都有&lt;code&gt;rc--&lt;/code&gt;，优秀的 GC 应该把这个消除掉。&lt;/p&gt;
&lt;h4 id=&#34;并行&#34;&gt;并行&lt;/h4&gt;
&lt;p&gt;如果需要编写并行代码则需让 rc 的操作具有原子性，最重要的一点是它们不可以是全局变量了。&lt;/p&gt;
&lt;h4 id=&#34;自动引用计数automatic-reference-counting&#34;&gt;自动引用计数(Automatic Reference counting)&lt;/h4&gt;
&lt;p&gt;自动引用计数无需运行时，会在编译阶段处理引用计数并实现内存管理，但是难以处理循环引用的问题。神奇的 Rust 较好地解决了这个问题，方法还是使用弱引用，可以看 &lt;a href=&#34;https://doc.rust-lang.org/std/sync/struct.Arc.html&#34;&gt;Arc 的实现&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Breaking cycles with Weak&lt;/p&gt;
&lt;p&gt;The downgrade method can be used to create a non-owning Weak pointer. A Weak pointer can be upgraded to an Arc, but this will return None if the value stored in the allocation has already been dropped. In other words, Weak pointers do not keep the value inside the allocation alive; however, they do keep the allocation (the backing store for the value) alive.&lt;/p&gt;
&lt;p&gt;A cycle between Arc pointers will never be deallocated. For this reason, Weak is used to break cycles. For example, a tree could have strong Arc pointers from parent nodes to children, and Weak pointers from children back to their parents.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过，无论是朴素的引用计数还是自动引用计数，一旦引入弱引用就可能增加代码编写者的心智负担和精神内耗，让垃圾回收没有那么省心省力。&lt;/p&gt;
&lt;h3 id=&#34;逃逸分析escape-analysis&#34;&gt;逃逸分析(Escape analysis)&lt;/h3&gt;
&lt;p&gt;这个比较好理解，它的原理就是将一些不必要的堆分配变成栈分配，例如在一个函数之中，如果一个对象不会被传递到外部，Escape analysis 就可以将它从堆分配变为栈分配从而减少所需要的垃圾收集量。&lt;/p&gt;
&lt;h2 id=&#34;ulisp-gc&#34;&gt;ulisp GC&lt;/h2&gt;
&lt;p&gt;这是一种很 naive 的 GC ，采用的是最为朴素的 mark-and-sweep 中的双色标记法。&lt;/p&gt;
&lt;p&gt;首先调用 markobject() 函数对所有还能够访问的对象进行标记&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ulisp 是一种广泛用于嵌入式的 lisp 方言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; markobject (object *obj) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MARK:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (obj == &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;NULL&lt;/span&gt;) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (marked(obj)) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  object* arg = car(obj);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; type = obj-&amp;gt;type;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  mark(obj);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (type &amp;gt;= PAIR || type == ZERO) { &lt;span style=&#34;color:#007f7f&#34;&gt;// cons
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    markobject(arg);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    obj = cdr(obj);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;goto&lt;/span&gt; MARK;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 cons 是一种广义表，由两个指针组成，car 提取第一个指针，cdr 提取第二个指针。上面这个函数用了一种不够美观的方式消除了部分递归。&lt;/p&gt;
&lt;p&gt;这里的 mark(x) 宏利用内存对齐使用了一个技巧：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define mark(x)            (car(x) = (object *)(((unsigned int)(car(x))) | 0x0001))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为内存对齐到偶数位，所以最低位为 0 ，将 car(x) 的最低位置为 1 的标记操作是合理的，而且节约了内存。&lt;/p&gt;
&lt;p&gt;sweep() 函数则用于清理对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; sweep () {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Freelist = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Freespace = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i=WORKSPACESIZE-&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; i&amp;gt;=&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i--) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    object *obj = &amp;amp;Workspace[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (!marked(obj)) myfree(obj); &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; unmark(obj);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; myfree (object *obj) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  car(obj) = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cdr(obj) = Freelist;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Freelist = obj;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Freespace++;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的清理没有使用 free 等库函数是因为 ulisp 一般用于嵌入式环境中，它的内存管理就是管理一个保存对象地址的静态大数组，全局变量 Freelist 指向数组第一个为空的地方，Freespace 表示还剩余多少空间。&lt;/p&gt;
&lt;p&gt;ulisp 的 gc 周期设置也比较朴素，每次 eval 被调用时检测一下剩余内存空间，如果小于 20 个对象的大小就垃圾收集。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (Freespace &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;20&lt;/span&gt;) gc(form, env);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;lua-gc&#34;&gt;Lua GC&lt;/h2&gt;
&lt;p&gt;Lua GC 也采用了 mark-and-sweep 的策略，但是它使用的不再是双色标记，而是更加优秀的三色标记法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lua 5.0 之前使用的是双色标记法，和 ulisp 大同小异。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;lua-gc-规则&#34;&gt;Lua GC 规则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Lua 中所有对象需要垃圾回收，包括了 table 、函数、协程、模组。&lt;/li&gt;
&lt;li&gt;只有通过根集(root set)可以访问到的对象才会被保存。
&lt;ul&gt;
&lt;li&gt;root set ::= registry + shared metatables&lt;/li&gt;
&lt;li&gt;registry ::= global table(_G) + main thread + package.loaded&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lua 垃圾收集调用的是标准库内存分配函数（其实整个 Lua 都只用了标准库）。&lt;/li&gt;
&lt;li&gt;所有的对象都被一个链表储存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lua-gc-pace&#34;&gt;Lua GC Pace&lt;/h3&gt;
&lt;p&gt;如果 GC 从不运行就没有消耗额外的 CPU 周期，但是会浪费大量内存；如果 GC 一直运行就不会浪费额外的内存，但是会消耗大量 CPU 周期。因此我们需要找到一个合适的 GC 运行间隔。&lt;/p&gt;
&lt;p&gt;Lua 5.0 采取的方法是当此次内存分配达到上次内存分配的两倍时调用 GC 。但这就造成了一个问题，虚拟机会停下来收集完垃圾再继续执行(stop the world)，这也就是 Lua 5.0 及之前都只能作为小小胶水语言使用的原因。&lt;/p&gt;
&lt;h3 id=&#34;增量收集&#34;&gt;增量收集&lt;/h3&gt;
&lt;p&gt;在 5.1 版本中，Lua 有了一个增量收集器，将收集器的执行与主程序交错执行。这也导致 GC 内保存的不再是一个可以直接分析的静态数据，必须引入三色标记。&lt;/p&gt;
&lt;h3 id=&#34;三色标记法&#34;&gt;三色标记法&lt;/h3&gt;
&lt;p&gt;采用了一种三色标记的算法。每个对象都有三个状态：无法被访问到的对象是白色，可访问到，但没有递归扫描完全的对象是灰色，完全扫描过的对象是黑色。理想状况下，GC 只需要充分遍历灰色对象就可以完成收集。&lt;/p&gt;
&lt;h4 id=&#34;mutator-导致的问题&#34;&gt;Mutator 导致的问题&lt;/h4&gt;
&lt;p&gt;考虑一种情况，一个变量 x 已经被标记为黑色，但是解释执行&lt;code&gt;x.a = {}&lt;/code&gt;，很明显&lt;code&gt;{}&lt;/code&gt;是一个白色对象，这就形成了黑色对象指向白色对象的问题（导致这个问题的原因是对象的可变性）。此时我们不得不改变 x 的颜色，&lt;del&gt;给死去的变量打复活赛&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;这时是将 {} 改变为灰色，还是把 x 变成灰色是个问题，刚好 Lua 提供了这两个接口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LUAI_FUNC &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LUAI_FUNC &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; luaC_barrierback_ (lua_State *L, GCObject *o);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;何时使用何种方法其实是看设计者的经验。&lt;/p&gt;
&lt;p&gt;在刚刚说的这种情况中，Lua 采用的是将 x 变为灰色的方法，因为给一个 table 中的字段赋值说明这个 table 很有可能还要被复用；而在 metatable 中遇到这种情况就采取的是另一种方法。&lt;/p&gt;
&lt;h3 id=&#34;分代式-gc&#34;&gt;分代式 GC&lt;/h3&gt;
&lt;p&gt;想象一个场景，我们在代码的某处（甚至可以想象就是代码开头）使用了一个巨大的矩阵，之后再也没有比它更大的内存分配了，那么 Lua 5.1 的 GC 可能只会运行一次。&lt;/p&gt;
&lt;p&gt;因此基于假设大部分对象在创建出来后不久就被回收掉(m&lt;em&gt;ost objects die young&lt;/em&gt;)的假设，Lua 5.2 设计了分代式 GC ，并在 5.4 中完善。&lt;/p&gt;
&lt;h4 id=&#34;old-and-young&#34;&gt;Old and Young&lt;/h4&gt;
&lt;p&gt;所有的对象被划分为年轻的(young)和年老的(old)：对象刚被创建时是年轻的，当存活过两轮垃圾收集则变为年老的。在每次次级垃圾收集中，GC 只遍历并清除年轻的变量。&lt;/p&gt;
&lt;p&gt;注意在分代中的重要规则：老对象不能指向新对象。因此遇到这种情况时，如果我们将新对象变为老对象(forward)就可能出现大量的老对象，让分代式退化到原来的版本；如果我们将老对象变为新对象(backward)，就可能在别的地方破坏规则（例如这个老对象被别的对象引用）。&lt;/p&gt;
&lt;h4 id=&#34;the-touched-objects&#34;&gt;The Touched Objects&lt;/h4&gt;
&lt;p&gt;为了解决上述的问题，Lua 引入了被触碰过的对象这一概念，在刚刚的情景下，老对象会被标记为被触碰过的对象并被放入一个特殊的列表中。&lt;/p&gt;
&lt;p&gt;在每次次级垃圾收集中，被触碰过的变量会被遍历，但不会被收集（可能会收集它们指向的新对象）。&lt;/p&gt;
&lt;p&gt;在经历两次垃圾收集（非次级）后，被触碰过的变量指向的子对象都变成老对象了，因此他们也会恢复成为老对象。&lt;/p&gt;
&lt;h4 id=&#34;lua-52-分代的问题&#34;&gt;Lua 5.2 分代的问题&lt;/h4&gt;
&lt;p&gt;在 Lua 5.3 的设计中，一个新对象经历一次收集而不被回收就会成为老对象。如果它刚好在一次回收前被创建而且本应该在那次回收之后不久被回收，本不应该成为老对象的它就会成为老对象。&lt;/p&gt;
&lt;p&gt;过多的老对象就导致 5.2 的性能堪忧。&lt;/p&gt;
&lt;h3 id=&#34;userdata-导致的问题&#34;&gt;userdata 导致的问题&lt;/h3&gt;
&lt;p&gt;由于 Lua 是一种可以与 C 互相嵌入的语言，因此不可避免地会使用到 C 中的数据结构(userdata)，但又由于 Lua 支持给 userdata 定义 __gc 方法，故要区分有无 __gc 方法的 userdata 。&lt;/p&gt;
&lt;p&gt;标记流程要分为两步，先是把包括 userdata 的死对象标记，再将 userdata 中有 __gc 方法的复活，让它们在下一轮被收集。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ulisp.com/show?1BD3&#34;&gt;ulisp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/sync/struct.Arc.html&#34;&gt;Rust Arc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&#34;&gt;wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.codingnow.com/2018/10/lua_gc.html&#34;&gt;云风的BLOG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lua.org/wshop18/Ierusalimschy.pdf&#34;&gt;Lua 之父的演讲ppt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>FreeDOS和masm开发环境配置</title>
      <link>https://vaaandark.top/posts/freedos-and-masm-environment/</link>
      <pubDate>Fri, 16 Sep 2022 16:22:34 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/freedos-and-masm-environment/</guid>
      <description>&lt;p&gt;正在上计算机系统基础，目前主要是在讲汇编语言，使用的开发环境自然是又老又臭的 DOS 加上 MASM 。之前我看到过 FreeDOS 这个自由的 DOS 发行版，打算试吃一下，之后的汇编实验也将在这上面进行。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;安装与配置&#34;&gt;安装与配置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;首先在&lt;a href=&#34;https://www.freedOS.org/download/&#34;&gt;FreeDOS 官网&lt;/a&gt;上下载最新的系统镜像，我选择的是 FreeDOS 1.3 LiveCD 。下载之后将其解压到一个文件夹内，有三个文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% ls
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;FD13BOOT.img  FD13LIVE.iso  readme.txt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;再使用虚拟机安装 FreeDOS ，&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% qemu-img create freedos.img 500M &lt;span style=&#34;color:#007f7f&#34;&gt;# 创建 QEMU 的虚拟磁盘&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% qemu-system-i386 -m 32M -drive file=freedos.img,media=disk,format=raw -drive file=FD13LIVE.iso,media=cdrom -boot order=d &lt;span style=&#34;color:#007f7f&#34;&gt;# 启动镜像&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后就是和安装 Linux 发行版大同小异的操作了。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;挂载虚拟磁盘到 Host 。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% sudo mkdir -p /mnt/freedos
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% sudo mount -t msdos -o uid=1000,loop,offset=&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;32256&lt;/span&gt; freedos.img /mnt/freedos
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;安装 MASM ，可以直接将文件放置到挂载的地方，重启 FreeDOS 后就可以使用了。使用时不再需要 LiveCD 的镜像：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% qemu-system-i386 -m 32M -drive file=freedos.img,media=disk,format=raw -boot order=d
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;疑惑&#34;&gt;疑惑&lt;/h2&gt;
&lt;p&gt;可能是 FreeDOS 文件系统，也可能是 qemu 的缓存问题，我在 Host 对文件的操作只有在重启 FreeDOS 之后才会在 guest 中生效。&lt;/p&gt;
&lt;p&gt;在这个&lt;a href=&#34;https://unix.stackexchange.com/questions/485822/how-to-mount-a-linux-host-filesystem-with-freedos-running-in-qemu&#34;&gt;帖子&lt;/a&gt;中也有人遇到了这个问题：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;However, it&amp;rsquo;s limited to 512MB, and doesn&amp;rsquo;t reflect any changes made to the directory from the host system after QEMU starts.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;另一个&lt;a href=&#34;https://superuser.com/questions/1630317/how-to-transfer-files-from-host-to-dos-qemu-c-drive&#34;&gt;帖子&lt;/a&gt;也有人提到：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;You should never write to the FAT directory on the host system while accessing it with the guest system. If want to add new files to &amp;lsquo;share&amp;rsquo;, shutdown the virtual machine before.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;打算有时间看一下&lt;a href=&#34;https://www.qemu.org/docs/master/system/images.html#virtual-fat-disk-images&#34;&gt;QEMU 的 FAT 文档&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何使用Lua写一个NeoVim插件</title>
      <link>https://vaaandark.top/posts/how-to-write-a-plugin-for-neovim-in-lua/</link>
      <pubDate>Thu, 18 Aug 2022 17:18:42 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/how-to-write-a-plugin-for-neovim-in-lua/</guid>
      <description>&lt;p&gt;之前学习了如何写 Lua 程序，又因为 NeoVim 的插件可以用 Lua 写，所以想学习一下插件开发。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;插件目录结构&#34;&gt;插件目录结构&lt;/h2&gt;
&lt;p&gt;我们的插件应当有至少两个目录：&lt;code&gt;plugin&lt;/code&gt;用于放&lt;code&gt;main&lt;/code&gt;代码文件，&lt;code&gt;lua&lt;/code&gt;放其余的所有代码。当然，如果我们真的想把所有代码放在同一个文件里面，这也是可以的。但是请不要这样。因此，使用&lt;code&gt;plugin/whid.vim&lt;/code&gt;和&lt;code&gt;lua/whid.lua&lt;/code&gt;这两个文件就可以了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-vim&#34; data-lang=&#34;vim&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#34; plugin/whid.vim 文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; exists(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;g:loaded_whid&amp;#39;&lt;/span&gt;) | finish | &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;endif&lt;/span&gt; &lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#34; 防止插件加载两次&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; s:save_cpo = &amp;amp;cpo &lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#34; 保存用户自定义选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;set&lt;/span&gt; cpo&amp;amp;vim &lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#34; 重置到默认选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#34; 运行插件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;command! Whid lua require&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;whid&amp;#39;&lt;/span&gt;.whid()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &amp;amp;cpo = s:save_cpo &lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#34; 恢复用户自定义选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;unlet s:save_cpo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; g:loaded_whid = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;let s:save_cpo = &amp;amp;cpo&lt;/code&gt;是防止自定义选项干扰插件的常见做法。依据我们要编写的代码，缺少这一行可能不会有什么坏处，但是这是一种好的习惯（至少根据 Vim 帮助文件是这样）。&lt;code&gt;command! Whid lua require &#39;whid&#39;.whid()&lt;/code&gt;需要插件的 Lua 模块并调用它的主函数。&lt;/p&gt;
&lt;h2 id=&#34;浮动窗口&#34;&gt;浮动窗口&lt;/h2&gt;
&lt;p&gt;NeoVim 和如今的新版 Vim 都有浮动窗口的特性。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- lua/whid.lua 文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; api = vim.api
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; buf, win
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; open_window()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  buf = api.nvim_create_buf(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;true&lt;/span&gt;) &lt;span style=&#34;color:#007f7f&#34;&gt;-- 创建一个空缓冲区&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  api.nvim_buf_set_option(buf, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;bufhidden&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;wipe&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;-- 获取窗口的行和列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; width = api.nvim_get_option(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;columns&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; height = api.nvim_get_option(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;lines&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;-- 计算出浮动窗口的行和列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; win_height = math.ceil(height * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.8&lt;/span&gt; - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; win_width = math.ceil(width * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.8&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;-- 计算出浮动窗口的开始位置&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; row = math.ceil((height - win_height) / &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; col = math.ceil((width - win_width) / &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;-- 设置选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; opts = {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    style = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;minimal&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    relative = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;editor&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    width = win_width,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    height = win_height,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    row = row,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    col = col
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;-- 最后在一个附加的缓冲区创建浮动窗口&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  win = api.nvim_open_win(buf, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;true&lt;/span&gt;, opts)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;nvim_create_buf&lt;/code&gt;函数用于创建一个缓冲区，第一个参数是&lt;code&gt;listed&lt;/code&gt;第二个参数是&lt;code&gt;scratch&lt;/code&gt;，分别被设置成&lt;code&gt;false&lt;/code&gt;和&lt;code&gt;true&lt;/code&gt;，创建了一个未列出的缓冲区，并且是 &lt;em&gt;throwaway&lt;/em&gt; 的（隐藏时将会被删除）。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;nvim_open_win&lt;/code&gt;可以创建一个新窗口同时也可以将之前创建的&lt;code&gt;buf&lt;/code&gt;绑定其上，第二个&lt;code&gt;bool&lt;/code&gt;类型参数表示这个窗口是否获得焦点。第三个参数&lt;code&gt;opt&lt;/code&gt;是一个表，其中元素&lt;code&gt;width&lt;/code&gt;和&lt;code&gt;height&lt;/code&gt;的作用不言自明；&lt;code&gt;row&lt;/code&gt;和&lt;code&gt;col&lt;/code&gt;是窗口的开始位置（编辑器的左上角开始算）。&lt;code&gt;relative=&amp;quot;editor&amp;quot;&lt;/code&gt;和&lt;code&gt;style=&amp;quot;minimal&amp;quot;&lt;/code&gt;是配置窗口外观的选项，这样设置可以禁用一些不需要的选项，例如行号和拼写错误提示。&lt;/p&gt;
&lt;p&gt;现在我们创建了一个浮动窗口，但是我们可以把它变得更加好看。NeoVim 当前还不支持边框等小部件，但是我们可以自己做出来。这其实相当简单，我们可以弄一个新的窗口，比原来的窗口稍微大一圈，并放置在底部。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; border_opts = {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  style = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;minimal&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  relative = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;editor&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  width = win_width + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  height = win_height + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  row = row - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  col = col - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以用边框字符让它看起来更好看。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; border_buf = api.nvim_create_buf(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;true&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; border_lines = { &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;╔&amp;#39;&lt;/span&gt; .. string.rep(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;═&amp;#39;&lt;/span&gt;, win_width) .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;╗&amp;#39;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; middle_line = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;║&amp;#39;&lt;/span&gt; .. string.rep(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;, win_width) .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;║&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; i=&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, win_height &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  table.insert(border_lines, middle_line)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;table.insert(border_lines, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;╚&amp;#39;&lt;/span&gt; .. string.rep(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;═&amp;#39;&lt;/span&gt;, win_width) .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;╝&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;api.nvim_buf_set_lines(border_buf, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, -&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;false&lt;/span&gt;, border_lines)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 函数原型为 nvim_buf_set_lines({buffer}, {start}, {end}, {strict_indexing}, {replacement})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 设置缓冲区(border_buf)填充范围为第一行(0)到最后一行(-1)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 忽略越界错误(false)并填充(border_lines)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显然我们必须按照正确的顺序打开窗口，并且一起关闭窗口。当前最好的解决办法是使用&lt;code&gt;viml autocomand&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; border_win = api.nvim_open_win(border_buf, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;true&lt;/span&gt;, border_opts)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;win = api.nvim_open_win(buf, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;true&lt;/span&gt;, opts)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;api.nvim_command(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;au BufWipeout &amp;lt;buffer&amp;gt; exe &amp;#34;silent bwipeout! &amp;#34;&amp;#39;&lt;/span&gt;..border_buf)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;获取数据&#34;&gt;获取数据&lt;/h2&gt;
&lt;p&gt;我们的插件用于展示我们处理过的最新文件。可以使用 git 命令达到这样的效果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git diff-tree --no-commit-id -name-only -r HEAD
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建函数将数据插入到窗口之中。&lt;/p&gt;
&lt;h2 id=&#34;用户输入&#34;&gt;用户输入&lt;/h2&gt;
&lt;h2 id=&#34;公共函数&#34;&gt;公共函数&lt;/h2&gt;
&lt;h2 id=&#34;完整代码&#34;&gt;完整代码&lt;/h2&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.2n.pl/blog/how-to-write-neovim-plugins-in-lua.md&#34;&gt;How to write neovim plugins in Lua&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rafcamlet/nvim-whid&#34;&gt;GitHub rafcamlet/nvim-whid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>工程师文化、工匠精神和赛博丁真</title>
      <link>https://vaaandark.top/posts/engineer-and-dingzhen/</link>
      <pubDate>Mon, 15 Aug 2022 12:27:41 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/engineer-and-dingzhen/</guid>
      <description>&lt;p&gt;最近何同学和稚晖君都发视频了，巧合的是他们做的项目都是关于键盘的魔改，不过人比人还是气死人嗷。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;何同学本质上走的还是网红甚至说是饭圈路线，并没有很硬的实力，也就导致了大部分理工科的“直男”都会看不起甚至讨厌他。&lt;/p&gt;
&lt;p&gt;而稚晖君就不一样了，他本身并不是一位专职 UP ，他有自己的本职工作，并不需要将流量变现，因此他没有大范围炒作过自己的项目，而且他的视频也不会为了更多的播放量去搞一些所谓的“人文”升华，他自有自己的目标观众。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;稚晖君GitHub&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/zhihui.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;我并不知道对何同学冠以赛博丁真的绰号是否有点过了，但我可以确定的是，多一两个能力只够做开箱视频的网红对形成工程师文化是毫无作用的。对于未来真的在工程师岗位上的观众群体来说，何同学的作用最多只是让人批判性地观看。相反地，多几位善于表达、会做出优质视频的真正“天才少年”却是非常难得的事情。&lt;/p&gt;
&lt;p&gt;刚刚说到了工程师文化，可是我们总在说它，它究竟是什么呢？我在知乎上看到了一个很好的定义：&lt;strong&gt;一切以解决问题为导向的工作文化&lt;/strong&gt;。很明显的是，这样的文化可以高质高量地解决问题，也可以提高一线人员的话语权和地位（并不要求一线人员是一位工程师）。一个优秀的一线问题解决者的工资就应该高于中层管理人员（类似于苏联早期公务员的工资不能超过熟练工人）。&lt;/p&gt;
&lt;p&gt;很明显，何同学身上不能体现工程师文化。我们并不要求工程师“讷于言”，他的确可以说得天花乱坠，但是“敏于行”却是必要的。而且，何同学对背后为他解决问题的团队所提甚少，从没有感谢他们的贡献。并且，他所做的东西根本没有解决问题，甚至是为了一个“伪需求”而制造问题。以这次的键盘为例，这么多电机的堆砌，最终的结果就是一个发热惊人的“电老虎”。如果他真的想解决问题，使用热插拔键盘就可以了。一定要做一个可变键程的键盘的话，那他就需要设计专门的控制、电源芯片等。另外说一句，我对键盘的集成度持怀疑态度，怀疑键盘的控制都在桌子下面。&lt;strong&gt;总而言之，何同学并不具有作为科技博主的解决问题能力，只有作为数码博主的测评能力。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再说说我们国家总在说的“工匠精神”。工匠精神固然是好的，但是它的内涵也要跟随时代而变化。以央视纪录片《大国工匠》为例，它总是不自觉地给人一种观点，老师傅就是好的，手工制作就是好的。这种宣传导向真的好吗？我看不一定。能熟练运用机器达到要求的师傅是好师傅吗？年轻的师傅就不是好师傅吗？制造出能代替人工的优秀机器的是好发明家吗？&lt;/p&gt;
&lt;p&gt;很多官媒讲不好故事，这可能是宣传部门与工业界脱节造成的。但受人热捧的是“小丑”讲故事，这是否和整个社会的氛围有关呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知乎问答：&lt;a href=&#34;https://www.zhihu.com/question/22168420/answer/36904920&#34;&gt;工程师文化&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>说说链表</title>
      <link>https://vaaandark.top/posts/facts-about-linklist/</link>
      <pubDate>Sun, 14 Aug 2022 16:01:24 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/facts-about-linklist/</guid>
      <description>&lt;p&gt;最近看到了一些关于侵入式和非侵入式链表的讨论，决定研究一下它们两个。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;侵入式和非侵入式链表的区别&#34;&gt;侵入式和非侵入式链表的区别&lt;/h2&gt;
&lt;p&gt;这里的侵入是相对于链表的指针域来说，所以最主要的区别就是非侵入式的链表容器中保存了一份用户传入的值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;class&lt;/span&gt; list_node {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    list_node *next, *previous;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    MyClass value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到非侵入式的链表在分配节点时要包含指针域和数据域。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;而侵入式链表就不需要保存传递对象的拷贝，而是保存对象本身。对象插入链表中的所需要的附加数据由对象本身提供。&lt;/p&gt;
&lt;p&gt;可以看 &lt;strong&gt;Linux&lt;/strong&gt; 提供的&lt;code&gt;listnode&lt;/code&gt;结构体：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; listnode {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; listnode *next, *prev;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用时，需要将一个&lt;code&gt;listnode&lt;/code&gt;结构体放入到需要组成链表的结构体中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; data {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; listnode _list;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在使用的时候，可以用一些宏来方便代码书写，尤其是在通过&lt;code&gt;listnode&lt;/code&gt;来寻找整个&lt;code&gt;data&lt;/code&gt;结构体时，就需要利用偏移量（使用&lt;code&gt;offsetof&lt;/code&gt;关键字）和指针的强制转换的宏。&lt;/p&gt;
&lt;h2 id=&#34;两种容器的优缺点&#34;&gt;两种容器的优缺点&lt;/h2&gt;
&lt;h3 id=&#34;非侵入式&#34;&gt;非侵入式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单易操作。&lt;/li&gt;
&lt;li&gt;每个节点只需要分配一次。&lt;/li&gt;
&lt;li&gt;每个节点是一个整体，所以生命周期和内存手动管理比较友好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个对象只能属于一个容器，如要共享于两个容器（例如同时放在双向链表和红黑树中），就只能拷贝这个对象或者使用指针间接访问。如果使用拷贝的方法就会降低性能。&lt;/li&gt;
&lt;li&gt;无法保留原始类型的同时将派生对象存储在STL容器中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;侵入式&#34;&gt;侵入式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不会调用内存分配，可以将动态分配的开销最小化，也在插入和擦除对象时有可预测性。&lt;/li&gt;
&lt;li&gt;使用很小的代价就可以将同一个对象插入到多个容器之中。&lt;/li&gt;
&lt;li&gt;迭代的速度很快，内存访问更少，从指针或元素引用到该元素的迭代器的计算是一个常数时间，（&lt;code&gt;std::list&amp;lt;T*&amp;gt;&lt;/code&gt;是线性复杂度）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改对象时时刻要注意是否会带来副作用。&lt;/li&gt;
&lt;li&gt;需要独立于容器管理对象的生命周期以及内存分配。&lt;/li&gt;
&lt;li&gt;因为对象可以在从容器被删除之前释放，因此迭代器容易失效。&lt;/li&gt;
&lt;li&gt;分析使用容器的程序的线程安全性更加困难，因为容器可能会在没有显式调用容器成员的情况下被间接修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;来自-boost-的对比表格&#34;&gt;来自 boost 的对比表格&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;不同容器类型的对比&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/list-differences.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.boost.org/doc/libs/1_80_0/doc/html/intrusive/intrusive_vs_nontrusive.html&#34;&gt;boost document&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OpenMP进阶</title>
      <link>https://vaaandark.top/posts/openmp-advance/</link>
      <pubDate>Tue, 02 Aug 2022 22:08:34 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/openmp-advance/</guid>
      <description>&lt;p&gt;继续学习 OpenMP 的使用，尤其是一些较新版本。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;openmp-40&#34;&gt;OpenMP 4.0&lt;/h2&gt;
&lt;h3 id=&#34;controlling-openmp-thread-affinity&#34;&gt;Controlling OpenMP thread Affinity&lt;/h3&gt;
&lt;p&gt;因为很多硬件如今是 NUMA 结构，分配线程的位置可以很大程度上影响性能。&lt;/p&gt;
&lt;p&gt;与核绑定有关的 OpenMP 结构 proc_bind (master | close | spread)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;继承串行部分的核绑定，用运行之前串行线程的核来执行所有的线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;close&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优先分配与串行线程相临近的核。当并行线程数量大于核心数量时，分配方式与 spread 相近。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;spread&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;稀疏、均匀地进行绑定。如果有 M 个线程， N 个核心，那么从串行线程运行的那个核开始分布，每个核上运行 $M/N$ 个线程。&lt;/p&gt;
&lt;h3 id=&#34;task-constructor&#34;&gt;Task constructor&lt;/h3&gt;
&lt;p&gt;OpenMP 4.0 可以指定 task 之间的依赖关系。&lt;/p&gt;
&lt;h4 id=&#34;taskwait&#34;&gt;taskwait&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; fib(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; n) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i, j;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (n &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; n;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma opm task shared(i) firstprivate(n)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        i = fib(n - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp task shared(j) firstprivate(n)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        j = fib(n - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp taskwait
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; i + j
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; n = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    opm_set_num_threads(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel shared(n)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp single
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;fib (%d) = %d&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, n, fib(n));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码中的 taskwait 指令可以保证在 return 之前要计算完成 i 和 j 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然只有一个线程会执行 fib 的调用，但是在 fib 函数之中的 task 执行是四个线程都参与的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;task-dependencies&#34;&gt;Task dependencies&lt;/h4&gt;
&lt;p&gt;对同一父级任务的调度增加额外的约束。&lt;/p&gt;
&lt;p&gt;#pragma omp task depend(type: list)&lt;/p&gt;
&lt;p&gt;type := in | out | inout&lt;/p&gt;
&lt;p&gt;类似于依赖图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Flow dependency: read - after - write(RAW)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp single
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp task shared (x) depend (out: x)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        x = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp task shared (x) depend (in: x)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;x = %d&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, x);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Anti dependency: write - after - read(WAR)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp single
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp task shared (x) depend (in: x)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        x = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp task shared (x) depend (out: x)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;x = %d&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, x);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Output dependency: write - after - write(WAW)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp single
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp task shared (x) depend (out: x)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        x = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp task shared (x) depend (out: x)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;x = %d&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, x);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码中的两个 task 可以以任意方式执行，因此可能会出现数据竞争的情况。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在矩阵中使用，利用数组分片。&lt;/p&gt;
&lt;p&gt;以下例子展示了一个基于 task 的矩阵(N * N)分块，分成 BS * BS 的分块矩阵。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// Assume BS divides N perfectly
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; matmul_depend(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; N, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; BS, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;float&lt;/span&gt; A[N][N], &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;float&lt;/span&gt; B[N][N], &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;float&lt;/span&gt; C[N][N))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i, j, k, ii, jj, kk;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt;(i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; N; i += BS)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt;(j = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; j &amp;lt; N; j += BS)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt;(k = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; k &amp;lt; N; k += BS) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp task \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;                    depend (in: A[i:BS][k:BS], B[k:BS][j:BS]) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;                    depend (inout: C[i:BS][j:BS])
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt;(ii = i; ii &amp;lt; i + BS; ii++)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt;(jj = j; jj &amp;lt; j + BS; jj++)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt;(kk = k; kk &amp;lt; k + BS; kk++)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            C[ii][jj] = C[ii][jj] + A[ii][kk] * B[kk][jj];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;taskyield-construct&#34;&gt;Taskyield construct&lt;/h3&gt;
&lt;p&gt;使当前的 task 让出，方便其他的 task 执行。一般和 while 语句搭配使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; N; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp task
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        something_useful();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt; (!omp_test_lock(lock)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp taskyield
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        something_critical();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        omp_unset_lock(lock); &lt;span style=&#34;color:#007f7f&#34;&gt;// 释放锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;taskgroup-construct&#34;&gt;Taskgroup Construct&lt;/h3&gt;
&lt;p&gt;taskwait vs. taskgroup&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;taskwait 只 join 子任务&lt;/li&gt;
&lt;li&gt;taskgroup join 所有子任务和子任务派生的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;user-define-reductions&#34;&gt;User define reductions&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp declare reduction(reduction-identifier: typename-list: combiner) [initialize-clause]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;reduction-identifier: 可以是一个用户定义的操作，也可以是 +, -, *, &amp;amp;, |, ^, &amp;amp;&amp;amp;, ||&lt;/li&gt;
&lt;li&gt;typename-list: 操作作用的变量&lt;/li&gt;
&lt;li&gt;combiner: 指定如何结合这些变量的语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;reduction&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/openmp-reduction.png&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; reduction1(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;float&lt;/span&gt; *x, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; *y, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i, b, c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;float&lt;/span&gt; a, d;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	a = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	b = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	c = y[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	d = x[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel for private(i) shared(x, y, n) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;        reduction(+:a) reduction(^:b) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;        reduction(min:c) reduction(max:d)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (i=&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        a += x[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        b ^= y[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (c &amp;gt; y[i])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            c = y[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        d = fmaxf(d,x[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;construct-cancellation&#34;&gt;Construct cancellation&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp cancel construct [if (expr)]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;constructor := parallel | sections | for | taskgroup&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; t = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel firstprivate(t)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp for
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;100&lt;/span&gt;; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t = test();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp cancel for if (t == 5)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp cancel parallel if (t == 5)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp barrier
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Thread %d&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, omp_get_thread_num());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;cancel 功能默认是关闭的，如果需要则要把环境变量 OMP_CANCELLATION 设置为 true，&lt;code&gt;$OMP_CANCELLATION=true ./test&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;simd-constructs&#34;&gt;SIMD Constructs&lt;/h3&gt;
&lt;p&gt;OpenMP 对并行和串行都有向量化支持。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp simd [clauses]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以对循环使用，指示这个循环迭代可以 SIMD 分块执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp declare simd [clauses]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;标记这个函数可以被一个 SIMD 循环调用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp for simd [clauses]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;表示循环可以分块后被线程组执行，每一块都可以 SIMD 向量化&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp declare simd
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; inc(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; i + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; d1 = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, N = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; a[N], b[N], d2 = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.0f&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp simd reduction(+: d1)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; N; ++i)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        d1 += i * inc(i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel for simd reduction(+: d2)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; N; ++i)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        d2 += a[i] * b[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;device-constructs&#34;&gt;Device Constructs&lt;/h3&gt;
&lt;p&gt;OpenMP 4.0 开始支持异构计算，可以将计算部分放到其余的 target 上完成。&lt;/p&gt;
&lt;p&gt;在 map 语句中，有两种映射类型，分别是 to 和 from，定义了 original(host) 和 target(device) 之间的数据映射&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;to: 在 device 上只读&lt;/li&gt;
&lt;li&gt;from: 在 device 上只写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过限制数据的权限，可以减少数据传输中的开销。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;target&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/openmp-target.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#pragma omp target data&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为后面的代码域创建一个 device 数据环境，它的作用只是将数据移动到 target 上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; vec_mult(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;float&lt;/span&gt; *p, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;float&lt;/span&gt; *v1, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;float&lt;/span&gt; *v2, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; N)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp target data map(to: v1[0:N], v2[0:N]) map(from: p[0:N])
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp target
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel for
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; N; ++i)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            p[i] = v1[i] * v2[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    output(p, N);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;target&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/openmp-target-data-map.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#pragma omp target&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建一个 device 数据环境，并在这个 target 上执行之后结构中的语句。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#pragma omp target update&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 target 域中更新数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp target update to(v1[:N], v2[:N]) &lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// 将新值分配给 target 环境
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#pragma omp declare target&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指示变量或者函数被映射到了 device 上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp declare target
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; fib(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; N);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp end declare target
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define THRESHOLD 1000000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; fib_wrapper(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp target if (n &amp;gt; THRESHOLD)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        fib(n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;openmp-45&#34;&gt;OpenMP 4.5&lt;/h2&gt;
&lt;h3 id=&#34;parallelism--workshare-for-devices&#34;&gt;Parallelism &amp;amp; Workshare for devices&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;omp teams [clause[[,] clause], &amp;hellip;] newline structured-block&lt;/li&gt;
&lt;li&gt;omp distribute [clause[[,] clause], &amp;hellip;] newline for-loops&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;openmp-50&#34;&gt;OpenMP 5.0&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>OpenMP入门</title>
      <link>https://vaaandark.top/posts/openmp-introduction/</link>
      <pubDate>Fri, 29 Jul 2022 09:03:18 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/openmp-introduction/</guid>
      <description>&lt;p&gt;写 OpenMP 的时候总是感觉怪怪的，不知道什么时候该用什么，所以最近系统化地看一遍 OpenMP 的使用，主体为 OpenMP 2.0 和 3.0。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;what-is-openmp&#34;&gt;What is OpenMP?&lt;/h2&gt;
&lt;h3 id=&#34;openmp-model&#34;&gt;OpenMP Model&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每个线程都有可以访问全局的共享内存。&lt;/li&gt;
&lt;li&gt;数据可以是共享的也可以是私有的。&lt;/li&gt;
&lt;li&gt;共享的数据可以被所有线程访问。&lt;/li&gt;
&lt;li&gt;私有数据只能被拥有它的线程访问。&lt;/li&gt;
&lt;li&gt;数据的传递对于编程者是透明的。&lt;/li&gt;
&lt;li&gt;同步会发生，但是它大部分时候是隐式的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;OpenMP Model&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/openmp-model.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;data-sharing-attributes&#34;&gt;Data-Sharing Attributes&lt;/h3&gt;
&lt;p&gt;在一个 OpenMP 程序中，数据需要被打上标签，有两种基本类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享的
&lt;ul&gt;
&lt;li&gt;只有一个数据的实例&lt;/li&gt;
&lt;li&gt;所有的线程都可以同步地读或者写，除非有特定的 OpenMP 结构保护它&lt;/li&gt;
&lt;li&gt;所有数据变化都对所有线程可见&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;但是除非强制，并不需要变化立即可见&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;私有的
&lt;ul&gt;
&lt;li&gt;每一个线程持有一份数据的拷贝&lt;/li&gt;
&lt;li&gt;其他线程无权访问该数据&lt;/li&gt;
&lt;li&gt;数据变化只对拥有者线程可见&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;其余的一些类型也是基于以上变化而来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;the-openmp-execution-model&#34;&gt;The OpenMP Execution Model&lt;/h3&gt;
&lt;p&gt;OpenMP 程序执行模型被称为 Fork and Join Model，在不需要并行执行时只有一个主线程，在需要并行时 Fork 出多个 Worker 线程，在经历了同步之后 Join 到一个主线程。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Fork and Join&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/openmp-fork-and-join-model.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;how-to-use-openmp&#34;&gt;How to use OpenMP?&lt;/h2&gt;
&lt;h3 id=&#34;a-first-openmp-example&#34;&gt;A first OpenMP example&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;omp.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;# pragma omp parallel for num_threads(4)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;20&lt;/span&gt;; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Hello from thread %d of %d&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			omp_get_thread_num(), \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			omp_get_num_threads());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gcc -o for for.c -fopenmp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./for
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果不指定线程数，就会默认使用 CPU 实际能同时运行的个数，在我的 8 核 16 线程的电脑上就是 16 个线程。&lt;/p&gt;
&lt;h3 id=&#34;matrix-example&#34;&gt;Matrix example&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;# pragma omp parallel for default(none) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;    private(i, j, sum) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;    shared(m, n, a, b, c)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; m; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sum = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.0f&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (j = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; j &amp;lt; n; ++j) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum += b[i][j] * c[j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a[i] = sum;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;以 #pragma 开头的语句要写在同一行（类似宏）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;a-more-elaborate-example&#34;&gt;A more elaborate example&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;# pragma omp parallel if (n&amp;gt;limit) default(none) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;    shared(n, a, b, c, x, y, z) private(f, i, scale)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// 使用 if 语句来避免因为矩阵过小导致的并行衰退
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    f = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1.0f&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;# pragma omp for nowait
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// nowait 每个线程完成自己的工作后不等待其他线程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// 而是直接执行后面的代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; n; ++i)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        z[i] = x[i] + y[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;# pragma omp for nowait
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; n; ++i)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        a[i] = b[i] + c[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;# pragma omp barrier
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// 在此处显示说明要同步
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    scale = sum(a, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, n) + sum(z, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) + f;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;openmp-in-some-more-detail&#34;&gt;OpenMp in Some More Detail&lt;/h2&gt;
&lt;h3 id=&#34;terminology-and-behavior&#34;&gt;Terminology and behavior&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OpenMP Team := Master + Worker&lt;/li&gt;
&lt;li&gt;并行域(Parallel Region)是所有线程同步执行的代码块
&lt;ul&gt;
&lt;li&gt;主线程 ID 永远是 0&lt;/li&gt;
&lt;li&gt;线程调整（如果有的话）都只会在进入并行域之后完成&lt;/li&gt;
&lt;li&gt;并行域是可以嵌套的&lt;/li&gt;
&lt;li&gt;if 语句可以用于并行域，如果为假则会串行执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有一个 work-sharing 结构(例如 Single, Sections 等)在分配任务给 team 中的成员&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;the-if--private--shared-clauses&#34;&gt;The if / private / shared clauses&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if (scalar expression)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;private(list)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;firstprivate(list)&lt;/code&gt; 在第一个循环继承共享变量的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lastprivate(list)&lt;/code&gt; 根据逻辑上的最后一个线程给共享变量赋值（不是实际运行完的最后一个线程，对于 for 循环就是最后一次迭代的值）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shared(list)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;the-nowait-clause&#34;&gt;The nowait clause&lt;/h3&gt;
&lt;p&gt;为了最小化同步带来的损失，可以使用 nowait 。如果出现了 nowait ，线程将在特定代码块之后不同步或者等待。&lt;/p&gt;
&lt;h3 id=&#34;the-sections-directive&#34;&gt;The sections directive&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel default(none) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;    shared(n,a,b,c,d) private(i)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp sections nowait
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// 下面两个 section 是并行的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp section
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; n - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; ++i)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            b[i] = (a[i] + a[i + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;] / &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp section
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; n; ++i)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            d[i] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1.0f&lt;/span&gt; / c[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#007f7f&#34;&gt;/*-- End of sections --*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#007f7f&#34;&gt;/*-- End of parallel region --*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;single-processor-region&#34;&gt;Single processor region&lt;/h3&gt;
&lt;p&gt;这种结构作 I/O 或者初始化非常理想。&lt;/p&gt;
&lt;p&gt;例如在一个并行域中需要进行 IO 操作，这时可以在读取后放一个 barrier ，但是根据 Amdahl 定理，这会成为拓展这段代码时的瓶颈。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;bottleneck&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/openmp-single.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时可以使用 single 或者 master 将任务只分配给一个线程，其中 master 只会分配给 master 线程。如此一来，无论是在入口还是出口都没有使用 barrier 。&lt;/p&gt;
&lt;h3 id=&#34;critical-region&#34;&gt;Critical Region&lt;/h3&gt;
&lt;p&gt;在如下代码块中，如果 sum 是一个共享变量，那么就可能在并行中发生数据竞争的问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; N; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    sum += a[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以使用 critical region ，在同一时间段内只会有一个线程执行该语句。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp critical [(name)]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;critical region&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/openmp-critical-region.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;有的时候也可以使用 Atomic ，但是要注意 Atomic 只是原子地载入和存储，它们并不完全等效。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;能用 Atomic 时尽量使用 Atomic ，因为其更加轻量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp atomic [(name)]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;openmp-30-supports-for-tasks&#34;&gt;OpenMP 3.0 supports for TASKS&lt;/h2&gt;
&lt;p&gt;在 3.0 版本中，OpenMP 增加了对 task 的支持，更多的东西可以并行化了。&lt;/p&gt;
&lt;h3 id=&#34;a-linked-list-example&#34;&gt;A Linked List Example&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt;(my_pointer) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;)do_independent_work(my_pointer);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    my_pointer = my_pointer-&amp;gt;next ;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#007f7f&#34;&gt;// End of while loop
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码在 OpenMP 2.0 中想要并行化会较为困难，但是在 3.0 增加了对 task 的支持之后便容易了许多。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp parallel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp single nowait
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt; (my_pointer) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#pragma omp task firstprivate(my_pointer)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#007f7f&#34;&gt;// task 在此处并行执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;            {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;)do_independent_work(my_pointer)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            my_pointer = my_pointer-&amp;gt;next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#007f7f&#34;&gt;// End of single - no implied barrier (nowait)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;} &lt;span style=&#34;color:#007f7f&#34;&gt;// End of parallel region - implied barrier
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.openmp.org/resources/tutorials-articles/&#34;&gt;OpenMP Tutorials&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.openmp.org/wp-content/uploads/ntu-vanderpas.pdf&#34;&gt;An Overview of OpenMP - Ruud van der Pas - Sun Microsystems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.openmp.org/wp-content/uploads/Intro_To_OpenMP_Mattson.pdf&#34;&gt;Tim Matton&amp;rsquo;s &amp;ldquo;Introduction fo OpenMP&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>七月随笔</title>
      <link>https://vaaandark.top/posts/essay-in-july/</link>
      <pubDate>Thu, 28 Jul 2022 21:47:18 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/essay-in-july/</guid>
      <description>&lt;p&gt;突然发现自己从高二以来基本没有读过“闲书”，意识到这可能正是现在诸多烦恼的原因之一吧……&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;其实从初中以来，我所阅读书籍的文学性都是在下降的，我看过的大部分文学名著都是在初中及之前看的，在之后就是科幻和一些功能性的书了，再就是各种评论性的文章，抑或是看不懂也要看的哲学或者诗歌。&lt;/p&gt;
&lt;p&gt;以散文为例，在高中就买了的一些我较为喜欢作家的文集被我带到了华科，但到现在都还只翻动了几页。而高中语文老师送给我的《月亮与六便士》、《罗生门》也被我连带着包装平移到了宿舍吃灰。&lt;/p&gt;
&lt;p&gt;作为一个“中土”迷，我的《精灵宝钻》也是尚未拆封，也没有再花时间重温电影。联想到最近在看的《哈利波特》，也是被我囫囵吞枣般看了三部，期间夹杂着快放以及xx讲电影的剧透。&lt;/p&gt;
&lt;p&gt;我好像失去了欣赏文学艺术的能力，以前那个把小学同学书都看完了的我好像不见了，取而代之的是一个阅读只注重效果的工具、一个时时刻刻想看“锐评”或者发表“锐评”的“大评论家”“大阴阳师”、一个只想“开天眼”到结局的“快餐食客”。我的短视、暴戾、尖酸刻薄、无知和浅薄好像就派生于此。&lt;/p&gt;
&lt;p&gt;希望能少看一些看似能涨知识的视频，多看点书吧，就从这几本开始吧……&lt;/p&gt;
&lt;p&gt;在这之后打算去读读一直想读的卡尔维诺、卡夫卡。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;书&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/essay-2022-07-28.jpg&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lua Coroutine</title>
      <link>https://vaaandark.top/posts/lua-coroutine/</link>
      <pubDate>Fri, 13 May 2022 15:19:09 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/lua-coroutine/</guid>
      <description>&lt;p&gt;Lua 的一大特色就是协程的使用，在解释型语言中，如果不考虑嵌入到较为低级的语言（如 C 语言）中，就只需要操作调用栈并保存好上下文状态即可。但是 Lua 并不是一门纯粹依靠字节码的解释型语言，它常常与 C 语言反复嵌套，甚至出现 C 中调用 Lua ，Lua 中再调用 C 代码，，，的情况。一旦 Lua 调用的 C 库企图中断线程，再想恢复，就会是一个难题。好在 Lua 巧妙地解决了这些问题。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;lua-虚拟机重要结构体&#34;&gt;Lua 虚拟机重要结构体&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;global_State&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;global_State 由所有线程共享，其中包含字符串内部化保存的哈希表、垃圾回收、异常处理等信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lua_State&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;lua_State 表示一个 Lua 线程的执行状态，它有着自己独立的数据栈和函数调用栈。每个 lua_State 都有一个指向 global_State 的指针。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;** &amp;#39;per thread&amp;#39; state
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; lua_State {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  CommonHeader;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lu_byte status;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lu_byte allowhook;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;short&lt;/span&gt; nci;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* number of items in &amp;#39;ci&amp;#39; list */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  StkId top;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* first free slot in the stack */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  global_State *l_G;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  CallInfo *ci;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* call info for current function */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  StkId stack_last;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* end of stack (last element + 1) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  StkId stack;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* stack base */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  UpVal *openupval;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* list of open upvalues in this stack */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  StkId tbclist;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* list of to-be-closed variables */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  GCObject *gclist;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; lua_State *twups;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* list of threads with open upvalues */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; lua_longjmp *errorJmp;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* current error recover point */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  CallInfo base_ci;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* CallInfo for first level (C calling Lua) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;volatile&lt;/span&gt; lua_Hook hook;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;ptrdiff_t&lt;/span&gt; errfunc;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* current error handling function (stack index) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  l_uint32 nCcalls;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* number of nested (non-yieldable | C)  calls */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; oldpc;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* last pc traced */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; basehookcount;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; hookcount;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;volatile&lt;/span&gt; l_signalT hookmask;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;数据栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对数据栈初始化和释放分别调用 stack_init 和 free_stack 函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; stack_init (lua_State *L1, lua_State *L);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; freestack (lua_State *L);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;数据栈初始大小是 Lua 内置栈结构的两倍，随着数据的增多需要调用 growstack 进行栈的扩展。因为有些数据包含了对栈中元素的引用，在栈中元素移位之后，在扩展之中要对栈进行修正。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; correctstack (lua_State *L, StkId oldstack, StkId newstack);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; luaD_reallocstack (lua_State *L, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; newsize, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; raiseerror);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; luaD_growstack (lua_State *L, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; raiseerror);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过源代码中的注释可以很清晰知晓这些函数的作用，再结合源码，可以发现这三个函数的调用关系为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;luaD_growstack ---&amp;gt; luaD_reallocstack ---&amp;gt; correctstack
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;调用栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数调用栈使用的是一个双向链表结构体 CallInfo ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; CallInfo {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  StkId func;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* function index in the stack */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  StkId	top;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* top for this function */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; CallInfo *previous, *next;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* dynamic call link */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;union&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* only for Lua functions */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; Instruction *savedpc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;volatile&lt;/span&gt; l_signalT trap;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; nextraargs;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* # of extra arguments in vararg functions */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } l;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* only for C functions */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      lua_KFunction k;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* continuation in case of yields */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;ptrdiff_t&lt;/span&gt; old_errfunc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      lua_KContext ctx;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* context info. in case of yields */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } u;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;union&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  } u2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;short&lt;/span&gt; nresults;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* expected number of results from this function */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;short&lt;/span&gt; callstatus;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} CallInfo;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在联合体 u 中：字段 l 用于调用 Lua 函数，字段 c 用于调用 C 函数，callstatus 用于标志是 Lua 函数还是 c 函数；联合体 u2 和保护模式、钩子函数等有关，暂不考虑。&lt;/p&gt;
&lt;p&gt;需要注意到的是，既有 func 又有 base 的原因是，Lua 传入一个函数的参数个数可能不定，通过函数位置和栈底位置相减可以计算出参数个数。&lt;/p&gt;
&lt;h2 id=&#34;lua-线程&#34;&gt;Lua 线程&lt;/h2&gt;
&lt;h3 id=&#34;创建线程&#34;&gt;创建线程&lt;/h3&gt;
&lt;p&gt;在 Lua 中也有线程的概念，但它并不是系统线程，而且由于所有的 lua_State 都共享了 global_State ，因此多线程操作较难。在 Lua 中，协程才是最强大的武器。&lt;/p&gt;
&lt;p&gt;Lua 给 C/C++ 保留了很多 API ，其中关于创建线程的 API 很有意思：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LUA_API lua_State *lua_newthread (lua_State *L) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* create new thread */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  L1 = &amp;amp;cast(LX *, luaM_newobject(L, LUA_TTHREAD, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(LX)))-&amp;gt;l;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;//...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建线程结构体时分配空间的大小不是 Lua_State 的大小，而是 LX 的大小，而且将 Lua_State 放在了 LX 所在内存的后一部分，这既是给自定义 Lua 代码留下了空间，也是为了防止向用户暴露 Lua_State 的大小。&lt;/p&gt;
&lt;p&gt;举个例子，在多线程操作中，访问 lua_State 结构中注册表是线程不安全的，但是如果你将一些信息放在 lua_State 的前面，就可以既方便访问又在数据竞争中保持安全（不够这也增加了代码的复杂度）。&lt;/p&gt;
&lt;h3 id=&#34;线程中断及异常处理&#34;&gt;线程中断及异常处理&lt;/h3&gt;
&lt;p&gt;Lua 全部源码都由标准 C 写成而且只使用了标准库，因此它的线程中断和错误处理都使用的是标准库中的 setjmp.h 来实现的。&lt;/p&gt;
&lt;h4 id=&#34;异常&#34;&gt;异常&lt;/h4&gt;
&lt;p&gt;我在之前的一篇博文中讲到过 C语言接口与实现 中实现 C 语言异常处理的方法，也是通过 setjmp.h 来实现的。而 Lua 源码更进一步，通过宏定义将异常处理和 C++ 中的原生异常处理 try/catch 联系起来，也方便了开发者使用 C++ 开发 Lua 程序。&lt;/p&gt;
&lt;p&gt;Lua 中的异常是一个单向链表（链栈），它的行为也很好理解：出现异常，将异常串到链表上并抛出，在处理完后再使用 longjmp 跳回来。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;/* chain list of long jump buffers */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; lua_longjmp {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; lua_longjmp *previous;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  luai_jmpbuf b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; status;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* error code */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;函数&#34;&gt;函数&lt;/h4&gt;
&lt;p&gt;Lua 的函数调用过程分为 precall 和 poscall 两个部分：对于 C 语言函数来说，precall 调用了它；而对于 Lua 函数来说，precall 是为了它的调用做准备，只是改变了 Lua 虚拟机（lua_State）的状态而已，并没有真正调用。poscall 处理了它的返回，对数据栈进行了调整。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CallInfo *luaD_precall (lua_State *L, StkId func, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; nresults) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; retry:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;switch&lt;/span&gt; (ttypetag(s2v(func))) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;case&lt;/span&gt; LUA_VCCL:  &lt;span style=&#34;color:#007f7f&#34;&gt;/* C closure */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	  &lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;case&lt;/span&gt; LUA_VLCF:  &lt;span style=&#34;color:#007f7f&#34;&gt;/* light C function */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	  &lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;case&lt;/span&gt; LUA_VLCL: {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* Lua function */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;default&lt;/span&gt;: {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* not a function */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      func = luaD_tryfuncTM(L, func);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* try to get &amp;#39;__call&amp;#39; metamethod */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#007f7f&#34;&gt;/* return luaD_precall(L, func, nresults); */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;goto&lt;/span&gt; retry;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* try again with metamethod */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; luaD_poscall (lua_State *L, CallInfo *ci, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; nres);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;StkId luaD_tryfuncTM (lua_State *L, StkId func);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 precall 里面 switch/case 中的 default 分支，里面调用了 luaD_tryfuncTM 函数，这涉及了 Lua 中的元表（Meta Table），简单来说就是，当在表中找不到元素时就会尝试在表对应的元表中寻找。Lua 就是利用元表实现了类似于 Java 中的接口、C++ 中的虚函数、Rust 中的 Trait，以及重载运算符等操作。&lt;/p&gt;
&lt;p&gt;当我们使用 C 语言开发并将 Lua 代码嵌入其中时，可以使用 API luaD_call ，它是 ccall 的一个包装。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; luaD_call (lua_State *L, StkId func, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; nResults) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ccall(L, func, nResults, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;l_sinline &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; ccall (lua_State *L, StkId func, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; nResults, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; inc) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  CallInfo *ci;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  L-&amp;gt;nCcalls += inc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (l_unlikely(getCcalls(L) &amp;gt;= LUAI_MAXCCALLS))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    luaE_checkcstack(L);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; ((ci = luaD_precall(L, func, nResults)) != &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;NULL&lt;/span&gt;) {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* Lua function? */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ci-&amp;gt;callstatus = CIST_FRESH;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* mark that it is a &amp;#34;fresh&amp;#34; execute */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    luaV_execute(L, ci);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* call it */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  L-&amp;gt;nCcalls -= inc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参数 inc 代表的是在 C 函数栈中递归函数的个数，而 lua_State 实例 L 中的 nCcalls 代表的是在调用过程中被中断后就不能恢复的 C 函数（non-yielded，在老版本中名字叫做 nny)。&lt;/p&gt;
&lt;h4 id=&#34;从中断中恢复&#34;&gt;从中断中恢复&lt;/h4&gt;
&lt;p&gt;终于到了如何解决从中断中恢复这个问题了。Lua 给出的解决方案其实也不难，就是让编写 C 程序的开发者辛苦一点而已，也就是让他们自己提供一个延续函数 k 。&lt;/p&gt;
&lt;p&gt;我们可以回顾一下 CallInfo 结构体中的 c 字段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* only for C functions */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lua_KFunction k;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* continuation in case of yields */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;ptrdiff_t&lt;/span&gt; old_errfunc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lua_KContext ctx;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* context info. in case of yields */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;k 就是延续函数，而 ctx 就保存有 yield 时的上下文。&lt;/p&gt;
&lt;p&gt;在使用 k 时，只需要把它当作回调函数，将它和虚拟机实例 L 一起传入 API lua_callk 中即可。&lt;/p&gt;
&lt;p&gt;在 C 线程需要挂起时就要调用 lua_yieldk 来保存恢复时需要的上下文等信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LUA_API &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; lua_yieldk (lua_State *L, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; nresults, lua_KContext ctx, lua_KFunction k);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 lua_yieldk 中保存信息前要进行 lua_lock(L)，之后要 lua_unlock(L) 释放锁，但是在源码中 这两个宏都是不完整的，都被拓展为&lt;code&gt;(void (0))&lt;/code&gt;，在需要同步的时候要注意对它们进行补充。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lua 协程让出时也需要调用 lua_yieldk ，这放在协程部分讨论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在恢复时 Lua 内部调用的函数是 resume 函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; resume (lua_State *L, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; *ud) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (isLua(ci)) {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* yielded inside a hook? */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    L-&amp;gt;top = firstArg;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* discard arguments */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    luaV_execute(L, ci);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* just continue running Lua code */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* &amp;#39;common&amp;#39; yield */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (ci-&amp;gt;u.c.k != &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;NULL&lt;/span&gt;) {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* does it have a continuation function? */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      lua_unlock(L);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      n = (*ci-&amp;gt;u.c.k)(L, LUA_YIELD, ci-&amp;gt;u.c.ctx); &lt;span style=&#34;color:#007f7f&#34;&gt;/* call continuation */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      lua_lock(L);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      api_checknelems(L, n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    luaD_poscall(L, ci, n);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* finish &amp;#39;luaD_call&amp;#39; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  unroll(L, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;NULL&lt;/span&gt;);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* run continuation */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到如果是要恢复一个 Lua 函数就直接继续执行就可以了，如果是一个 C 函数则需要调用延续函数，再使用 poscall 处理返回值。&lt;/p&gt;
&lt;p&gt;与 resume 相关的 API 有 lua_resume，只是对 resume 的包装而已，较为简单。&lt;/p&gt;
&lt;h2 id=&#34;lua-协程&#34;&gt;Lua 协程&lt;/h2&gt;
&lt;p&gt;讨论完了上面的线程问题，现在需要讲的协程就是小菜一碟了。Lua 的协程实际上就是 Lua 线程间的切换（而非系统线程，故性能损失较少），需要考虑的只有错误信息的 move 以及新切换到的线程的 resume 问题，而 resume 的实现在前文已经讨论过了。&lt;/p&gt;
&lt;h3 id=&#34;协程的创建&#34;&gt;协程的创建&lt;/h3&gt;
&lt;p&gt;对应 Lua 语句： &lt;code&gt;lua coroutine.create()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于 Lua 协程是不对称的，故创建协程时有一个参数会是创建协程的协程 L ，并从 L 中 move 函数信息到新创建的 NL 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; luaB_cocreate (lua_State *L) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lua_State *NL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  luaL_checktype(L, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, LUA_TFUNCTION);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NL = lua_newthread(L);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lua_pushvalue(L, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* move function to top */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lua_xmove(L, NL, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* move function from L to NL */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;luaB_cowrap 是对函数 luaB_coreate 的一层封装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; luaB_cowrap (lua_State *L) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  luaB_cocreate(L);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lua_pushcclosure(L, luaB_auxwrap, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;协程的让出&#34;&gt;协程的让出&lt;/h3&gt;
&lt;p&gt;对应 Lua 语句： &lt;code&gt;lua coroutine.yield()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define lua_yield(L,n)		lua_yieldk(L, (n), 0, NULL)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; luaB_yield (lua_State *L) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; lua_yield(L, lua_gettop(L));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;协程的恢复&#34;&gt;协程的恢复&lt;/h3&gt;
&lt;p&gt;对应 Lua 语句：&lt;code&gt;lua coroutine.resume()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动协程和协程的恢复类似，都离不开以下两个函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; luaB_coresume (lua_State *L);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; auxresume (lua_State *L, lua_State *co, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; narg);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数调用链如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;luaB_coresume ---&amp;gt; auxresume ---&amp;gt; lua_resume(API) ---&amp;gt; resume
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Lua 的异常处理和线程机制为了和 C 语言互相嵌入经过了反复的权衡，代码的复杂度较大，最后使用延续函数的设计其实只能算是一个妥协的结果，但是这其中的设计还是很值得我们去学习。&lt;/p&gt;
&lt;p&gt;但 Lua 的协程库的代码非常之短小，总共两百行出头，而核心部分只有接近百行，原因之一就是它只需要调用 ldo.h 中提供的 API ，线程中断和恢复部分的代码已经给协程实现打下了良好的基础。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/lua/lua&#34;&gt;Lua 5.4.4 源码&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://lua-users.org/wiki/LuaDirectory&#34;&gt;Lua-Users-Wiki&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.codingnow.com&#34;&gt;云风的 BLOG&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://vaaandark.top/2022/05/03/C%E8%AF%AD%E8%A8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/&#34;&gt;vaaandark&amp;rsquo;s blog&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://poga.github.io/lua53-notes/coroutine.html&#34;&gt;Notes on the Implementation of Lua 5.3&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Lua Table</title>
      <link>https://vaaandark.top/posts/lua-table/</link>
      <pubDate>Wed, 11 May 2022 23:49:28 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/lua-table/</guid>
      <description>&lt;p&gt;之前学习 Lua 的时候就对它的 Table 很感兴趣，最近在看 Lua 解释器的源码，因此就想研究一下具体是怎么实现这个 Lua 之中最为重要的数据结构的。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;lua-table-简介&#34;&gt;Lua Table 简介&lt;/h2&gt;
&lt;p&gt;在 Lua 语言之中，数组是 table ，字典是 table ，就连对象、模块、包也是通过 table 实现的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数组是键值为正整数的表；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于键值也可以是其他类型，故表也可以实现字典这种数据结构；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于函数也是 Lua 的第一公民，所以成员函数也可以通过表来实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块和包之间的从属关系也是通过 table 来表示的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lua 中的 table 使用十分广泛，这也导致了 Lua 使用起来有着 &lt;del&gt;纯真的、野性的&lt;/del&gt; 简洁的美。&lt;/p&gt;
&lt;p&gt;这种数组和字典杂糅的数据结构有是如何实现的呢？这种数据结构又是否高效呢？我们将会在下文进行探究。&lt;/p&gt;
&lt;h2 id=&#34;lua-解释器中的哈希函数&#34;&gt;Lua 解释器中的哈希函数&lt;/h2&gt;
&lt;p&gt;传入参数中的 seed 是通过 lua_newstate 函数地址、lua_State 实例的地址和当前时间共同计算得到的，因此具有较强的随机性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; luaS_hash (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *str, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;size_t&lt;/span&gt; l, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; seed) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; h = seed ^ cast_uint(l);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (; l &amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; l--)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    h ^= ((h&amp;lt;&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;) + (h&amp;gt;&amp;gt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;) + cast_byte(str[l - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;]));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; h;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在老版本的 Lua 中 luaS_hash 函数比现在的复杂，是因为新版中只对短字符串使用该函数，而老版本对所有字符串都使用该函数，为了保证求哈希时的效率，所以对字符串大于 32 字节的部分进行跳过至少一个字节的哈希运算（注意 step 变量）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; luaS_hash(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; lua_State* L, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt;* str, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; l, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; h) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    h = h ^ l;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; step = (l &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;) + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; l; i = i + step) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        h ^= (h &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;) + (h &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;) + cast(lu_byte, str[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; h;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过 hash 值来得到索引的方法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;index = hash_value &amp;amp; ((&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1U&lt;/span&gt; &amp;lt;&amp;lt; lsizenode) - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 lsizenode 是 node 长度关于 2 的对数，这种方法类似于取模。&lt;/p&gt;
&lt;h2 id=&#34;lua-解释器中的重要类型&#34;&gt;Lua 解释器中的重要类型&lt;/h2&gt;
&lt;p&gt;联合体 Value 能表示 Lua 所有的基本数据结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;** Union of all Lua values
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;union&lt;/span&gt; Value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; GCObject *gc;    &lt;span style=&#34;color:#007f7f&#34;&gt;/* collectable objects */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; *p;         &lt;span style=&#34;color:#007f7f&#34;&gt;/* light userdata */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lua_CFunction f; &lt;span style=&#34;color:#007f7f&#34;&gt;/* light C functions */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lua_Integer i;   &lt;span style=&#34;color:#007f7f&#34;&gt;/* integer numbers */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lua_Number n;    &lt;span style=&#34;color:#007f7f&#34;&gt;/* float numbers */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} Value;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结构体 TValuefields 的两个字段分别表示 value 和 value 的类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define TValuefields	Value value_; lu_byte tt_
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; TValue {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  TValuefields;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} TValue;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;TValue 长度为 12 个字节，可以使用 NaN Trick 节约空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;联合体 Node 有两个字段，一个是结构体 NodeKey 依次包含了这个节点的值、键的类型、下一个节点的位置、键的值与类型，另一个字段是 TValue 类型的 i_val ，因为是联合体，所以可以通过直接访问 i_val 得到值的类型和类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;union&lt;/span&gt; Node {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; NodeKey {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TValuefields;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* fields for value */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    lu_byte key_tt;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* key type */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; next;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* for chaining */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Value key_val;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* key value */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } u;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  TValue i_val;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* direct access to node&amp;#39;s value as a proper &amp;#39;TValue&amp;#39; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} Node;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结构体 Table 中 CommonHeader 和 GCObject 与垃圾回收有关，metatable 和元表有关，flags 和元方法有关，都暂时不考虑。lsizenode 是哈希部分长度关于 2 的对数，alimit 是数组部分的长度的下限（不一定是真实大小，是一个估计），array 和 node 分别指向数组部分和哈希部分，lastfree 指向哈希部分存在空槽的末尾位置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; Table {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  CommonHeader;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lu_byte flags;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* 1&amp;lt;&amp;lt;p means tagmethod(p) is not present */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lu_byte lsizenode;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* log2 of size of &amp;#39;node&amp;#39; array */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; alimit;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* &amp;#34;limit&amp;#34; of &amp;#39;array&amp;#39; array */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  TValue *array;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* array part */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Node *node;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Node *lastfree;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* any free position is before this position */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; Table *metatable;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  GCObject *gclist;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} Table;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;table-相关操作&#34;&gt;Table 相关操作&lt;/h2&gt;
&lt;p&gt;前面已经说到了 Lua 中的 Table 是一个既包含数组部分又包含哈希部分的数据结构，也对 Lua 源码中关于 Table 的类型进行了探究，现在就可以对 Table 的相关操作进行讨论。&lt;/p&gt;
&lt;p&gt;在讨论之前有一些前置知识需要了解：首先就是 Lua 的哈希部分应对哈希冲突使用的是链接法，但是它不会单独拉出链表来，依然是一个 Node 数组的形式。它所有的节点都在 Node 数组之中，通过 next 字段串起来，这就导致 Lua 哈希表对内存的利用十分紧凑。&lt;/p&gt;
&lt;p&gt;在源码中，作者将键值通过哈希计算直接得到的位置叫做 mainpostion ，下文中称之为主位置。&lt;/p&gt;
&lt;h3 id=&#34;初始化操作&#34;&gt;初始化操作&lt;/h3&gt;
&lt;p&gt;初始化 Table 较为简单，基本上就是给字段赋值为 0 或者 NULL，但需注意 node 字段并不初始化为 NULL 而是初始化为一个全局变量 dummynode ，这种做法可以减少很多次判空操作。&lt;/p&gt;
&lt;h3 id=&#34;get-操作&#34;&gt;get 操作&lt;/h3&gt;
&lt;p&gt;当 key 为一个整数 i_key 时，首先判断 i_key 与 alimit 的关系，如果小于 alimit 说明在数组部分，直接返回下标位置的值；如果大于 alimit 但 alimit 并不是真实的数组大小，就先更新 alimit 再返回下标位置；上述条件都不满足，说明在哈希部分，并在哈希部分查找。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; TValue *luaH_getint (Table *t, lua_Integer key) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (l_castS2U(key) - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1u&lt;/span&gt; &amp;lt; t-&amp;gt;alimit)  &lt;span style=&#34;color:#007f7f&#34;&gt;/* &amp;#39;key&amp;#39; in [1, t-&amp;gt;alimit]? */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;amp;t-&amp;gt;array[key - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (!limitequalsasize(t) &amp;amp;&amp;amp;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* key still may be in the array part? */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           (l_castS2U(key) == t-&amp;gt;alimit + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; ||
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            l_castS2U(key) - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1u&lt;/span&gt; &amp;lt; luaH_realasize(t))) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    t-&amp;gt;alimit = cast_uint(key);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* probably &amp;#39;#t&amp;#39; is here now */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;amp;t-&amp;gt;array[key - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Node *n = hashint(t, key);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (;;) {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* check whether &amp;#39;key&amp;#39; is somewhere in the chain */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (keyisinteger(n) &amp;amp;&amp;amp; keyival(n) == key)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; gval(n);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* that&amp;#39;s it */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; nx = gnext(n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (nx == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        n += nx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &amp;amp;absentkey;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果 key 不是一个整数，处理方法就较为简单，直接去哈希部分寻找。&lt;/p&gt;
&lt;h3 id=&#34;set-操作&#34;&gt;set 操作&lt;/h3&gt;
&lt;p&gt;首先介绍插入键值为一个整数时的情况，此时调用函数 luaH_setint 。插入键值时，先通过上文介绍过的函数 luaH_getint 在 Table 中进行查找，如果不为空则直接 set ，为空则调用函数 luaH_newkey ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; luaH_setint (lua_State *L, Table *t, lua_Integer key, TValue *value) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; TValue *p = luaH_getint(t, key);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (isabstkey(p)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TValue k;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    setivalue(&amp;amp;k, key);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    luaH_newkey(L, t, &amp;amp;k, value);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    setobj2t(L, cast(TValue *, p), value);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;luaH_newkey 是一个很重要的函数，它的主要逻辑和函数原型如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;** inserts a new key into a hash table; first, check whether key&amp;#39;s main
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;** position is free. If not, check whether colliding node is in its main
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;** position or not: if it is not, move colliding node to an empty place and
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;** put new key in its main position; otherwise (colliding node is in its main
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;** position), new key goes to an empty position.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; luaH_newkey (lua_State *L, Table *t, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; TValue *key, TValue *value);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;插入一个键值到哈希表中时，首先检查这个键值对应的主位置是不是空的。如果不是空的，就检查那个冲突节点是不是在它自身的主位置上：如果不是，那就调整这个冲突节点到空位置然后将待插入节点放入腾出来的位置；否则（冲突节点在自己的主位置），待插入键值就要去空位置了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冲突节点在自己主位置的情况：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;插入键值&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/table-01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;解决哈希冲突&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/table-02.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冲突节点在自己主位置的情况：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;如果不是主位置节点&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/table-03.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;调整不在主位置的冲突节点位置时要把它的前驱的 next 字段进行修改，对冲突节点的 next 字段也要修正。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于使用链接法时使用的是单向链表，因此想要获取冲突节点的前驱需要将冲突节点的键取出来求哈希，首先得到主位置，再通过一步一步地 next ，找到冲突节点之前的位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;解决哈希冲突&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/table-04.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;lastfree 的移动：初始化时指向 node 数组的最后一位。在这之后，一般情况下只会使用自减操作向左移动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;resize-操作&#34;&gt;resize 操作&lt;/h2&gt;
&lt;p&gt;当表空间不足时就会进行 resize 操作。&lt;/p&gt;
&lt;p&gt;第一步是对 Key 为整数的部分进行统计，统计的是在区间 $(2^i, 2^{i+1}]$ 不为空的元素的个数，方便之后的 resize ，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;** Count keys in array part of table &amp;#39;t&amp;#39;: Fill &amp;#39;nums[i]&amp;#39; with
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;** number of keys that will go into corresponding slice and return
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;** total number of non-nil keys.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; numusearray (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; Table *t, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; *nums) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; lg;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; ttlg;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* 2^lg */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; ause = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* summation of &amp;#39;nums&amp;#39; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* count to traverse all array keys */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; asize = limitasasize(t);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* real array size */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* traverse each slice */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (lg = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, ttlg = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; lg &amp;lt;= MAXABITS; lg++, ttlg *= &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; lc = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* counter */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; lim = ttlg;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (lim &amp;gt; asize) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      lim = asize;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* adjust upper limit */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (i &amp;gt; lim)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;break&lt;/span&gt;;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* no more elements to count */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;/* count elements in range (2^(lg - 1), 2^lg] */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (; i &amp;lt;= lim; i++) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (!isempty(&amp;amp;t-&amp;gt;array[i-&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;]))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        lc++;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    nums[lg] += lc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ause += lc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; ause;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;重新确定数组大小的一个原则就是，数组中不为空的元素要超过数组长度的一半，Lua 的设计者使用这种方法保证效率和内存使用的平衡。函数 computesizes 用于计算新数组的大小，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; computesizes (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; nums[], &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; *pna) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; twotoi;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* 2^i (candidate for optimal size) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; a = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* number of elements smaller than 2^i */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; na = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* number of elements to go to array part */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; optimal = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* optimal size for array part */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* loop while keys can fill more than half of total size */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, twotoi = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       twotoi &amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; *pna &amp;gt; twotoi / &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       i++, twotoi *= &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a += nums[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (a &amp;gt; twotoi/&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;) {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* more than half elements present? */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      optimal = twotoi;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* optimal size (till now) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      na = a;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* all elements up to &amp;#39;optimal&amp;#39; will go to array part */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lua_assert((optimal == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt; || optimal / &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; &amp;lt; na) &amp;amp;&amp;amp; na &amp;lt;= optimal);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  *pna = na;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; optimal;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果计算出来的 newsize 大于原来的大小，则将 Node 数组（哈希部分）中的一部分移到数组之中；如果小于，则将数组的一部分移到 Node 数组中。但无论如何都要对 Node 部分进行 rehash 操作。&lt;/p&gt;
&lt;p&gt;上文中的 numusearray 和 computesizes 计算都是在函数 rehash 中调用的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;** nums[i] = number of keys &amp;#39;k&amp;#39; where 2^(i - 1) &amp;lt; k &amp;lt;= 2^i
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; rehash (lua_State *L, Table *t, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; TValue *ek) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; asize;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* optimal size for array part */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; na;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* number of keys in the array part */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; nums[MAXABITS + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; totaluse;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt;= MAXABITS; i++) nums[i] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* reset counts */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  setlimittosize(t);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  na = numusearray(t, nums);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* count keys in array part */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  totaluse = na;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* all those keys are integer keys */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  totaluse += numusehash(t, nums, &amp;amp;na);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* count keys in hash part */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* count extra key */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (ttisinteger(ek))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    na += countint(ivalue(ek), nums);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  totaluse++;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* compute new size for array part */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  asize = computesizes(nums, &amp;amp;na);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* resize the table to new computed sizes */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  luaH_resize(L, t, asize, totaluse - na);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;next-操作&#34;&gt;next 操作&lt;/h2&gt;
&lt;p&gt;在 Lua 解释器中没有实现一个数据结构可以维护对 Table 的迭代信息，但是有一个函数 LuaH_next 可以通过传入一个键值，返回下一个键值对（实际上是将键值对压入 Lua 的栈中）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; luaH_next (lua_State *L, Table *t, StkId key) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; asize = luaH_realasize(t);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = findindex(L, t, s2v(key), asize);  &lt;span style=&#34;color:#007f7f&#34;&gt;/* find original key */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (; i &amp;lt; asize; i++) {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* try first array part */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (!isempty(&amp;amp;t-&amp;gt;array[i])) {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* a non-empty entry? */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      setivalue(s2v(key), i + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      setobj2s(L, key + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, &amp;amp;t-&amp;gt;array[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (i -= asize; cast_int(i) &amp;lt; sizenode(t); i++) {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* hash part */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (!isempty(gval(gnode(t, i)))) {  &lt;span style=&#34;color:#007f7f&#34;&gt;/* a non-empty entry? */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      Node *n = gnode(t, i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      getnodekey(L, s2v(key), n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      setobj2s(L, key + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, gval(n));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;  &lt;span style=&#34;color:#007f7f&#34;&gt;/* no more elements */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码的基本思路为对传入 Key 之后的位置进行遍历，找到第一个非空的元素，将其键值对压入栈中，遍历依然是数组部分优先。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过对 Lua Table 的学习，发现它真的是一门很适合用于教学的语言：首先它的设计理念很统一，而且蕴含了 &lt;em&gt;Less is more&lt;/em&gt; 等简洁哲学；其次，它的代码短小规范，结构清晰，可读性极强，技巧使用也不多，看 Lua 代码有一种坐在教室看幻灯片的感觉。&lt;/p&gt;
&lt;p&gt;但做到了简洁，代价又是什么呢？&lt;/p&gt;
&lt;p&gt;我认为 Table 反而丧失了数组的高效，也让字典的内部实现变得复杂了起来。不过作为一门广泛用于配置文件的胶水语言，效率也许并没有那么重要。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/lua/lua&#34;&gt;Lua 5.4.4 源码&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://lua-users.org/wiki/LuaDirectory&#34;&gt;Lua-Users-Wiki&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.lua.org/doc/jucs05.pdf&#34;&gt;The Implementation of Lua 5.0&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.codingnow.com&#34;&gt;云风的 BLOG&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>C语言异常处理</title>
      <link>https://vaaandark.top/posts/c-exception/</link>
      <pubDate>Tue, 03 May 2022 19:36:40 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/c-exception/</guid>
      <description>&lt;p&gt;C 语言没有原生支持异常处理，但是可以使用&lt;code&gt;setjmp&lt;/code&gt;和&lt;code&gt;longjmp&lt;/code&gt;函数实现类似&lt;code&gt;try ... except&lt;/code&gt;的功能。&lt;/p&gt;
&lt;p&gt;本文主要参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;C Interfaces and Implementation&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;a href=&#34;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-40.pdf&#34;&gt;Implementing exceptions in C&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;setjmph&#34;&gt;setjmp.h&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;setjmp.h&lt;/code&gt;是 C 标准函数库中提供“非本地跳转”的头文件：控制流偏离了通常的子程序调用与返回序列。互补的两个函数&lt;code&gt;setjmp&lt;/code&gt;与&lt;code&gt;longjmp&lt;/code&gt;提供了这种功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setjmp&lt;/code&gt;和&lt;code&gt;longjmp&lt;/code&gt;的典型用途是异常处理机制的实现：利用&lt;code&gt;longjmp&lt;/code&gt;恢复程序或线程的状态，甚至可以跳过栈中多层的函数调用。&lt;/p&gt;
&lt;h3 id=&#34;重要函数&#34;&gt;重要函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;int setjmp(jmp_buf env)&lt;/code&gt;：建立本地的&lt;code&gt;jmp_buf&lt;/code&gt;缓冲区并且初始化，用于将来跳转回此处。这个子程序保存程序的调用环境于&lt;code&gt;env&lt;/code&gt;参数所指的缓冲区，&lt;code&gt;env&lt;/code&gt;将被&lt;code&gt;longjmp&lt;/code&gt;使用。如果是从&lt;code&gt;setjmp&lt;/code&gt;直接调用返回，&lt;code&gt;setjmp&lt;/code&gt;返回值为 0 。如果是从&lt;code&gt;longjmp&lt;/code&gt;恢复的程序调用环境返回，&lt;code&gt;setjmp&lt;/code&gt;返回非零值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void longjmp(jmp_buf env, int value)&lt;/code&gt;：恢复&lt;code&gt;env&lt;/code&gt;所指的缓冲区中的程序调用环境上下文，&lt;code&gt;env&lt;/code&gt;所指缓冲区的内容是由&lt;code&gt;setjmp&lt;/code&gt;子程序调用所保存。&lt;code&gt;value&lt;/code&gt;的值从&lt;code&gt;longjmp&lt;/code&gt;传递给&lt;code&gt;setjmp&lt;/code&gt;。&lt;code&gt;longjmp&lt;/code&gt;完成后，程序从对应的&lt;code&gt;setjmp&lt;/code&gt;调用处继续执行，如同&lt;code&gt;setjmp&lt;/code&gt;调用刚刚完成。如果&lt;code&gt;value&lt;/code&gt;传递给&lt;code&gt;longjmp&lt;/code&gt;零值，&lt;code&gt;setjmp&lt;/code&gt;的返回值为 1 ；否则，&lt;code&gt;setjmp&lt;/code&gt;的返回值为&lt;code&gt;value&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;重要类型&#34;&gt;重要类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jmp_buf&lt;/code&gt;：用于保存恢复调用环境所需要的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;浅探异常处理&#34;&gt;浅探异常处理&lt;/h2&gt;
&lt;p&gt;下面一段代码给出了使用&lt;code&gt;setjmp&lt;/code&gt;和&lt;code&gt;longjmp&lt;/code&gt;处理异常的基本思路：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;setjmp.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; Allocation_handled = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jmp_buf Allocate_Failed;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; *allocate(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; *new = malloc(n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (new)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; new;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (Allocation_handled)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		longjmp(Allocate_Failed, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	assert(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *buf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Allocation_handled = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (setjmp(Allocate_Failed)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		fprintf(stderr, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;couldn&amp;#39;t allocate the buffer&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		exit(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	buf = allocate(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4096&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Allocation_handled = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上面的程序中，第一次调用&lt;code&gt;setjmp&lt;/code&gt;时函数返回 0 ，因此不进入&lt;code&gt;if&lt;/code&gt;后的分支而是继续执行后续操作，在调用函数&lt;code&gt;allocate&lt;/code&gt;时，如果内存分配失败，将会调用&lt;code&gt;longjmp&lt;/code&gt;函数，这会导致&lt;code&gt;setjmp&lt;/code&gt;函数第二次返回，此时的返回值是&lt;code&gt;longjmp&lt;/code&gt;函数第二个参数 1 。&lt;/p&gt;
&lt;p&gt;因此我们可以这样理解，&lt;code&gt;setjmp&lt;/code&gt;函数一般会返回两次，第一次调用是为了给之后的跳转标记位置和保存上文的环境，第二次返回是由调用&lt;code&gt;longjmp&lt;/code&gt;函数引起的，此时的返回值不是 0 ，因此可以进入&lt;code&gt;if&lt;/code&gt;分支中处理异常。&lt;/p&gt;
&lt;p&gt;流程如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;							                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                             ________return_a_non-zero_number ---&amp;gt; exception_handling ---&amp;gt; ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            /
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                           /
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;normal_control_flow ---&amp;gt; setjmp --- first_called --- return_0 ---&amp;gt; do_something ---&amp;gt; longjmp ---&amp;gt; normal_control_flow
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                           \                                                           /
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            \__________________call_second_time_______________________/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                                    &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;利用宏实现类似try--except的功能&#34;&gt;利用宏实现类似&lt;code&gt;try ... except&lt;/code&gt;的功能&lt;/h2&gt;
&lt;h3 id=&#34;实现效果&#34;&gt;实现效果&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TRY
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	S
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;EXCEPT(E1)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	S1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;EXCEPT(E2)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	S2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;EXCEPT(En)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Sn
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ELSE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	S0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ENDTRY
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// or
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TRY
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	S
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;FINALLY
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	S1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ENDTRY
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/vaaandark/cii/tree/main/except&#34;&gt; GitHub 仓库&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;重要结构体&#34;&gt;重要结构体&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;except&lt;/code&gt;结构体表示异常类型&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; except {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *reason;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;except_frame&lt;/code&gt;是一个链表的节点，包含了异常所在位置的程序环境、代码文件和行数，以及异常类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; except_frame {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; except_frame *prev;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	jmp_buf env;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *file;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; line;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; except *exception;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;重要全局变量&#34;&gt;重要全局变量&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;except_stack&lt;/code&gt;是一个异常栈，每次处理栈顶的异常，直至栈空。因此这个结构是实现异常嵌套处理的关键。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; except_frame *except_stack;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;重要函数-1&#34;&gt;重要函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;except_raise&lt;/code&gt;：用于抛出一个异常并跳转到&lt;code&gt;setjump&lt;/code&gt;，然后进入到异常处理分支。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; except_raise(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; except *e, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt; *file ,&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; line)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;重要的宏&#34;&gt;重要的宏&lt;/h4&gt;
&lt;p&gt;其实根据&lt;code&gt;except_raise&lt;/code&gt;函数和全局变量就可以实现所有的功能了，但下文中的宏也并不是多此一举，正是它们让我们可以实现&lt;code&gt;TRY ... EXCEPT ... ELSE ... END_TRY&lt;/code&gt;或者&lt;code&gt;TRY ... FINAL ... END_TRY&lt;/code&gt;这样的语法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define TRY do { \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;	volatile int except_flag; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;	struct except_frame except_frame; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;	except_frame.prev = except_stack; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;	except_stack = &amp;amp;except_frame; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;	except_flag = setjmp(except_frame.env); \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;	if (except_flag == EXCEPT_ENTERED) {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define EXCEPT(e) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;		if (except_flag == EXCEPT_ENTERED) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;			except_stack = except_stack-&amp;gt;prev; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;	} else if (except_frame.exception == &amp;amp;(e)) { \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;		except_flag = EXCEPT_HANDLED;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define ELSE \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;		if (except_flag == EXCEPT_ENTERED) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;			except_stack = except_stack-&amp;gt;prev; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;	} else { \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;		except_flag = EXCEPT_HANDLED;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define FINALLY \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;		if (except_flag == EXCEPT_ENTERED) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;			except_stack = except_stack-&amp;gt;prev; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;	} { \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;		if (except_flag == EXCEPT_ENTERED) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;			except_flag = EXCEPT_FINALIZED;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define END_TRY \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;		if (except_flag == EXCEPT_ENTERED) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;			except_stack = except_stack-&amp;gt;prev; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;	} if (except_flag == EXCEPT_RAISEED) RERAISE; \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;} while (0)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define RAISE(e) except_raise(&amp;amp;(e), __FILE__, __LINE__)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define RERAISE except_raise(except_frame.exception, except_frame.file, except_frame.line)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define RETURN switch (except_stack = except_stack-&amp;gt;prev , 0) default: return
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;p&gt;先全局定义几种异常类型，可以如下定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; except allocate_fail = {&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Allocate failed&amp;#34;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; except div_by_zero = {&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;divided by 0&amp;#34;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; except unknown_exception = {&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;unknown exception&amp;#34;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;抛出异常：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (something_happened)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	RAISE(a_except);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; (another_thing_happened)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	RAISE(another_except);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	RAISE(unknown_exception);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;捕捉异常：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TRY
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	do_something();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;EXCEPT(allocate_fail)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;catch a exception of %s&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, allocate_fail.reason);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;EXCEPT(div_by_zero)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;catch a exception of %s&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, div_by_zero.reason);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ELSE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	printf(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;catch a exception of %s&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, unknown_exception.reason);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	RERAISE;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;END_TRY;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在 C 语言中很多时候对异常的处理其实没有这么麻烦，直接使用 if else 几个分支就搞定了，而且也不会有因为跳转导致资源无法释放的问题。&lt;/p&gt;
&lt;p&gt;但是通过&lt;code&gt;setjmp.h&lt;/code&gt;和一些宏实现&lt;code&gt;try ... exception&lt;/code&gt;同样是有价值的，除了锻炼思维和写宏读宏的能力外，它还有很多用处，尤其是在一些由 C 编写的其他语言中，它就能提供异常处理甚至是协程的功能（例如 Lua ）。&lt;/p&gt;
&lt;p&gt;因此研究&lt;code&gt;setjmp.h&lt;/code&gt;实现异常对我们设计架构乃至编程语言都大有裨益。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rust闭包</title>
      <link>https://vaaandark.top/posts/rust-closure/</link>
      <pubDate>Tue, 26 Apr 2022 23:15:48 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/rust-closure/</guid>
      <description>&lt;p&gt;Rust 支持函数式编程，因此高阶函数、闭包等特性都不可或缺。&lt;/p&gt;
&lt;p&gt;本文主要参考了 &lt;em&gt;&lt;strong&gt;Rust Course&lt;/strong&gt;&lt;/em&gt; 和 Rust 标准库文档。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;什么是闭包&#34;&gt;什么是闭包&lt;/h2&gt;
&lt;p&gt;闭包是在支持头等函数的编程语言中实现词法绑定的一种技术，与函数不同的是，它可以捕捉自由变量，这意味着即使脱离了闭包创建时的上下文也能正常运行。&lt;/p&gt;
&lt;p&gt;闭包的用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;闭包实现了类似环境变量的功能，多个函数使用相同的环境。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;闭包可以定义自己的控制流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;闭包可以实现对象系统。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Rust 中，可以像如下方式创建一个最简单的闭包：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; add1 = |x: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;| x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;assert_eq!(add1(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;), &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这段代码创建了一个匿名函数&lt;code&gt;add1&lt;/code&gt;并在之后调用。&lt;/p&gt;
&lt;p&gt;Rust 中闭包的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数列表中使用&lt;code&gt;||&lt;/code&gt;代替&lt;code&gt;()&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果只有一个语句可以省略掉&lt;code&gt;{}&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以捕捉自由变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以利用闭包的类型自动推导，以下几种方法是等效的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt;  add_one_v1   (x: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u32&lt;/span&gt; { x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; add_one_v2 = |x: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u32&lt;/span&gt;| -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;u32&lt;/span&gt; { x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; add_one_v3 = |x|             { x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; add_one_v4 = |x|               x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;  ;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;需要注意的是，Rust 虽然有类型的自动推导，但是它只是一种语法糖，而不是泛型，当编译器推导出一种类型的闭包之后，它会一直使用该类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包本质上是一种词法绑定，故当闭包从环境中捕获一个值时，会分配内存去存储这些值。对于有些场景来说，这种额外的内存分配会成为一种负担。与之相比，函数就不会去捕获这些环境值，因此定义和使用函数不会拥有这种内存负担。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;三种fn特征&#34;&gt;三种&lt;code&gt;Fn&lt;/code&gt;特征&lt;/h2&gt;
&lt;p&gt;闭包有三种方式捕获自由变量，分别是：转移所有权、可变借用和不可变借用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FnOnce&lt;/code&gt;，顾名思义，这种闭包只能使用一次，因为它会夺取捕获到的变量的所有权。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;trait&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Fn&lt;/span&gt;&amp;lt;Args&amp;gt; : &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;FnMut&lt;/span&gt;&amp;lt;Args&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;rust-call&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; call(&amp;amp;self, args: Args) -&amp;gt; Self::Output;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FnMut&lt;/code&gt;，使用可变引用捕获了环境中的值，因此可以对其进行修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;trait&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;FnMut&lt;/span&gt;&amp;lt;Args&amp;gt; : &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;FnOnce&lt;/span&gt;&amp;lt;Args&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;rust-call&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; call_mut(&amp;amp;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; self, args: Args) -&amp;gt; Self::Output;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fn&lt;/code&gt;，使用不可变引用捕获了环境中的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;trait&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;FnOnce&lt;/span&gt;&amp;lt;Args&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;type&lt;/span&gt; Output;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;rust-call&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; call_once(self, args: Args) -&amp;gt; Self::Output;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当闭包的生命周期大于需要捕获的自由变量的生命周期时，可以使用&lt;code&gt;move&lt;/code&gt;关键字将自由变量的所有权移入闭包中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; v = vec![&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; print_vec = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;move&lt;/span&gt; || println!(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;{:?}&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, v);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;除了&lt;code&gt;FnMut&lt;/code&gt;需要在创建变量时使用&lt;code&gt;mut&lt;/code&gt;，创建闭包时并不需要显式地指定它实现的特征，因此闭包的类型实际上是编译器推导出来的，只有将闭包当作参数传递需要类型标注时才需要显式标记类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的闭包都自动实现了&lt;code&gt;FnOnce&lt;/code&gt;特征，因此任何一个闭包都至少可以被调用一次&lt;/li&gt;
&lt;li&gt;没有移出所捕获变量的所有权的闭包自动实现了&lt;code&gt;FnMut&lt;/code&gt;特征&lt;/li&gt;
&lt;li&gt;不需要对捕获变量进行改变的闭包自动实现了&lt;code&gt;Fn&lt;/code&gt;特征&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是 &lt;em&gt;&lt;strong&gt;Rust Course&lt;/strong&gt;&lt;/em&gt; 中的一个例子，说明了闭包实现的特征取决于使用自由变量的方法，而且因为只使用了不可变引用，三种特征都可以实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; main() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; s = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;String&lt;/span&gt;::new();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; update_string =  || println!(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;,s);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    exec(update_string);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    exec1(update_string);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    exec2(update_string);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; exec&amp;lt;F: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;FnOnce&lt;/span&gt;()&amp;gt;(f: F)  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    f()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; exec1&amp;lt;F: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;FnMut&lt;/span&gt;()&amp;gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; f: F)  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    f()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; exec2&amp;lt;F: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Fn&lt;/span&gt;()&amp;gt;(f: F)  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    f()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在编程中需要我们善于利用编译器的报错，可以先使用 Fn 特征，然后编译器会告诉你正误以及该如何选择。&lt;/p&gt;
&lt;h2 id=&#34;闭包作为返回值&#34;&gt;闭包作为返回值&lt;/h2&gt;
&lt;p&gt;闭包作为函数返回值时不要忘了使用&lt;code&gt;impl&lt;/code&gt;关键字，可以理解为实现了&lt;code&gt;Fn(xxx) -&amp;gt; yyy&lt;/code&gt;特征。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; add_num(n: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;) -&amp;gt; impl &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Fn&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;move&lt;/span&gt; |x| x + n
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; main() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; add1 = add_num(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assert_eq!(add1(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;), &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用这种方式有一个局限性就是只能返回一种闭包，因为即使是相同函数签名的闭包也是不同类型的，这时就需要使用特征对象：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; factory(x:&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Box&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;dyn&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Fn&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; num = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#007f7f&#34;&gt;// 要注意闭包中只捕获了 num 而没有捕获 x，x是闭包的参数，而不是上文中的 x
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; x &amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Box&lt;/span&gt;::new(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;move&lt;/span&gt; |x| x + num)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Box&lt;/span&gt;::new(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;move&lt;/span&gt; |x| x - num)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; main() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; add5 = factory(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; sub5 = factory(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assert_eq!(add5(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;), &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assert_eq!(sub5(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;), -&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;闭包的生命周期&#34;&gt;闭包的生命周期&lt;/h2&gt;
&lt;p&gt;Rust 中函数和闭包有不同的&lt;strong&gt;生命周期省略原则（Lifetime Elision）&lt;/strong&gt;，故两段几乎相同的代码在函数中能编译通过，在闭包中不能通过：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; fn_elision(x: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt; { x }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; closure_slision = |x: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;| -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt; { x };
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;会报错：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error: lifetime may not live long enough
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; --&amp;gt; d.rs:&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;:&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;47&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; |     &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; closure_slision = |x: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;| -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt; { x };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  |                               -        -      ^^ returning this value requires that &lt;span style=&#34;color:#f00&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;`&lt;/span&gt; must outlive &lt;span style=&#34;color:#f00&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  |                               |        |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  |                               |        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;s&lt;/span&gt; call the lifetime of this reference &lt;span style=&#34;color:#f00&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  |                               &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;s&lt;/span&gt; call the lifetime of this reference &lt;span style=&#34;color:#f00&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果函数参数中只有一个引用类型，那该引用的生命周期会被自动分配给所有的返回引用。但是闭包不会这样，这点值得我们注意。&lt;/p&gt;
&lt;h2 id=&#34;结构体中使用闭包&#34;&gt;结构体中使用闭包&lt;/h2&gt;
&lt;p&gt;如下代码是官方示例的升级版，&lt;code&gt;Cacher&lt;/code&gt;结构体只有在需要获取值且尚未重复计算时执行闭包，在执行后将计算结构缓存到一个&lt;code&gt;HashMap&lt;/code&gt;之中，这种模式被叫做惰性求值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;use&lt;/span&gt; std::collections::HashMap;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; Cacher&amp;lt;F&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;where&lt;/span&gt; F: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Fn&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    val_map: HashMap&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;&amp;gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    calculation: F
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;impl&lt;/span&gt; &amp;lt;F&amp;gt; Cacher&amp;lt;F&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;where&lt;/span&gt; F: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Fn&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; new(calculation: F) -&amp;gt; Cacher&amp;lt;F&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Cacher {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            val_map: HashMap::new(),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            calculation
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; value(&amp;amp;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; self, arg: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Some&lt;/span&gt;(v) = self.val_map.get(&amp;amp;arg) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            *v
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; v = (self.calculation)(arg);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            self.val_map.insert(arg, v);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            v
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; main() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; c = Cacher::new(|x| x);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; v1 = c.value(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; v2 = c.value(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assert_eq!(v1, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assert_eq!(v2, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Rust迭代器</title>
      <link>https://vaaandark.top/posts/rust-iterator/</link>
      <pubDate>Mon, 25 Apr 2022 23:22:24 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/rust-iterator/</guid>
      <description>&lt;p&gt;最近一直在学习 Rust 语言，深感它的学习曲线很陡峭，因此会写几篇博客记录一下学习进度。&lt;/p&gt;
&lt;p&gt;本文主要参考了 &lt;em&gt;&lt;strong&gt;Rust Course&lt;/strong&gt;&lt;/em&gt; 和 Rust 标准库文档。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;什么是迭代器&#34;&gt;什么是迭代器&lt;/h2&gt;
&lt;p&gt;迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，设计人员使用此接口无需关心容器对象的内存分配的实现细节。&lt;/p&gt;
&lt;p&gt;在 Rust 中的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;for&lt;/code&gt;的隐式迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; v = vec![&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;in&lt;/span&gt; &amp;amp;v {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	println!(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for&lt;/code&gt;语句中显式使用迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; v = vec![&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;in&lt;/span&gt; v.into_iter() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        println!(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;Iterator&lt;/code&gt;特征的&lt;code&gt;next&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; v = vec![&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; v = v.into_iter();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;assert_eq!(arr_iter.next(), &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Some&lt;/span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;assert_eq!(arr_iter.next(), &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Some&lt;/span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;assert_eq!(arr_iter.next(), &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Some&lt;/span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;assert_eq!(arr_iter.next(), &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;None&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当使用&lt;code&gt;for a in b&lt;/code&gt;语句遍历时，如果对象 b 实现了&lt;code&gt;IntoIterator&lt;/code&gt;特性，我们便可以利用 Rust 给我们提供的语法糖，不必显式使用迭代器。&lt;/p&gt;
&lt;p&gt;迭代器是消耗性的，每遍历到一个元素就会消耗掉一个元素，最终迭代器中没有任何元素，只能返回&lt;code&gt;None&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要注意两个特征&lt;code&gt;Iterator&lt;/code&gt;和&lt;code&gt;IntoIterator&lt;/code&gt;的区别，一个是实现了迭代器的基本功能，一个是可以转化为迭代器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;有趣的是，每个实现了&lt;code&gt;Iterator&lt;/code&gt;的类型都实现了&lt;code&gt;IntoIterator&lt;/code&gt;，调用&lt;code&gt;into_iter&lt;/code&gt;时会返回自身。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;对iterator更进一步&#34;&gt;对&lt;code&gt;Iterator&lt;/code&gt;更进一步&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt;的路径为&lt;code&gt;std::iter::Iterator&lt;/code&gt;，拥有一个关联类型&lt;code&gt;Item&lt;/code&gt;，和迭代的元素类型相同。&lt;/p&gt;
&lt;p&gt;该特性有 72 个方法，下面着重介绍几种常用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;next&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; next(&amp;amp;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; self) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Option&lt;/span&gt;&amp;lt;Self::Item&amp;gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;返回&lt;code&gt;Some(Item)&lt;/code&gt;或者&lt;code&gt;None&lt;/code&gt;，同时更新自己到下一个位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size_hint&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; size_hint(&amp;amp;self) -&amp;gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;usize&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Option&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;usize&lt;/span&gt;&amp;gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;返回一个元组&lt;code&gt;(lower, upper)&lt;/code&gt;，&lt;code&gt;lower&lt;/code&gt;为当前迭代器剩余元素个数的下界，	&lt;code&gt;upper&lt;/code&gt;为其上界。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果上界很大，超过了&lt;code&gt;usize&lt;/code&gt;的最大值，就会是&lt;code&gt;None&lt;/code&gt;，因此&lt;code&gt;size_hint	&lt;/code&gt;的默认实现返回的就是&lt;code&gt;(0, None)&lt;/code&gt;，这满足任意一个迭代器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这个方法的主要作用是优化代码性能，可以通过该方法为迭代器的元素保留空间。在&lt;code&gt;std&lt;/code&gt;的官方文档中提到，该实现应当提供正确的估计，不能因为实现不正确导致内存安全性原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;enumerate&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; enumerate(self) -&amp;gt; Enumerate&amp;lt;Self&amp;gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;返回一个迭代器，迭代器的元素为一个元组&lt;code&gt;(i, val)&lt;/code&gt;，&lt;code&gt;i&lt;/code&gt;为当前元素的索引，&lt;code&gt;val&lt;/code&gt;为当前元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; map&amp;lt;B, F&amp;gt;(self, f: F) -&amp;gt; Map&amp;lt;Self, F&amp;gt;&lt;span style=&#34;color:#f00&#34;&gt;ⓘ&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    F: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;FnMut&lt;/span&gt;(Self::Item) -&amp;gt; B,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ ... }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;F&lt;/code&gt;是一个闭包，通过对每个元素调用该闭包，&lt;code&gt;map&lt;/code&gt;将一个迭代器转换为另一个迭代器。&lt;/p&gt;
&lt;p&gt;值得注意的是，&lt;code&gt;map&lt;/code&gt;是一个非常“函数式”的方法，如果使用&lt;code&gt;map&lt;/code&gt;方法调用一些有副作用的闭包，由于懒惰执行，它可能根本不会起作用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;..&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;).map(|x| println!(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, x));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for_each&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; map&amp;lt;B, F&amp;gt;(self, f: F)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	F: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;FnMut&lt;/span&gt;(Self::Item)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;效果上类似与&lt;code&gt;for&lt;/code&gt;语句，但是不能使用&lt;code&gt;break&lt;/code&gt;和&lt;code&gt;continue&lt;/code&gt;，适用于很长的迭代器链。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;filter&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; filter&amp;lt;P&amp;gt;(self, predicate: P) -&amp;gt; Filter&amp;lt;Self, P&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    P: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;FnMut&lt;/span&gt;(&amp;amp;Self::Item) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建一个迭代器，该迭代器使用闭包确定是否应产生元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;filter_map&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; filter_map&amp;lt;B, F&amp;gt;(self, f: F) -&amp;gt; FilterMap&amp;lt;Self, F&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    F: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;FnMut&lt;/span&gt;(Self::Item) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Option&lt;/span&gt;&amp;lt;B&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;既过滤又映射，可以用于简化迭代器链。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zip&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; zip&amp;lt;U&amp;gt;(self, other: U) -&amp;gt; Zip&amp;lt;Self, &amp;lt;U &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;IntoIterator&lt;/span&gt;&amp;gt;::IntoIter&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    U: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;IntoIterator&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将两个迭代器压缩为成对的单个迭代器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果任一迭代器返回&lt;code&gt;None&lt;/code&gt;，则&lt;code&gt;zipped&lt;/code&gt;迭代器中的&lt;code&gt;next&lt;/code&gt;将返回&lt;code&gt;None&lt;/code&gt;。如果第一个迭代器返回&lt;code&gt;None&lt;/code&gt;，则&lt;code&gt;zip&lt;/code&gt;将短路，并且不会在第二个迭代器上调用&lt;code&gt;next&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fold&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; fold&amp;lt;B, F&amp;gt;(self, init: B, f: F) -&amp;gt; B
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    F: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;FnMut&lt;/span&gt;(B, Self::Item) -&amp;gt; B 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;F&lt;/code&gt;被称为累加器，通过应用操作将每个元素 fold 到一个累加器中，返回最终结果。&lt;/p&gt;
&lt;p&gt;看一个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; a = [&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; sum = a.iter().fold(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, |acc, x| acc + x);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;assert_eq!(sum, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;6&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;collect&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; collect&amp;lt;B&amp;gt;(self) -&amp;gt; B
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    B: FromIterator&amp;lt;Self::Item&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将迭代器转换为集合。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;collect&lt;/code&gt;需要上下文让其知道按照什么方式收集，一种是通过直接显式地表明类型，一种是显式地指定&lt;code&gt;collect&lt;/code&gt;调用时的类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; v: vec&amp;lt;_&amp;gt; = (&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;..&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;).collect();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// or
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;v = (&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;..&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;).collect::&amp;lt;vec&amp;lt;_&amp;gt;&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;skip&lt;/code&gt;方法和&lt;code&gt;take&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;take(n)&lt;/code&gt;的作用是取前 n 个元素，而&lt;code&gt;skip(n)&lt;/code&gt;正好相反，跳过前 n 	个元素。&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip; 迭代器的方法很多，不一而足&lt;/p&gt;
&lt;h2 id=&#34;迭代器适配器和消费者适配器&#34;&gt;迭代器适配器和消费者适配器&lt;/h2&gt;
&lt;p&gt;顾名思义，迭代器适配器就是产生迭代器，消费者适配器就是消耗迭代器。在之前讲&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;for_each&lt;/code&gt;时可以看到，&lt;code&gt;map&lt;/code&gt;创建了一个迭代器，而且是懒惰的，在使用之前不产生任何行为，如果&lt;code&gt;map&lt;/code&gt;在调用链的最后一个编译器就会报警，因此我们需要一个消费者适配器来收尾。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;warning: unused &lt;span style=&#34;color:#f00&#34;&gt;`&lt;/span&gt;Map&lt;span style=&#34;color:#f00&#34;&gt;`&lt;/span&gt; that must be used
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; --&amp;gt; c.rs:&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;:&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; |     (&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;..&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;).map(|x| println!(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;, x));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  = note: &lt;span style=&#34;color:#f00&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#[warn(unused_must_use)]&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;`&lt;/span&gt; on by default
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  = note: iterators are lazy and &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt; nothing unless consumed
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; v: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Vec&lt;/span&gt;&amp;lt;_&amp;gt; = (&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;..&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;).map(|x| x * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;).collect();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;自己动手实现iterator特征&#34;&gt;自己动手实现&lt;code&gt;Iterator&lt;/code&gt;特征&lt;/h2&gt;
&lt;p&gt;主要是要实现&lt;code&gt;Iterator&lt;/code&gt;中的&lt;code&gt;next&lt;/code&gt;方法，这个方法是其余方法的基础，实现了&lt;code&gt;next&lt;/code&gt;方法后，其余都可以默认实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; Range {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cnt: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    end: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;impl&lt;/span&gt; Range {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; new(cnt: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;, end: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;) -&amp;gt; Range {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Range {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cnt,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            end
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;impl&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Iterator&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; Range {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;type&lt;/span&gt; Item = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; next(&amp;amp;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; self) -&amp;gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Option&lt;/span&gt;&amp;lt;Self::Item&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self.cnt += &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; self.cnt == self.end {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;None&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Some&lt;/span&gt;(self.cnt)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;fn&lt;/span&gt; main() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;mut&lt;/span&gt; r = Range::new(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;10&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assert_eq!(r.next(), &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Some&lt;/span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assert_eq!(r.next(), &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Some&lt;/span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assert_eq!(r.next(), &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Some&lt;/span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assert_eq!(r.next(), &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;Some&lt;/span&gt;(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; sum: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt; = Range::new(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;10&lt;/span&gt;).sum();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assert_eq!(sum, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;45&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;let&lt;/span&gt; sum: &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;i32&lt;/span&gt; = Range::new(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;10&lt;/span&gt;).map(|x| x * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;).filter(|x| x &amp;lt; &amp;amp;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;10&lt;/span&gt;).sum();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    assert_eq!(sum, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;20&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;迭代器是 Rust 的零成本抽象之一，抽象时不会引起运行时开销，所以迭代器有着极高的运行效率。&lt;/p&gt;
&lt;p&gt;在编写代码时，使用迭代器也能带来良好的函数式编程的体验，使用迭代器链并与闭包结合时体验更是超过了 Lisp 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>华科寝室简易门禁</title>
      <link>https://vaaandark.top/posts/simple-entrance-guard-in-hust/</link>
      <pubDate>Tue, 29 Mar 2022 19:14:13 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/simple-entrance-guard-in-hust/</guid>
      <description>&lt;p&gt;华科宿舍的大门门禁用学生卡开，而每个寝室的门却只能使用钥匙打开。这就导致了每次出门都要带上学生卡和钥匙，每次回来都要先掏出卡，再掏出钥匙。这样实在是麻烦，因此我有了用校园卡就能打开宿舍门的想法。&lt;/p&gt;
&lt;p&gt;本项目地址 &lt;a href=&#34;https://github.com/vaaandark/smart-door&#34;&gt;Github 仓库&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MFRC522 官方手册 &lt;a href=&#34;https://www.nxp.com.cn/docs/en/data-sheet/MFRC522.pdf&#34;&gt;doc&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;李乾文的博客 &lt;a href=&#34;https://blog.csdn.net/leytton/article/details/73480974&#34;&gt;RFID-RC522读IC卡&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同宿舍楼上一位学长的 &lt;a href=&#34;https://www.bilibili.com/read/cv7832399?spm_id_from=333.999.0.0&#34;&gt;博文&lt;/a&gt; 及 &lt;a href=&#34;https://github.com/yllhwa/nfchello&#34;&gt;GitHub 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;他博客中引用的链接 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/66467989&#34;&gt;文章&lt;/a&gt; 及 &lt;a href=&#34;https://github.com/Ghastlcon/Access-Control&#34;&gt;GitHub 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;材料准备&#34;&gt;材料准备&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;名称&lt;/th&gt;
          &lt;th&gt;用途&lt;/th&gt;
          &lt;th&gt;预算(RMB)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;USB 延长线（公对母）&lt;/td&gt;
          &lt;td&gt;供电&lt;/td&gt;
          &lt;td&gt;6&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;USB 带开关延长线&lt;/td&gt;
          &lt;td&gt;开关&lt;/td&gt;
          &lt;td&gt;10&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Arduino UNO R3 开发板&lt;/td&gt;
          &lt;td&gt;控制&lt;/td&gt;
          &lt;td&gt;12&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;MG996R 舵机&lt;/td&gt;
          &lt;td&gt;开门&lt;/td&gt;
          &lt;td&gt;13&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RC522 IC 卡感应模块&lt;/td&gt;
          &lt;td&gt;读卡&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;杜邦线&lt;/td&gt;
          &lt;td&gt;接线&lt;/td&gt;
          &lt;td&gt;0 （白嫖）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;合计：46 RMB&lt;/p&gt;
&lt;h3 id=&#34;工具准备&#34;&gt;工具准备&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;名称&lt;/th&gt;
          &lt;th&gt;用途&lt;/th&gt;
          &lt;th&gt;预算(RMB)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;热熔胶枪和若干胶棒&lt;/td&gt;
          &lt;td&gt;固定&lt;/td&gt;
          &lt;td&gt;20&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;焊台&lt;/td&gt;
          &lt;td&gt;焊接&lt;/td&gt;
          &lt;td&gt;0 （白嫖）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;合计：20 RMB&lt;/p&gt;
&lt;h3 id=&#34;开发环境&#34;&gt;开发环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;arduino-cli&lt;/strong&gt; 0.21.1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;core&lt;/strong&gt; : arduino:avr 1.8.5&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lib&lt;/strong&gt; : MFRC522 1.4.10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fritzing&lt;/strong&gt; 0.9.9 beta&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;连线及原理图&#34;&gt;连线及原理图&lt;/h2&gt;
&lt;p&gt;RC522 模块的库是网上找的，在连线图上标识不够清晰，可以参考原理图来布线。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;连线&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/smart-door.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原理图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;原理图&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/smart-door_%E5%9B%BE%E7%A4%BA.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;配置及使用&#34;&gt;配置及使用&lt;/h2&gt;
&lt;p&gt;编译烧录运行&lt;code&gt;./src/get-id/get-id.ino&lt;/code&gt;以获得卡的 UID。&lt;/p&gt;
&lt;p&gt;创建文件&lt;code&gt;./src/access-control/card-group.hpp&lt;/code&gt;，添加如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define CARD_NUM {卡的数量}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define UID_SIZE 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; byte card_group[CARD_NUM][UID_SIZE] =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    { &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x00&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    { &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x00&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//    ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译烧录&lt;code&gt;./src/access-control/access-control.ino&lt;/code&gt;则可以使用这个简易门禁了！&lt;/p&gt;
&lt;h2 id=&#34;效果图&#34;&gt;效果图&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;连线完成效果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;连线完成&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/connected-device.jpg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装完成效果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;安装完成-1&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/installed-device_1.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;安装完成-2&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/installed-device_2.jpg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用效果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;demo&#34; loading=&#34;lazy&#34; src=&#34;https://vaaandark.top/image/demo.gif&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lua入门</title>
      <link>https://vaaandark.top/posts/lua-introduction/</link>
      <pubDate>Wed, 23 Mar 2022 23:40:09 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/lua-introduction/</guid>
      <description>&lt;p&gt;最近对脚本语言 Lua 很感兴趣，其一是因为它可以很方便地调用 C 语言库，其二是因为它是很多现代化工具的配置语言（比如 NeoVim ），另外 Lua 的源代码不是很长，因此研究学习难度会比其他语言更低。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;基本语法&#34;&gt;基本语法&lt;/h2&gt;
&lt;h3 id=&#34;注释&#34;&gt;注释&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;单行注释以双减号开始&lt;code&gt;--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多行注释为：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;--[[
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;comment
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;--]]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;标识符&#34;&gt;标识符&lt;/h3&gt;
&lt;p&gt;与C语言规定相同&lt;/p&gt;
&lt;h3 id=&#34;保留字&#34;&gt;保留字&lt;/h3&gt;
&lt;p&gt;Lua 语言中保留字有 22 个：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;and&lt;/code&gt; &lt;code&gt;break&lt;/code&gt; &lt;code&gt;do&lt;/code&gt; &lt;code&gt;else&lt;/code&gt; &lt;code&gt;elseif&lt;/code&gt; &lt;code&gt;end&lt;/code&gt; &lt;code&gt;false&lt;/code&gt; &lt;code&gt;for&lt;/code&gt; &lt;code&gt;function&lt;/code&gt; &lt;code&gt;if&lt;/code&gt; &lt;code&gt;in&lt;/code&gt; &lt;code&gt;local&lt;/code&gt; &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;not&lt;/code&gt; &lt;code&gt;or&lt;/code&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;code&gt;return&lt;/code&gt; &lt;code&gt;then&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; &lt;code&gt;until&lt;/code&gt; &lt;code&gt;while&lt;/code&gt; &lt;code&gt;goto&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般约定，以下划线开头连接一串大写字母的名字（比如 VERSION ）被保留用于 Lua 内部全局变量。&lt;/p&gt;
&lt;h3 id=&#34;全局变量&#34;&gt;全局变量&lt;/h3&gt;
&lt;p&gt;Lua 中变量默认为全局变量，使用全局变量前不需要声明，赋值之后即创建了这个变量。&lt;/p&gt;
&lt;p&gt;如果访问了一个不存在的全局变量不会报错，只是它的值是&lt;code&gt;nil&lt;/code&gt;。同样地，删除一个变量就可以通过给它赋值为&lt;code&gt;nil&lt;/code&gt;来实现。&lt;/p&gt;
&lt;h2 id=&#34;数据类型&#34;&gt;数据类型&lt;/h2&gt;
&lt;p&gt;Lua 是动态类型语言，有八个基本类型，而且其中的一些较为特殊：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;数据类型&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;nil&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;false和true。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;number&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;数字类型&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;字符串&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;function&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;由 C 或 Lua 编写的函数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;userdata&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;表示任意存储在变量中的C数据结构&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;表示执行的独立线路，用于执行协同程序&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;table&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;Lua 中表是一种&amp;quot;关联数组&amp;quot;，数组的索引可以是数字、字符串或表类型。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们可以使用 type 函数测试给定变量或者值的类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(type(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- &amp;gt; string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(type(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;114514&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- &amp;gt; number&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(type(print))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- &amp;gt; function&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(type(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;true&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- &amp;gt; boolean&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(type(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;nil&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- &amp;gt; nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(type(type(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;nil&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- &amp;gt; string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- type() 函数返回值为字符串&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lua 默认只有一种 number 类型，为 double 双精度类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用一对双引号或者单引号来表示，也可以使用&lt;code&gt;[[]]&lt;/code&gt;来表示一块字符串。&lt;/p&gt;
&lt;p&gt;如果对字符串进行数字运算，会尝试将字符串转换为一个数字再进行运算；在 Lua 中，真正的字符串拼接是&lt;code&gt;..&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;类似于一些脚本语言， Lua 使用&lt;code&gt;#&lt;/code&gt;来计算字符串的长度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;table&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过构造表达式来创建一个&lt;code&gt;table&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 创建一个空表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;table1 = {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 在创建时进行初始化&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;table2 = {&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;向表中添加元素：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a = {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a[&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;key&amp;#34;&lt;/span&gt;] = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当表的索引为字符串时，可以使用&lt;code&gt;.&lt;/code&gt;来像结构体一样访问：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t = {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;t.key = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;value&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 以下两种方法等价&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(t.key)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(t[&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;key&amp;#34;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一种遍历表中元素的方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; k, v &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;in&lt;/span&gt; pairs(a) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(k .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; : &amp;#34;&lt;/span&gt; .. v)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;Lua 中表的默认初始索引为1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Lua 中，function 是第一类值，可以作为对象传递，也可以作为函数返回的值，可以存在变量之中。&lt;/p&gt;
&lt;p&gt;function 可以使用匿名函数，也可以使用闭包。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事实上，Lua 全部的函数都是匿名函数，函数名是对其的引用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;thread&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lua 中主要的线程是协程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;userdata&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以将 C/C++ 中的类型数据存在 Lua 变量中调用。&lt;/p&gt;
&lt;h2 id=&#34;变量与赋值&#34;&gt;变量与赋值&lt;/h2&gt;
&lt;p&gt;Lua 变量有三种类型：全局变量、局部变量、表中的域。变量默认为全局变量&lt;/p&gt;
&lt;p&gt;在多值赋值时，出现变量的个数和值的个数不一致情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果值更多，则忽略掉多余的值&lt;/li&gt;
&lt;li&gt;如果变量更多，则多出来的变量赋值为 nil&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多值赋值经常用来交换变量，或将函数调用返回给变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a, b = func()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a, b = b, a
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;流程控制&#34;&gt;流程控制&lt;/h2&gt;
&lt;h3 id=&#34;循环&#34;&gt;循环&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;while 循环&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt; (test_expression) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	do_something
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;for 循环&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;var 的值从 exp1 到 exp2 （闭区间），exp3 可选，默认为 1 ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; var=exp1, exp2, exp3 &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	do_something
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Lua 中也有泛型 for 循环&lt;code&gt;for .. in ...&lt;/code&gt;，与 python 类似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;repeat &amp;hellip; until 循环&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似 C 语言中的 do &amp;hellip; while ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;repeat&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	do_something
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;until&lt;/span&gt;(test_expression)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;循环控制语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt; &lt;code&gt;goto&lt;/code&gt; 与 C 语言类似&lt;/p&gt;
&lt;h3 id=&#34;分支判断&#34;&gt;分支判断&lt;/h3&gt;
&lt;p&gt;if 使用与 shell 中类似：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; ( test_expression1 ) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	do_something
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;elseif&lt;/span&gt; ( test_expression2 ) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	do_something
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	do_something
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;optional_func_scope: 默认为全局，使用 local 将函数设置为局部。&lt;/li&gt;
&lt;li&gt;ret: Lua 语言中函数返回值可以是多个，用逗号隔开。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;optional_func_scope &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; func_name(arg1, arg2, ... , argn)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	function_body
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; ret_val
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数可以作为参数传递&lt;/p&gt;
&lt;p&gt;Lua 支持可变参数，使用时在参数列表中用&lt;code&gt;...&lt;/code&gt;表示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; average(...)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; res = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; arg = {...}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; i, v &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;in&lt;/span&gt; ipairs(arg) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		res = res + v
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	res = res / #arg
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; res
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;函数 select(&amp;quot;#&amp;quot;, &amp;hellip;) 可以返回可变参数的数量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;select(n, &amp;hellip;) 可以返回从起点 n 开始到结束位置的所有参数列表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;运算符&#34;&gt;运算符&lt;/h2&gt;
&lt;p&gt;与 C 语言基本相同，逻辑运算为&lt;code&gt;and&lt;/code&gt; &lt;code&gt;or&lt;/code&gt; &lt;code&gt;not&lt;/code&gt;，此外还有乘幂运算&lt;code&gt;^&lt;/code&gt;和整除运算&lt;code&gt;//&lt;/code&gt;，关系运算符中不等于为&lt;code&gt;~=&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lua5.3 之后才支持整除运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;字符串&#34;&gt;字符串&lt;/h2&gt;
&lt;p&gt;在 string 模块中有很多方法可以操作字符串，以下函数原型可以望文生义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string.upper(str)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string.lower(str)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string.gsub(str, find, rep)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 返回子串的开始和结束索引，[] 表示可选参数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string.find(str, sub [, beg [, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;]])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string.reverse(str)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 返回类似 printf 的格式化字符串&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string.format(...)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 将整型数字转为字符串并连接&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string.char(...)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 转换字符为整数值，默认第一个字符&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string.byte(str [, n])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string.len(str)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 返回 str 的 n 个拷贝&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string.rep(str, n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 返回一个迭代器函数，init 可选，是搜索的起点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string.gmatch(str, pattern [, init])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 字符串截取&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string.sub(str, beg [, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;匹配模式：Lua 中的匹配模式是一种特殊的正则表达式，详见以下链接&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://lua-users.org/wiki/PatternsTutorial&#34;&gt;http://lua-users.org/wiki/PatternsTutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://riptutorial.com/lua/example/20315/lua-pattern-matching&#34;&gt;https://riptutorial.com/lua/example/20315/lua-pattern-matching&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;
&lt;p&gt;Lua 中的数组实际上就是下标为整数的 table 。&lt;/p&gt;
&lt;h2 id=&#34;迭代器&#34;&gt;迭代器&lt;/h2&gt;
&lt;p&gt;通用形式的 for 通过一个叫作 迭代器 的函数工作。 每次迭代，迭代器函数都会被调用以产生一个新的值， 当这个值为 nil 时，循环停止。 通用形式的 for 循环的语法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; namelist &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;in&lt;/span&gt; explist &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt; block &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样的 for 语句&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; var_1, &lt;span style=&#34;color:#f00&#34;&gt;···&lt;/span&gt;, var_n &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;in&lt;/span&gt; explist &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt; block &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它等价于这样一段代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; f, s, var = explist
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;true&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; var_1, &lt;span style=&#34;color:#f00&#34;&gt;···&lt;/span&gt;, var_n = f(s, var)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; var_1 == &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;break&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	var = var_1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	block
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;explist 只会被计算一次。它返回三个值，一个迭代器函数 f ，一个状态 s ，一个迭代器的初始值 var 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考：http://cloudwu.github.io/lua53doc/manual.html#3.3.5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;无状态的迭代器&#34;&gt;无状态的迭代器&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; _square_iter(ending, current)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; current &amp;lt; ending &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		current = current + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; current, current * current
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 此处相当于对 _square_iter 进行了一个包装&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; square_iter(ending, start)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; square_iter_, ending, start
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; i, n &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;in&lt;/span&gt; square_iter(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(i .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt; .. i .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt; .. n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1*1=1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2*2=4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3*3=9
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;有状态的迭代器&#34;&gt;有状态的迭代器&lt;/h3&gt;
&lt;p&gt;上面代码的等价形式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; square_iter(a)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	idx = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	len = #a
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#007f7f&#34;&gt;-- 迭代函数需要的信息被外层函数传递给了内层函数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		idx = idx + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; idx &amp;lt;= len &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; idx, a[idx] * a[idx]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; i, n &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;in&lt;/span&gt; square_iter({&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;}) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(i .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt; .. i .. &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt; .. n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;表&#34;&gt;表&lt;/h2&gt;
&lt;p&gt;移除一个表的引用可以通过赋值为 nil 来完成，如果没有引用指向该表，该表占用的内存就会被释放。&lt;/p&gt;
&lt;p&gt;在 table 模块中有很多方法可以操作表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;table.concat (table [, sep [, start [, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;]]]):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 默认插入到数组尾部&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;table.insert (table, [pos,] value)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 指定table中所有正数key值中最大的key值。如果不存在key值为正数的元素, 则返回0。(Lua5.2之后该方法已经不存在了)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;table.maxn (table)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 默认删除最后一个元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;table.remove (table [, pos])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 默认升序&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;table.sort(table [, comp])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;手动实现 maxn ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; maxn(t)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (t) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; max_key = t[&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; k, v &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;in&lt;/span&gt; pairs(t) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; k &amp;gt; max_key &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				max_key = k
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; max_key
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们使用&lt;code&gt;#&lt;/code&gt;时，如果索引不是连续的，则不会返回真正的表长度，因此我们可以自己实现一个函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; table.len(t)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; len = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; k, v &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;in&lt;/span&gt; pairs(t) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		len = len + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; len
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;模块与包&#34;&gt;模块与包&lt;/h2&gt;
&lt;h3 id=&#34;lua-包&#34;&gt;Lua 包&lt;/h3&gt;
&lt;p&gt;Lua 中的模块是一个由变量、函数等已知元素组成的表，只需要最后将这个 table 返回即可创建一个模块。&lt;/p&gt;
&lt;p&gt;文件格式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# filename module.lua
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;module = {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;module.const_var = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;114514&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; module.func()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	do_something
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- private function&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;function&lt;/span&gt; local_func()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	do_something
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; module
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以使用 require 函数来加载模块：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;require(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;module_name&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- or&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;require &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;module_name&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以给加载的模块定义一个别名，方便调用（本质是又创建了一个引用）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;-- 使用局部变量避免污染命名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; m = require(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;module&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数 require 有自己的文件路径加载策略，会尝试从 Lua 文件或者 C 程序库中加载模块。&lt;/p&gt;
&lt;p&gt;可以搜到的 Lua 文件的路径存放于全局变量 package.path 之中，Lua 解释器启动时会使用系统环境变量 LUA_PATH 来初始化。&lt;/p&gt;
&lt;p&gt;可以像这样将路径加入环境变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;#LUA_PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;export&lt;/span&gt; LUA_PATH=&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;~/lua/?.lua;;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;c-包&#34;&gt;C 包&lt;/h3&gt;
&lt;p&gt;C 包在使用之前一定要加载并且链接：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; path = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;/usr/local/lua/lib/libluasocket.so&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; f = loadlib(path, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;luaopen_socket&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; path = &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;/usr/local/lua/lib/libluasocket.so&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;local&lt;/span&gt; f = assert(loadlib(path, &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;luaopen_socket&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;f()  &lt;span style=&#34;color:#007f7f&#34;&gt;-- 真正打开库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>一些Vim使用技巧（持续更新）</title>
      <link>https://vaaandark.top/posts/vim-practice/</link>
      <pubDate>Sun, 20 Feb 2022 10:53:42 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/vim-practice/</guid>
      <description>&lt;p&gt;最近翻看了一下 &lt;strong&gt;《Vim使用技巧》&lt;/strong&gt; 这本书，然后就发现我对 &lt;strong&gt;Vim&lt;/strong&gt; 快捷键的了解很不深入。不过即使如此，我日常使用 &lt;strong&gt;Vim&lt;/strong&gt; 写代码的效率也高于使用其他编辑器了，足见 &lt;strong&gt;Vim&lt;/strong&gt; 模式之奇。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;实用的命令&#34;&gt;实用的命令&lt;/h2&gt;
&lt;h3 id=&#34;普通模式&#34;&gt;普通模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;code&gt;g&lt;/code&gt;加移动命令可以在屏幕行而不是实际行中移动。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;C-a&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;C-x&amp;gt;&lt;/code&gt;可以对数字进行加减，如果数字开头是&lt;code&gt;0&lt;/code&gt;则会被认为是八进制。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;该命令和大部分命令一样可以用数字在前修饰表示重复，比如加&lt;code&gt;100&lt;/code&gt;是&lt;code&gt;100&amp;lt;C-a&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;daw&lt;/code&gt;和&lt;code&gt;diw&lt;/code&gt;效果类似，但是&lt;code&gt;daw&lt;/code&gt;使用更多（&lt;code&gt;caw&lt;/code&gt;等同理），因为可以去除多余的空格。但在使用的时候还是看情况是否包括两边。&lt;/li&gt;
&lt;li&gt;行内查找既可以用&lt;code&gt;t&lt;/code&gt;也可以用&lt;code&gt;f&lt;/code&gt;，目的只是查找时明显使用&lt;code&gt;f&lt;/code&gt;更加符合直觉，但是在删除到指定位置的使用场景时，&lt;code&gt;dt&lt;/code&gt;保留查找字符的特点可以让我们输入一些在文本中多用于分割的字符用于定位，而不是费劲去看分号前面时什么字母。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;可以跳转到成对匹配的符号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插入模式&#34;&gt;插入模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有趣但是没啥大用的技巧，&lt;code&gt;&amp;lt;C-v&amp;gt;&lt;/code&gt;后接数字可以通过编码输入字符，如果数字以&lt;code&gt;u&lt;/code&gt;打头，就是十六进制，&lt;code&gt;&amp;lt;C-k&amp;gt;&lt;/code&gt;后接两个字符可以得到二合字母表示的字符。这个技巧在命令行模式中也存在。&lt;/li&gt;
&lt;li&gt;可以使用&lt;code&gt;&amp;lt;C-h&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;C-w&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;C-u&amp;gt;&lt;/code&gt;在插入模式中像终端一样删除，该技巧在命令行模式也成立。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;&amp;lt;C-r&amp;gt;&lt;/code&gt;加寄存器名实现在插入模式下快速粘贴。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;特殊的插入-普通模式（&lt;code&gt;&amp;lt;C-o&amp;gt;&lt;/code&gt;）：即执行一次普通模式命令然后马上进入插入模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;可视模式&#34;&gt;可视模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在按&lt;code&gt;v&lt;/code&gt;进入可视模式之后，通过&lt;code&gt;a&lt;/code&gt;或&lt;code&gt;i&lt;/code&gt;加上&lt;code&gt;&#39;&lt;/code&gt; &lt;code&gt;&amp;quot;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt;等成对匹配的符号，可以直接选中那对符号之间的部分（如果是&lt;code&gt;a&lt;/code&gt;则包括那对符号）。&lt;/li&gt;
&lt;li&gt;在普通模式下按下&lt;code&gt;gv&lt;/code&gt;可以选中上次高亮的部分。&lt;/li&gt;
&lt;li&gt;在可视模式下按下&lt;code&gt;o&lt;/code&gt;可以将光标切换到另外一段（比较常见的技巧，只是我之前不知道）。&lt;/li&gt;
&lt;li&gt;在块可视模式中可以对多行进行插入操作，这样可以不依赖插件实现快速注释和快速取消注释。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;命令行模式&#34;&gt;命令行模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;命令行命令的格式一般为&lt;code&gt;[range]+[command]+[args]([address])&lt;/code&gt;，作用范围和参数可选。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!&lt;/code&gt;后的命令由外部shell执行，可以结合读入到缓冲区（&lt;code&gt;read&lt;/code&gt; &lt;code&gt;r&lt;/code&gt;），从缓冲区写入（&lt;code&gt;write&lt;/code&gt; &lt;code&gt;w&lt;/code&gt;）达到一些很好的效果，如得到当前工作目录中的所有文件&lt;code&gt;r !ls ./&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;!&lt;/code&gt;前有一个范围时，情况就会有所不同，shell执行的外部命令的输出会被写回到缓冲区。可以利用这个特性实现对文本的排序&lt;code&gt;%!sort -n&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;表示当前编辑的文件路径，&lt;code&gt;%:h&lt;/code&gt;可以去掉当前文件路径的文件名，非常适合编辑同时编辑多个相对工作目录层级很深的文件时使用。当然，这个也是可以映射的（这里更像宏展开，我也不是很懂&lt;code&gt;vimscript&lt;/code&gt;）：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cnoremap &amp;lt;expr&amp;gt; %% getcmdtype() == &amp;#39;:&amp;#39; ? expand(&amp;#39;%:h&amp;#39;).&amp;#39;/&amp;#39; : &amp;#39;%%&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在表示范围时，&lt;code&gt;%&lt;/code&gt;表示整个文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:&lt;/code&gt;加行号实现跳转，这个方法其实实用性不高，不如在普通模式下使用行号加&amp;rsquo;G&amp;rsquo;。&lt;/li&gt;
&lt;li&gt;一些特殊标记：&lt;code&gt;&#39;m&lt;/code&gt; &lt;code&gt;&#39;&amp;lt;&lt;/code&gt; &lt;code&gt;&#39;&amp;gt;&lt;/code&gt;分别表示位置标记为&lt;code&gt;m&lt;/code&gt;的行，高亮选区的起始行和结束行。&lt;/li&gt;
&lt;li&gt;在命令行中用复制（&lt;code&gt;copy&lt;/code&gt; &lt;code&gt;t&lt;/code&gt;）、移动（&lt;code&gt;move&lt;/code&gt; &lt;code&gt;m&lt;/code&gt;）很多时候会更快。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normal&lt;/code&gt;命令可以实现在指定范围执行普通模式命令，在每次执行完之后自动退出插入模式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vim&lt;/strong&gt; 的命令行与shell不同，上下翻历史用的不是&lt;code&gt;&amp;lt;M-p&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;M-n&amp;gt;&lt;/code&gt;而是&lt;code&gt;&amp;lt;C-p&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;C-n&amp;gt;&lt;/code&gt;（老版本没有该特性需要自己绑定&lt;code&gt;cnoremap &amp;lt;C-p&amp;gt; &amp;lt;Up&amp;gt;&lt;/code&gt; &lt;code&gt;cnoremap &amp;lt;C-n&amp;gt; &amp;lt;Down&amp;gt;&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;配置了路径之后可以使用 &lt;strong&gt;Vim&lt;/strong&gt; 内建的&lt;code&gt;find&lt;/code&gt;命令，如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;:set path+={dirname/**}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;:find {filename}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;其他技巧&#34;&gt;其他技巧&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;清屏&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;strong&gt;Vim&lt;/strong&gt; 中也可以利用&lt;code&gt;&amp;lt;C-l&amp;gt;&lt;/code&gt;进行清屏，这个技巧在通过查找跳转时相当有用，因为高亮有时十分烦人。也有一劳永逸的方法，就是&lt;code&gt;set nohlsearch&lt;/code&gt;直接关闭查找高亮。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在配置文件中加入如下代码可以在打开文件时光标处于上次的更新位置：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;autocmd BufReadPost * if line(&amp;#34;&amp;#39;\&amp;#34;&amp;#39;&amp;#34;) &amp;gt; 1 &amp;amp;&amp;amp; line(&amp;#34;&amp;#39;\&amp;#39;&amp;#34;) &amp;lt;= line(&amp;#34;$&amp;#34;) | exe &amp;#34;normal! g&amp;#39;\&amp;#34;&amp;#34; | endif
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码保存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果使用的是 &lt;strong&gt;Vim&lt;/strong&gt; ，想要以超级用户权限保存文件，可以在使用命令&lt;code&gt;w !sudo tee % &amp;gt; /dev/null&lt;/code&gt;，即将缓冲区通过&lt;code&gt;tee&lt;/code&gt;命令输入到当前文件中，并将标准输出抛弃。可以绑定为：&lt;code&gt;cmap w!! w !sudo tee % &amp;gt; /dev/null&lt;/code&gt;。如果使用的是 &lt;strong&gt;NeoVim&lt;/strong&gt; ，则很遗憾不能使用这个小技巧，可以使用插件 &lt;a href=&#34;https://github.com/lambdalisue/suda.vim&#34;&gt;&lt;strong&gt;Suda.vim&lt;/strong&gt;&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果想要保存到一个不存在的目录，可以利用外部命令加上&lt;code&gt;%:h&lt;/code&gt;的特性，如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;:!mkdir -p %:h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;:w
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓冲区&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多缓冲区编辑时用&lt;code&gt;:bprevious&lt;/code&gt; &lt;code&gt;:bnext&lt;/code&gt;命令切换文件比较麻烦可以绑定为：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nnoremap &amp;lt;silent&amp;gt; [b :bprevious&amp;lt;CR&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nnoremap &amp;lt;silent&amp;gt; ]b :bnext&amp;lt;CR&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nnoremap &amp;lt;silent&amp;gt; [B :bfirst&amp;lt;CR&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nnoremap &amp;lt;silent&amp;gt; ]B :blast&amp;lt;CR&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在缓冲区进入轮换，即&lt;code&gt;:ls&lt;/code&gt;时文件名前有井号时，才可以使用&lt;code&gt;&amp;lt;C-^&amp;gt;&lt;/code&gt;快速切换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:argdo&lt;/code&gt;和&lt;code&gt;:bufdo&lt;/code&gt;命令可以对多缓冲区进行操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标签页和窗口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相比与使用多缓冲区，使用标签页和窗口更加直观且易于操作，可以达到类似于使用虚拟桌面的效果。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:sp[lit] {file}&lt;/code&gt;水平分隔窗口，&lt;code&gt;:vs[plit] {file}&lt;/code&gt;垂直分割，这两个用的比较多；而对于同一个文件的分屏&lt;code&gt;&amp;lt;C-w&amp;gt;s&lt;/code&gt;和&lt;code&gt;&amp;lt;C-w&amp;gt;v&lt;/code&gt;就可能用得比较少了。&lt;/li&gt;
&lt;li&gt;在窗口间切换的命令，前缀全部为&lt;code&gt;&amp;lt;C-w&amp;gt;&lt;/code&gt;，加上方向&lt;code&gt;hjkl&lt;/code&gt;就是按方向的切换，加上&lt;code&gt;w&lt;/code&gt;就是循环切换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:tabe[dit] {filename}&lt;/code&gt;在新标签页打开，&lt;code&gt;&amp;lt;C-w&amp;gt;T&lt;/code&gt;把当前窗口移到新标签页，&lt;code&gt;tabc[lose]&lt;/code&gt;关闭当前标签页及其全部窗口，&lt;code&gt;tabo[nly]&lt;/code&gt;只保持当前标签页。&lt;/li&gt;
&lt;li&gt;普通模式下&lt;code&gt;{N}gt&lt;/code&gt;切换到标号为&lt;code&gt;N&lt;/code&gt;的标签页，如果没有&lt;code&gt;N&lt;/code&gt;则是切换到上一个，&lt;code&gt;gT&lt;/code&gt;是切换到下一个。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置标记&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以通过&lt;code&gt;m{a-zA-Z}&lt;/code&gt;标记光标所在位置，小写是当前缓冲区可见，大写是全局可见。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;&#39;{mark}&lt;/code&gt;跳转到标记的那一行第一个非空白字符，&lt;code&gt; `{mark}&lt;/code&gt;跳转到标记的准确位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;提高编辑效率的思路&#34;&gt;提高编辑效率的思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;注意一些成对的命令的使用选择，如正向还是反向、到目标位置还是到目标位置之前，虽然每次不会节约太多时间，但毕竟积少成多。&lt;/li&gt;
&lt;li&gt;多构造能够通过&lt;code&gt;.&lt;/code&gt;来重复的编辑，这需要我们注意每次编辑后光标的位置，如果使用宏也是相同的道理。&lt;/li&gt;
&lt;li&gt;能够重复就别用次数（为了撤销时能够当作整体）:例如&lt;code&gt;d3w&lt;/code&gt;和&lt;code&gt;2dw&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在适当的时候回到普通模式，让每一次的编辑更在逻辑上更连贯（同样是方便撤销和重复）。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>gitignore文件如何书写</title>
      <link>https://vaaandark.top/posts/how-to-write-gitignore/</link>
      <pubDate>Tue, 08 Feb 2022 13:32:19 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/how-to-write-gitignore/</guid>
      <description>&lt;p&gt;之前使用&lt;code&gt;git&lt;/code&gt;基本只是把它当作提交到 &lt;strong&gt;GitHub&lt;/strong&gt; 上的工具，最多使用到的功能就是恢复误删的文件而已。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;在我之前的&lt;code&gt;git&lt;/code&gt;命令使用之中，基本上用的就是&lt;code&gt;git clone&lt;/code&gt;、&lt;code&gt;git add .&lt;/code&gt;、&lt;code&gt;git commit -m&lt;/code&gt;以及&lt;code&gt;git commit push&lt;/code&gt;。由于基本上是无脑&lt;code&gt;add&lt;/code&gt;，因此&lt;code&gt;.gitigore&lt;/code&gt;的文件书写比较重要。&lt;/p&gt;
&lt;p&gt;最近想复习并实践一下&lt;code&gt;git&lt;/code&gt;的操作，在翻看&lt;code&gt;git&lt;/code&gt;的文档时，发现&lt;code&gt;.gitigore&lt;/code&gt;文件并没有我想象的那么简单。&lt;/p&gt;
&lt;p&gt;可以先设想几个情景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个子目录里面的&lt;code&gt;tmp&lt;/code&gt;文件夹都不加入到&lt;code&gt;git&lt;/code&gt;的版本控制中&lt;/li&gt;
&lt;li&gt;只有根目录下的&lt;code&gt;tmp&lt;/code&gt;文件夹不加入&lt;/li&gt;
&lt;li&gt;所有的&lt;code&gt;tmp&lt;/code&gt;文件夹，除了&lt;code&gt;a/b/tmp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;忽略&lt;code&gt;a&lt;/code&gt;目录下所有的&lt;code&gt;pdf&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;忽略&lt;code&gt;a&lt;/code&gt;目录下及其子目录下所有的&lt;code&gt;pdf&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;忽略指定文件之外的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在解决这些问题之前，我先了解了一下&lt;code&gt;gitignore&lt;/code&gt;的语法设计。它被称为 &lt;strong&gt;glob&lt;/strong&gt; 模式，也就是&lt;code&gt;shell&lt;/code&gt;中使用到的简化了的正则表达式，因此掌握它是没有什么难度的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 忽略所有的 .a 文件
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;*.a
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;!lib.a
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 只忽略当前目录下的 tmp 文件夹，而不忽略子目录中的 tmp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/tmp/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 忽略任何目录下名为 tmp 的文件夹
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tmp/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 忽略 doc 目录下的 pdf 文件，但不忽略 doc 子目录中的 pdf 文件
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;doc/*.pdf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;doc/**/*.pdf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>CSAPP Data Lab</title>
      <link>https://vaaandark.top/posts/csapp-data-lab/</link>
      <pubDate>Wed, 02 Feb 2022 13:06:25 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/csapp-data-lab/</guid>
      <description>&lt;p&gt;最近本来在看 &lt;em&gt;&lt;strong&gt;CSAPP&lt;/strong&gt;&lt;/em&gt; 后面的内容，但突然发现自己前面可能还有一些知识掌握不完全，因此做一下 Lab 检验一下。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;准备工作&#34;&gt;准备工作&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;在 CSAPP 的官网上找到 Lab，下载 Self-Study Handout。&lt;/li&gt;
&lt;li&gt;在下载目录下解压文件&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tar -xf datalab-handout.tar
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;尝试执行自动测评脚本&lt;code&gt;driver.pl&lt;/code&gt;结果发现没有32位环境，于是用&lt;code&gt;dnf&lt;/code&gt;安装需要的库，折腾了一会发现还是不太行。请教了大佬 &lt;a href=&#34;https://www.cnblogs.com/jyi2ya&#34;&gt;&lt;strong&gt;jyi2ya&lt;/strong&gt;&lt;/a&gt;，他告诉我可以直接在&lt;code&gt;makefile&lt;/code&gt;里面把编译条件改为&lt;code&gt;-m64&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;题目与题解&#34;&gt;题目与题解&lt;/h1&gt;
&lt;h2 id=&#34;int-部分&#34;&gt;int 部分&lt;/h2&gt;
&lt;h3 id=&#34;bitxor&#34;&gt;bitXor&lt;/h3&gt;
&lt;p&gt;只用&lt;code&gt;~&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;实现&lt;code&gt;^&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以使用&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B&#34;&gt;&lt;strong&gt;德摩根定理&lt;/strong&gt;&lt;/a&gt;秒杀。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; bitXor(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; y) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; ~(~(~x &amp;amp; y) &amp;amp; ~(x &amp;amp; ~y));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;tmin&#34;&gt;tmin&lt;/h3&gt;
&lt;p&gt;使用位运算获取补码的最小值&lt;/p&gt;
&lt;p&gt;由于题目已经告诉了我们机器环境，我们可以认为&lt;code&gt;int&lt;/code&gt;类型是占八个字节。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; tmin(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;31&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;istmax&#34;&gt;isTmax&lt;/h3&gt;
&lt;p&gt;使用位运算获取判断是否是补码的最大值&lt;/p&gt;
&lt;p&gt;这题相较上题有一定的技巧。主要思路为把补码的每一位变为1，这样就可以很方便地得到0或非0的值。在转换的过程中要注意到-1同样适用，所以要对-1进行特判。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; isTmax(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// 如果是0b111...111或者0b011...111就能变为0b000...000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; check = ~(x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; + x);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// 如果是-1则结果为1，排除掉
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; except = !(x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; !(check | except);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;alloddbits&#34;&gt;allOddBits&lt;/h3&gt;
&lt;p&gt;判断所有奇数位是否都为1&lt;/p&gt;
&lt;p&gt;一开始的想法是直接暴力判断每个奇数位是否为1（先移位然后进行逻辑与运算），但是这样应该得不到性能分。于是我想到了类似于二分法的思想，每次对半比较，最后只需要七次操作捏。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; allOddBits(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x &amp;amp;= (x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;16&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x &amp;amp;= (x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; !(x &amp;amp; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0xaa&lt;/span&gt; ^ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0xaa&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;negate&#34;&gt;negate&lt;/h3&gt;
&lt;p&gt;不使用&lt;code&gt;-&lt;/code&gt;操作符，求&lt;code&gt;-x&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;运用补码的基础知识得到答案。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; negate(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; (~x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;isasciidigit&#34;&gt;isAsciiDigit&lt;/h3&gt;
&lt;p&gt;计算输入值是否是数字&lt;code&gt;0-9&lt;/code&gt;的 &lt;strong&gt;ASCII&lt;/strong&gt; 值。&lt;/p&gt;
&lt;p&gt;一开始打算先判断前多少多少位是不是0，后面是否满足&lt;code&gt;0x30 &amp;lt;= x &amp;lt;= 0x39&lt;/code&gt;，后来一想发现这样好复杂，可以直接通过范围判断。&lt;/p&gt;
&lt;p&gt;可以使用一个小技巧，这个技巧也可以优化分支预测。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (x &amp;gt;= a &amp;amp;&amp;amp; x &amp;lt;= b) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  do_something();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// 等价于
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; ((x - a) | (b - x) &amp;gt;= ) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  do_something();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里不能使用&lt;code&gt;-&lt;/code&gt;，但是可以利用前面题目的结论，通过取反和加法代替减法。&lt;/p&gt;
&lt;p&gt;于是我们得到了答案：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; isAsciiDigit(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; !(((x + (~&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x30&lt;/span&gt; + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;)) | ((~x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;) + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x39&lt;/span&gt;)) &amp;amp; (&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;31&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;conditional&#34;&gt;conditional&lt;/h3&gt;
&lt;p&gt;通过位运算模拟三目运算&lt;/p&gt;
&lt;p&gt;不难想到：一个数和&lt;code&gt;0x0&lt;/code&gt;进行逻辑与操作的结果是&lt;code&gt;0x0&lt;/code&gt;，一个数和&lt;code&gt;~0x0&lt;/code&gt;进行逻辑与操作的结果是本身。因此我们可以构造一个与&lt;code&gt;x&lt;/code&gt;有关的掩码，当x为真时就是&lt;code&gt;0xffffffff&lt;/code&gt;，否则为&lt;code&gt;0x0&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; conditional(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; y, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; z) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; mask = !x + (~&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  y &amp;amp;= mask;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  z &amp;amp;= ~mask;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; y | z;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;islessorequal&#34;&gt;isLessOrEqual&lt;/h3&gt;
&lt;p&gt;通过位运算模拟小于等于&lt;/p&gt;
&lt;p&gt;将两个数移到一边变为减法运算，再把减法运算变为加上绝对值的加法运算，最后判断最高位是否为0即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; isLessOrEqual(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; y) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; !(y + (~x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;) &amp;amp; (&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;31&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果这个代码被朋友叉掉了，因为我没有考虑到溢出的情况，所以要加上对一个是正数一个是负数的特判。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; isLessOrEqual(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; y) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; (((x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;31&lt;/span&gt;) &amp;amp; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;) | (!(y &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;31&lt;/span&gt;))) &amp;amp; !(y + (~x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;) &amp;amp; (&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;31&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;logicalneg&#34;&gt;logicalNeg&lt;/h3&gt;
&lt;p&gt;通过位运算模拟逻辑非&lt;/p&gt;
&lt;p&gt;我很自然地想到了这样的代码，结果发现没有拿到性能分，刚好比要求多一个操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; logicalNeg(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x ^= ~&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x &amp;amp;= (x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;16&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x &amp;amp;= (x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x &amp;amp;= (x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x &amp;amp;= (x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x &amp;amp;= (x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; x &amp;amp; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;于是我分析这段垃圾代码，发现&lt;code&gt;x ^= ~0&lt;/code&gt;就占用了两步操作，而且有更好的替代方法。&lt;/p&gt;
&lt;p&gt;依然使用类似二分法的思想，同时以使用或操作为主，就能节约操作了。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; logicalNeg(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x |= (x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;16&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x |= (x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x |= (x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x |= (x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x |= (x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; x &amp;amp; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; ^ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;howmanybits&#34;&gt;howManyBits&lt;/h3&gt;
&lt;p&gt;求最少用多少个位可以表示出给定数字&lt;/p&gt;
&lt;p&gt;刚开始做这题时，我看着题目的例子搞不懂为啥&lt;code&gt;-1&lt;/code&gt;只需要一位。最后我的理解就是，题目想问的是“最少用多少个位可以表示从0到给定的数字”，因此如果给出负数我们就不需要考虑正数，反之同理。&lt;/p&gt;
&lt;p&gt;所以这道题转化为了求 $log_2x$ 。&lt;/p&gt;
&lt;p&gt;还是可以将用类似二分的思想解题。首先判断前16位是否有1，如果有就要加上16，同时下一次的移位要多移动16位，依此类推。每次加上的权不同，代表这次判断的一共有&lt;code&gt;n&lt;/code&gt;位（16、8、4、2、1）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; howManyBits(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; mask, b16, b8, b4, b2, b1, b0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  mask = x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;31&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x = (mask &amp;amp; ~x) | (~mask &amp;amp; x);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  b16 = !!(x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;16&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x = x &amp;gt;&amp;gt; b16;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  b8 = !!(x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x = x &amp;gt;&amp;gt; b8;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  b4 = !!(x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x = x &amp;gt;&amp;gt; b4;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  b2 = !!(x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x = x &amp;gt;&amp;gt; b2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  b1 = !!(x &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x = x &amp;gt;&amp;gt; b1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  b0 = x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; b16 + b8 + b4 + b2 + b1 + b0 + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;float-部分&#34;&gt;float 部分&lt;/h2&gt;
&lt;p&gt;浮点数的题目比较简单，只考察其结构而不是运算。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了位运算方便，题目中给出的函数参数和返回值都是与&lt;code&gt;float&lt;/code&gt;长度相同的&lt;code&gt;unsigned int&lt;/code&gt;或者&lt;code&gt;int&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;floatscale2&#34;&gt;floatScale2&lt;/h3&gt;
&lt;p&gt;求一个浮点数乘2&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先取出符号&lt;code&gt;sign&lt;/code&gt;、尾数&lt;code&gt;frac&lt;/code&gt;、阶码&lt;code&gt;exp&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果阶码是0，说明是一个非规格化的浮点数，由于浮点数的分规格化到规格化的过渡是连续的，因此尾数向左移动一位变成规格化浮点数不是特殊情况。&lt;/li&gt;
&lt;li&gt;如果阶码全为1，说明是无穷大，直接原样返回即可。&lt;/li&gt;
&lt;li&gt;给阶码加上1，即是给变量&lt;code&gt;exp&lt;/code&gt;加上&lt;code&gt;0x800000&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果溢出了变为无穷大，就要将尾数变为0，否则就是&lt;code&gt;NaN&lt;/code&gt;了。&lt;/li&gt;
&lt;li&gt;将三部分拼接后返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; floatScale2(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; uf) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; sign = uf &amp;amp; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x80000000&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; exp = uf &amp;amp; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x7f800000&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; frac = uf &amp;amp; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x007fffff&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (exp == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; sign | uf &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (exp == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x7f800000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; uf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  exp += &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x00800000&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (exp == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x7f800000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    frac = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; sign | exp | frac;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;floatfloat2int&#34;&gt;floatFloat2Int&lt;/h3&gt;
&lt;p&gt;将一个浮点数转换为整型数&lt;/p&gt;
&lt;p&gt;在 &lt;em&gt;&lt;strong&gt;CSAPP&lt;/strong&gt;&lt;/em&gt; 中介绍过几种舍入的方法，在计算中向偶数（奇数）位舍入会减小误差，而在类型转换中，使用向零舍入会比较方便。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先将符号、尾数、阶码取出来，为了加减法计算方便，对阶码进行了移位，并加上了127。&lt;/li&gt;
&lt;li&gt;尾数的第24位置为1，因为在规格化数中就是&lt;code&gt;1.x&lt;/code&gt;的形式。而非规格化数舍入变为0，不需要考虑其尾数。&lt;/li&gt;
&lt;li&gt;如果阶小于0，直接返回0。&lt;/li&gt;
&lt;li&gt;如果阶大于31，说明是无穷大。&lt;/li&gt;
&lt;li&gt;其余情况就是对加上&lt;code&gt;1.x&lt;/code&gt;（&lt;code&gt;x&lt;/code&gt;为尾数）进行移位，由于尾数长24位，因此有方向和绝对值要注意。&lt;/li&gt;
&lt;li&gt;带上符号后返回答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; floatFloat2Int(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; uf) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; ans;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; sign = uf &amp;amp; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x80000000&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; exp = ((uf &amp;gt;&amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;23&lt;/span&gt;) &amp;amp; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0xff&lt;/span&gt;) -&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;127&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; frac = (uf &amp;amp; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x007fffff&lt;/span&gt;) | &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x00800000&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (exp &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (exp &amp;gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;31&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x80000000&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (exp &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;23&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ans = frac &amp;gt;&amp;gt; (&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;23&lt;/span&gt; - exp);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ans = frac &amp;lt;&amp;lt; (exp - &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;23&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; sign ? ~ans + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; : ans;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;floatpower2&#34;&gt;floatPower2&lt;/h3&gt;
&lt;p&gt;求$2.0^x$&lt;/p&gt;
&lt;p&gt;利用一个结论：最小的非规格化数是 $2^{-23}*2^{-126}$ ，最大的非规格化数是 $(1-u)*2^{-126}$ ，最小的规格化数是 $2^{-126}$ ，最大规格化数是 $(2-u)*2^{127}$，其中 $u$ 为无穷小。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; floatPower2(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (x &amp;lt; -&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;149&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (x &amp;lt; -&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;126&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;149&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (x &amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;128&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; x + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;127&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;23&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0xff&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;23&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;测评结果&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Correctness Results	Perf Results
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Points	Rating	Errors	Points	Ops	Puzzle
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1	1	0	2	8	bitXor
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1	1	0	2	1	tmin
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1	1	0	2	7	isTmax
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2	2	0	2	7	allOddBits
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2	2	0	2	2	negate
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3	3	0	2	10	isAsciiDigit
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3	3	0	2	8	conditional
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3	3	0	2	6	isLessOrEqual
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4	4	0	2	12	logicalNeg
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4	4	0	2	36	howManyBits
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4	4	0	2	11	floatScale2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4	4	0	2	15	floatFloat2Int
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4	4	0	2	10	floatPower2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Score = 62/62 [36/36 Corr + 26/26 Perf] (&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;133&lt;/span&gt; total operators)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;做了 &lt;em&gt;&lt;strong&gt;CSAPP&lt;/strong&gt;&lt;/em&gt; 的 &lt;strong&gt;Data Lab&lt;/strong&gt; 还是收获良多的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发现自己之前学习的位运算和浮点数的知识还有不少漏洞，幸好补起来了。&lt;/li&gt;
&lt;li&gt;在做这种限制操作的题目时，一开始还是会感觉很不适应，疯狂地想写分支判断等操作。坚持下来之后就有不小的提高，对抽象能力和写更高性能的代码都有帮助。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lab&lt;/strong&gt; 中给出的&lt;code&gt;makefile&lt;/code&gt;开的编译选项给我报了很多警告，让我发现我的代码习惯不是很好，还有很大进步空间。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>斐波那契堆</title>
      <link>https://vaaandark.top/posts/fibonacci-heap/</link>
      <pubDate>Mon, 31 Jan 2022 12:51:49 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/fibonacci-heap/</guid>
      <description>&lt;p&gt;联创 Lab 组新人任务第一弹。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;关于斐波那契堆&#34;&gt;关于斐波那契堆&lt;/h2&gt;
&lt;h3 id=&#34;结构与特点&#34;&gt;结构与特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。&lt;/li&gt;
&lt;li&gt;斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。&lt;/li&gt;
&lt;li&gt;斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。&lt;/li&gt;
&lt;li&gt;使用一个指针指向斐波那契堆中最小元素。
斐波那契堆将操作尽可能地延后，它的插入是懒惰的，只有在不得不进行合并操作时才进行合并。在极端情况下，它甚至是一个长度很大的链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插入操作&#34;&gt;插入操作&lt;/h3&gt;
&lt;p&gt;将一个节点直接插入到根链表中，并比较键值的大小，如果新节点的键值小于原有节点的键值，就将斐波那契堆的指向最小节点的指针指向它。&lt;/p&gt;
&lt;h3 id=&#34;删除最小节点操作&#34;&gt;删除最小节点操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;先将最小节点的儿子插入到根链表中，再删除掉这个目标节点。再遍历根链表，合并所有根节点是相同度数的堆。&lt;/li&gt;
&lt;li&gt;由于本次实现不需要实现对节点键值的改变或者根据键值删除节点，因此这里的斐波那契堆可以进行一定程度的简化：不再需要指向父亲节点的指针，也不需要第一个儿子是否被删除的标记。由于不需要维护指向父亲的指针，在将儿子们合并到根链表时的操作也可以简化，直接将两个链表合并即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实现斐波那契堆&#34;&gt;实现斐波那契堆&lt;/h2&gt;
&lt;h3 id=&#34;代码文件&#34;&gt;代码文件&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/vaaandark/MyPriorityQueue&#34;&gt;https://github.com/vaaandark/MyPriorityQueue&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;文件结构&#34;&gt;文件结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;generator文件夹内有文件generator.c，用于生成测试数据。&lt;/li&gt;
&lt;li&gt;STLPriorityQueue文件夹内有文件stl_priority_queue.cpp，用STL中的Priority Queue编写，用于对照实验。&lt;/li&gt;
&lt;li&gt;src中为基于Fibonacci Heap的Priority Queue的具体实现。&lt;/li&gt;
&lt;li&gt;脚本test.sh用于自动化测试，可以使用可选参数clean，用于清理之前测试出现的非代码文件。&lt;/li&gt;
&lt;li&gt;src_cpp为Set的C++实现。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>左偏红黑树</title>
      <link>https://vaaandark.top/posts/llrb/</link>
      <pubDate>Mon, 31 Jan 2022 12:51:39 +0000</pubDate>
      
      <guid>https://vaaandark.top/posts/llrb/</guid>
      <description>&lt;p&gt;联创 Lab 组新人任务第一弹。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;关于llrb&#34;&gt;关于LLRB&lt;/h2&gt;
&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;根节点是黑色的。&lt;/li&gt;
&lt;li&gt;红色节点的儿子一定是黑色的。&lt;/li&gt;
&lt;li&gt;任意节点到任意叶子的最短路径上都有相同数量的黑色节点。&lt;/li&gt;
&lt;li&gt;黑色节点的儿子要么全是黑色，要么只有左儿子是黑色。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;前三点与红黑树的性质相同，第四点为左偏红黑树的特殊性质，这导致了它的操作相对红黑树更加简单。&lt;/li&gt;
&lt;li&gt;左偏红黑树也可以认为其相邻节点的边是有颜色的。&lt;/li&gt;
&lt;li&gt;空节点的颜色认为是黑色。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插入操作&#34;&gt;插入操作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;可以先就像向二叉查找树中插入节点一样操作，插入时将其颜色赋为红色。如果插入时是黑色，这会导致破坏了LLRB的平衡性质。&lt;/li&gt;
&lt;li&gt;保持住了黑色平衡性质之后再来调整其他结构性质，要对连续两个红色节点、只有右儿子是红色节点进行旋转，对左右儿子都是红色的节点进行颜色翻转（拆分2-3-4树中的4-node）。&lt;/li&gt;
&lt;li&gt;其操作可以是递归的，编写代码也将更加容易实现。
优先保持平衡性质的原因有：在一开始插入时保持平衡性质最容易实现（只需要给新节点赋红色），此时若优先考虑其他性质，会导致需要考虑的情况过多，而且在后续进行修补（旋转、颜色翻转）的时候不会破坏其平衡性质。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;删除操作&#34;&gt;删除操作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;依然优先考虑其平衡性质，删除的节点需要是红色的，因此思路就是先将需要删除的节点变成红色的。&lt;/li&gt;
&lt;li&gt;此时需要考虑的是，如何将红色节点向下移动（向左下或右下）。当左右儿子都不是红色时也不用担心，可以通过颜色翻转实现，翻转后需要考虑移动的另一个方向是否会出现不满足左倾红黑树的情况，并对其进行修补。&lt;/li&gt;
&lt;li&gt;由于LLRB的左偏特性，因此会出现想要向右下移动时，左儿子是红色而右儿子是黑色，因此需要对该节点进行右旋，让向右下的路径上出现红色。&lt;/li&gt;
&lt;li&gt;当找到删除的目标节点后，如果是一个叶子节点，直接删去，如果是一个内部节点，便从它的右儿子的分支中找到最小节点与之替换，再删掉。&lt;/li&gt;
&lt;li&gt;在向上返回的途中修补节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt; 中判断是否为叶子节点不应该用它是否有左儿子来判断，而是用它是否有右儿子来判断，因为在前一步中有右旋操作。&lt;/p&gt;
&lt;h2 id=&#34;实现llrb&#34;&gt;实现LLRB&lt;/h2&gt;
&lt;h3 id=&#34;代码文件&#34;&gt;代码文件&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/vaaandark/MySet&#34;&gt;https://github.com/vaaandark/MySet&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;文件结构&#34;&gt;文件结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;generator文件夹内有文件generator.c，用于生成测试数据。&lt;/li&gt;
&lt;li&gt;STLSet文件夹内有文件stl_set.cpp，STL中的Set编写，用于对照实验。&lt;/li&gt;
&lt;li&gt;src中为基于LLRB Tree的Set的具体实现。&lt;/li&gt;
&lt;li&gt;脚本test.sh用于自动化测试，可以使用可选参数clean，用于清理之前测试出现的非代码文件。&lt;/li&gt;
&lt;li&gt;src_cpp为Set的C++实现。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
