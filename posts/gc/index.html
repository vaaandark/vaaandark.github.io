<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>垃圾回收 | vaaandark&#39;s blog</title>
<meta name="keywords" content="编译原理, Lua, Lisp, 数据结构, GC">
<meta name="description" content="之前学习了 Lua 的 Table 和协程，对 Lua 中另一个重要模块 GC 还有很多疑问，这次就来学习一下。

GC 简介与策略分类
在计算机科学中，垃圾收集(GC)是一种自动内存管理形式。垃圾收集器尝试回收程序分配但不再引用的内存；这样的内存被称为垃圾。">
<meta name="author" content="vaaandark">
<link rel="canonical" href="https://vaaandark.top/posts/gc/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.556a50c7c92c2556e588f602528ac3c41884cdb6e537ce0647b5e200cd1c2094.css" integrity="sha256-VWpQx8ksJVbliPYCUorDxBiEzbblN84GR7XiAM0cIJQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://vaaandark.top/image/vaaandark.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://vaaandark.top/image/vaaandark.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://vaaandark.top/image/vaaandark.png">
<link rel="apple-touch-icon" href="https://vaaandark.top/image/vaaandark.png">
<link rel="mask-icon" href="https://vaaandark.top/image/vaaandark.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://vaaandark.top/posts/gc/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://vaaandark.top/posts/gc/">
  <meta property="og:site_name" content="vaaandark&#39;s blog">
  <meta property="og:title" content="垃圾回收">
  <meta property="og:description" content="之前学习了 Lua 的 Table 和协程，对 Lua 中另一个重要模块 GC 还有很多疑问，这次就来学习一下。
GC 简介与策略分类 在计算机科学中，垃圾收集(GC)是一种自动内存管理形式。垃圾收集器尝试回收程序分配但不再引用的内存；这样的内存被称为垃圾。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-09-17T11:27:19+00:00">
    <meta property="article:modified_time" content="2022-09-17T11:27:19+00:00">
    <meta property="article:tag" content="编译原理">
    <meta property="article:tag" content="Lua">
    <meta property="article:tag" content="Lisp">
    <meta property="article:tag" content="数据结构">
    <meta property="article:tag" content="GC">
    <meta property="og:image" content="https://vaaandark.top/image/gc.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://vaaandark.top/image/gc.png">
<meta name="twitter:title" content="垃圾回收">
<meta name="twitter:description" content="之前学习了 Lua 的 Table 和协程，对 Lua 中另一个重要模块 GC 还有很多疑问，这次就来学习一下。

GC 简介与策略分类
在计算机科学中，垃圾收集(GC)是一种自动内存管理形式。垃圾收集器尝试回收程序分配但不再引用的内存；这样的内存被称为垃圾。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://vaaandark.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "垃圾回收",
      "item": "https://vaaandark.top/posts/gc/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "垃圾回收",
  "name": "垃圾回收",
  "description": "之前学习了 Lua 的 Table 和协程，对 Lua 中另一个重要模块 GC 还有很多疑问，这次就来学习一下。\nGC 简介与策略分类 在计算机科学中，垃圾收集(GC)是一种自动内存管理形式。垃圾收集器尝试回收程序分配但不再引用的内存；这样的内存被称为垃圾。\n",
  "keywords": [
    "编译原理", "Lua", "Lisp", "数据结构", "GC"
  ],
  "articleBody": "之前学习了 Lua 的 Table 和协程，对 Lua 中另一个重要模块 GC 还有很多疑问，这次就来学习一下。\nGC 简介与策略分类 在计算机科学中，垃圾收集(GC)是一种自动内存管理形式。垃圾收集器尝试回收程序分配但不再引用的内存；这样的内存被称为垃圾。\n追踪(Tracing) Tracing 的策略简单讲就是使用一些根对象来遍历所有的引用，可以访问到的就不是垃圾，不能访问到的就是需要回收的垃圾。虽然这个说起来和实现起来很简单，但是想要使其有较好的性能并不是一件很容易的事情。Tracing 有很多需要考虑的问题，例如收集的周期(步进 Pace)是什么，是按照时间片还是按照已经分配过的内存，是否会出现为了收集垃圾程序执行出现明显卡死现象等。\n之后用到的 Lisp 和 Lua 的例子都以 Tracing 策略为主。\n引用计数(Reference counting) 引用计数垃圾收集是每个对象都有一个对它的引用数的计数。垃圾通过引用计数为零来标识。对象的引用计数在创建对它的引用时增加，在引用被销毁时减少。当计数达到零时，对象的内存被回收。\n循环引用 如果有两个对象相互引用，就会导致它们的引用计数永远大于等于 1 ，它们永远不会被回收。对于这个问题，一般有两种解决方案。一种比较直观，直接检测是否出现循环，cpython 就使用的这种方法；另一种就是引入弱引用的概念。\n弱引用不会增加引用计数，而且指向的对象可能是已经被回收的，因此可以简单地检测出是否失效，而不是保持引用悬垂。\n额外空间开销 明显地，如果使用引用计数的策略就需要额外的空间来存储计数。有的是存在对象中，有的是存在一个表之中。在一些语言例如 objective-c 中，它们将引用计数存在指针地址未使用的位当中（我认为这对不同处理器间可移植性有影响）。\n额外时间开销 例如如果使用for item in something的方法遍历，在每个循环开始都有rc++每个结尾都有rc--，优秀的 GC 应该把这个消除掉。\n并行 如果需要编写并行代码则需让 rc 的操作具有原子性，最重要的一点是它们不可以是全局变量了。\n自动引用计数(Automatic Reference counting) 自动引用计数无需运行时，会在编译阶段处理引用计数并实现内存管理，但是难以处理循环引用的问题。神奇的 Rust 较好地解决了这个问题，方法还是使用弱引用，可以看 Arc 的实现：\nBreaking cycles with Weak\nThe downgrade method can be used to create a non-owning Weak pointer. A Weak pointer can be upgraded to an Arc, but this will return None if the value stored in the allocation has already been dropped. In other words, Weak pointers do not keep the value inside the allocation alive; however, they do keep the allocation (the backing store for the value) alive.\nA cycle between Arc pointers will never be deallocated. For this reason, Weak is used to break cycles. For example, a tree could have strong Arc pointers from parent nodes to children, and Weak pointers from children back to their parents.\n不过，无论是朴素的引用计数还是自动引用计数，一旦引入弱引用就可能增加代码编写者的心智负担和精神内耗，让垃圾回收没有那么省心省力。\n逃逸分析(Escape analysis) 这个比较好理解，它的原理就是将一些不必要的堆分配变成栈分配，例如在一个函数之中，如果一个对象不会被传递到外部，Escape analysis 就可以将它从堆分配变为栈分配从而减少所需要的垃圾收集量。\nulisp GC 这是一种很 naive 的 GC ，采用的是最为朴素的 mark-and-sweep 中的双色标记法。\n首先调用 markobject() 函数对所有还能够访问的对象进行标记\nulisp 是一种广泛用于嵌入式的 lisp 方言\nvoid markobject (object *obj) { MARK: if (obj == NULL) return; if (marked(obj)) return; object* arg = car(obj); unsigned int type = obj-\u003etype; mark(obj); if (type \u003e= PAIR || type == ZERO) { // cons markobject(arg); obj = cdr(obj); goto MARK; } } 这里的 cons 是一种广义表，由两个指针组成，car 提取第一个指针，cdr 提取第二个指针。上面这个函数用了一种不够美观的方式消除了部分递归。\n这里的 mark(x) 宏利用内存对齐使用了一个技巧：\n#define mark(x) (car(x) = (object *)(((unsigned int)(car(x))) | 0x0001)) 因为内存对齐到偶数位，所以最低位为 0 ，将 car(x) 的最低位置为 1 的标记操作是合理的，而且节约了内存。\nsweep() 函数则用于清理对象。\nvoid sweep () { Freelist = NULL; Freespace = 0; for (int i=WORKSPACESIZE-1; i\u003e=0; i--) { object *obj = \u0026Workspace[i]; if (!marked(obj)) myfree(obj); else unmark(obj); } } inline void myfree (object *obj) { car(obj) = NULL; cdr(obj) = Freelist; Freelist = obj; Freespace++; } 这里的清理没有使用 free 等库函数是因为 ulisp 一般用于嵌入式环境中，它的内存管理就是管理一个保存对象地址的静态大数组，全局变量 Freelist 指向数组第一个为空的地方，Freespace 表示还剩余多少空间。\nulisp 的 gc 周期设置也比较朴素，每次 eval 被调用时检测一下剩余内存空间，如果小于 20 个对象的大小就垃圾收集。\nif (Freespace \u003c 20) gc(form, env); Lua GC Lua GC 也采用了 mark-and-sweep 的策略，但是它使用的不再是双色标记，而是更加优秀的三色标记法。\nLua 5.0 之前使用的是双色标记法，和 ulisp 大同小异。\nLua GC 规则 Lua 中所有对象需要垃圾回收，包括了 table 、函数、协程、模组。 只有通过根集(root set)可以访问到的对象才会被保存。 root set ::= registry + shared metatables registry ::= global table(_G) + main thread + package.loaded Lua 垃圾收集调用的是标准库内存分配函数（其实整个 Lua 都只用了标准库）。 所有的对象都被一个链表储存。 Lua GC Pace 如果 GC 从不运行就没有消耗额外的 CPU 周期，但是会浪费大量内存；如果 GC 一直运行就不会浪费额外的内存，但是会消耗大量 CPU 周期。因此我们需要找到一个合适的 GC 运行间隔。\nLua 5.0 采取的方法是当此次内存分配达到上次内存分配的两倍时调用 GC 。但这就造成了一个问题，虚拟机会停下来收集完垃圾再继续执行(stop the world)，这也就是 Lua 5.0 及之前都只能作为小小胶水语言使用的原因。\n增量收集 在 5.1 版本中，Lua 有了一个增量收集器，将收集器的执行与主程序交错执行。这也导致 GC 内保存的不再是一个可以直接分析的静态数据，必须引入三色标记。\n三色标记法 采用了一种三色标记的算法。每个对象都有三个状态：无法被访问到的对象是白色，可访问到，但没有递归扫描完全的对象是灰色，完全扫描过的对象是黑色。理想状况下，GC 只需要充分遍历灰色对象就可以完成收集。\nMutator 导致的问题 考虑一种情况，一个变量 x 已经被标记为黑色，但是解释执行x.a = {}，很明显{}是一个白色对象，这就形成了黑色对象指向白色对象的问题（导致这个问题的原因是对象的可变性）。此时我们不得不改变 x 的颜色，给死去的变量打复活赛。\n这时是将 {} 改变为灰色，还是把 x 变成灰色是个问题，刚好 Lua 提供了这两个接口：\nLUAI_FUNC void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v); LUAI_FUNC void luaC_barrierback_ (lua_State *L, GCObject *o); 何时使用何种方法其实是看设计者的经验。\n在刚刚说的这种情况中，Lua 采用的是将 x 变为灰色的方法，因为给一个 table 中的字段赋值说明这个 table 很有可能还要被复用；而在 metatable 中遇到这种情况就采取的是另一种方法。\n分代式 GC 想象一个场景，我们在代码的某处（甚至可以想象就是代码开头）使用了一个巨大的矩阵，之后再也没有比它更大的内存分配了，那么 Lua 5.1 的 GC 可能只会运行一次。\n因此基于假设大部分对象在创建出来后不久就被回收掉(most objects die young)的假设，Lua 5.2 设计了分代式 GC ，并在 5.4 中完善。\nOld and Young 所有的对象被划分为年轻的(young)和年老的(old)：对象刚被创建时是年轻的，当存活过两轮垃圾收集则变为年老的。在每次次级垃圾收集中，GC 只遍历并清除年轻的变量。\n注意在分代中的重要规则：老对象不能指向新对象。因此遇到这种情况时，如果我们将新对象变为老对象(forward)就可能出现大量的老对象，让分代式退化到原来的版本；如果我们将老对象变为新对象(backward)，就可能在别的地方破坏规则（例如这个老对象被别的对象引用）。\nThe Touched Objects 为了解决上述的问题，Lua 引入了被触碰过的对象这一概念，在刚刚的情景下，老对象会被标记为被触碰过的对象并被放入一个特殊的列表中。\n在每次次级垃圾收集中，被触碰过的变量会被遍历，但不会被收集（可能会收集它们指向的新对象）。\n在经历两次垃圾收集（非次级）后，被触碰过的变量指向的子对象都变成老对象了，因此他们也会恢复成为老对象。\nLua 5.2 分代的问题 在 Lua 5.3 的设计中，一个新对象经历一次收集而不被回收就会成为老对象。如果它刚好在一次回收前被创建而且本应该在那次回收之后不久被回收，本不应该成为老对象的它就会成为老对象。\n过多的老对象就导致 5.2 的性能堪忧。\nuserdata 导致的问题 由于 Lua 是一种可以与 C 互相嵌入的语言，因此不可避免地会使用到 C 中的数据结构(userdata)，但又由于 Lua 支持给 userdata 定义 __gc 方法，故要区分有无 __gc 方法的 userdata 。\n标记流程要分为两步，先是把包括 userdata 的死对象标记，再将 userdata 中有 __gc 方法的复活，让它们在下一轮被收集。\n参考资料 ulisp Rust Arc wikipedia 云风的BLOG Lua 之父的演讲ppt ",
  "wordCount" : "3192",
  "inLanguage": "zh",
  "image":"https://vaaandark.top/image/gc.png","datePublished": "2022-09-17T11:27:19Z",
  "dateModified": "2022-09-17T11:27:19Z",
  "author":{
    "@type": "Person",
    "name": "vaaandark"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://vaaandark.top/posts/gc/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "vaaandark's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://vaaandark.top/image/vaaandark.png"
    }
  }
}
</script>


</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://vaaandark.top/" accesskey="h" title="vaaandark&#39;s blog (Alt + H)">
                <img src="https://vaaandark.top/image/vaaandark.png" alt="" aria-label="logo"
                    height="35">vaaandark&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://vaaandark.top/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://vaaandark.top/posts/" title="Posts">
                    <span>📄 归档</span>
                </a>
            </li>
            <li>
                <a href="https://vaaandark.top/categories/" title="categories">
                    <span>📂 分类</span>
                </a>
            </li>
            <li>
                <a href="https://vaaandark.top/tags/" title="tags">
                    <span>🔖 标签</span>
                </a>
            </li>
            <li>
                <a href="https://vaaandark.top/about/" title="关于我">
                    <span>🙋 关于</span>
                </a>
            </li>
            <li>
                <a href="https://vaaandark.top/links/" title="友链">
                    <span>🤝 友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://vaaandark.top/">主页</a>&nbsp;»&nbsp;<a href="https://vaaandark.top/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      垃圾回收
    </h1>
    <div class="post-meta"><span title='2022-09-17 11:27:19 +0000 UTC'>2022 9月 17</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;vaaandark

</div>
  </header> 
<figure class="entry-cover"><img loading="eager" src="https://vaaandark.top/image/gc.png" alt="">
        
</figure><div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#gc-%e7%ae%80%e4%bb%8b%e4%b8%8e%e7%ad%96%e7%95%a5%e5%88%86%e7%b1%bb" aria-label="GC 简介与策略分类">GC 简介与策略分类</a><ul>
                        
                <li>
                    <a href="#%e8%bf%bd%e8%b8%aatracing" aria-label="追踪(Tracing)">追踪(Tracing)</a></li>
                <li>
                    <a href="#%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0reference-counting" aria-label="引用计数(Reference counting)">引用计数(Reference counting)</a><ul>
                        
                <li>
                    <a href="#%e5%be%aa%e7%8e%af%e5%bc%95%e7%94%a8" aria-label="循环引用">循环引用</a></li>
                <li>
                    <a href="#%e9%a2%9d%e5%a4%96%e7%a9%ba%e9%97%b4%e5%bc%80%e9%94%80" aria-label="额外空间开销">额外空间开销</a></li>
                <li>
                    <a href="#%e9%a2%9d%e5%a4%96%e6%97%b6%e9%97%b4%e5%bc%80%e9%94%80" aria-label="额外时间开销">额外时间开销</a></li>
                <li>
                    <a href="#%e5%b9%b6%e8%a1%8c" aria-label="并行">并行</a></li>
                <li>
                    <a href="#%e8%87%aa%e5%8a%a8%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0automatic-reference-counting" aria-label="自动引用计数(Automatic Reference counting)">自动引用计数(Automatic Reference counting)</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90escape-analysis" aria-label="逃逸分析(Escape analysis)">逃逸分析(Escape analysis)</a></li></ul>
                </li>
                <li>
                    <a href="#ulisp-gc" aria-label="ulisp GC">ulisp GC</a></li>
                <li>
                    <a href="#lua-gc" aria-label="Lua GC">Lua GC</a><ul>
                        
                <li>
                    <a href="#lua-gc-%e8%a7%84%e5%88%99" aria-label="Lua GC 规则">Lua GC 规则</a></li>
                <li>
                    <a href="#lua-gc-pace" aria-label="Lua GC Pace">Lua GC Pace</a></li>
                <li>
                    <a href="#%e5%a2%9e%e9%87%8f%e6%94%b6%e9%9b%86" aria-label="增量收集">增量收集</a></li>
                <li>
                    <a href="#%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95" aria-label="三色标记法">三色标记法</a><ul>
                        
                <li>
                    <a href="#mutator-%e5%af%bc%e8%87%b4%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="Mutator 导致的问题">Mutator 导致的问题</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%86%e4%bb%a3%e5%bc%8f-gc" aria-label="分代式 GC">分代式 GC</a><ul>
                        
                <li>
                    <a href="#old-and-young" aria-label="Old and Young">Old and Young</a></li>
                <li>
                    <a href="#the-touched-objects" aria-label="The Touched Objects">The Touched Objects</a></li>
                <li>
                    <a href="#lua-52-%e5%88%86%e4%bb%a3%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="Lua 5.2 分代的问题">Lua 5.2 分代的问题</a></li></ul>
                </li>
                <li>
                    <a href="#userdata-%e5%af%bc%e8%87%b4%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="userdata 导致的问题">userdata 导致的问题</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" aria-label="参考资料">参考资料</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>之前学习了 Lua 的 Table 和协程，对 Lua 中另一个重要模块 GC 还有很多疑问，这次就来学习一下。</p>
<!-- more -->
<h2 id="gc-简介与策略分类">GC 简介与策略分类<a hidden class="anchor" aria-hidden="true" href="#gc-简介与策略分类">#</a></h2>
<p>在计算机科学中，垃圾收集(GC)是一种自动内存管理形式。垃圾收集器尝试回收程序分配但不再引用的内存；这样的内存被称为垃圾。</p>
<h3 id="追踪tracing">追踪(Tracing)<a hidden class="anchor" aria-hidden="true" href="#追踪tracing">#</a></h3>
<p>Tracing 的策略简单讲就是使用一些根对象来遍历所有的引用，可以访问到的就不是垃圾，不能访问到的就是需要回收的垃圾。虽然这个说起来和实现起来很简单，但是想要使其有较好的性能并不是一件很容易的事情。Tracing 有很多需要考虑的问题，例如收集的周期(步进 Pace)是什么，是按照时间片还是按照已经分配过的内存，是否会出现为了收集垃圾程序执行出现明显卡死现象等。</p>
<p>之后用到的 Lisp 和 Lua 的例子都以 Tracing 策略为主。</p>
<h3 id="引用计数reference-counting">引用计数(Reference counting)<a hidden class="anchor" aria-hidden="true" href="#引用计数reference-counting">#</a></h3>
<p>引用计数垃圾收集是每个对象都有一个对它的引用数的计数。垃圾通过引用计数为零来标识。对象的引用计数在创建对它的引用时增加，在引用被销毁时减少。当计数达到零时，对象的内存被回收。</p>
<h4 id="循环引用">循环引用<a hidden class="anchor" aria-hidden="true" href="#循环引用">#</a></h4>
<p>如果有两个对象相互引用，就会导致它们的引用计数永远大于等于 1 ，它们永远不会被回收。对于这个问题，一般有两种解决方案。一种比较直观，直接检测是否出现循环，cpython 就使用的这种方法；另一种就是引入弱引用的概念。</p>
<p>弱引用不会增加引用计数，而且指向的对象可能是已经被回收的，因此可以简单地检测出是否失效，而不是保持引用悬垂。</p>
<h4 id="额外空间开销">额外空间开销<a hidden class="anchor" aria-hidden="true" href="#额外空间开销">#</a></h4>
<p>明显地，如果使用引用计数的策略就需要额外的空间来存储计数。有的是存在对象中，有的是存在一个表之中。在一些语言例如 objective-c 中，它们将引用计数存在指针地址未使用的位当中（我认为这对不同处理器间可移植性有影响）。</p>
<h4 id="额外时间开销">额外时间开销<a hidden class="anchor" aria-hidden="true" href="#额外时间开销">#</a></h4>
<p>例如如果使用<code>for item in something</code>的方法遍历，在每个循环开始都有<code>rc++</code>每个结尾都有<code>rc--</code>，优秀的 GC 应该把这个消除掉。</p>
<h4 id="并行">并行<a hidden class="anchor" aria-hidden="true" href="#并行">#</a></h4>
<p>如果需要编写并行代码则需让 rc 的操作具有原子性，最重要的一点是它们不可以是全局变量了。</p>
<h4 id="自动引用计数automatic-reference-counting">自动引用计数(Automatic Reference counting)<a hidden class="anchor" aria-hidden="true" href="#自动引用计数automatic-reference-counting">#</a></h4>
<p>自动引用计数无需运行时，会在编译阶段处理引用计数并实现内存管理，但是难以处理循环引用的问题。神奇的 Rust 较好地解决了这个问题，方法还是使用弱引用，可以看 <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc 的实现</a>：</p>
<blockquote>
<p>Breaking cycles with Weak</p>
<p>The downgrade method can be used to create a non-owning Weak pointer. A Weak pointer can be upgraded to an Arc, but this will return None if the value stored in the allocation has already been dropped. In other words, Weak pointers do not keep the value inside the allocation alive; however, they do keep the allocation (the backing store for the value) alive.</p>
<p>A cycle between Arc pointers will never be deallocated. For this reason, Weak is used to break cycles. For example, a tree could have strong Arc pointers from parent nodes to children, and Weak pointers from children back to their parents.</p>
</blockquote>
<p>不过，无论是朴素的引用计数还是自动引用计数，一旦引入弱引用就可能增加代码编写者的心智负担和精神内耗，让垃圾回收没有那么省心省力。</p>
<h3 id="逃逸分析escape-analysis">逃逸分析(Escape analysis)<a hidden class="anchor" aria-hidden="true" href="#逃逸分析escape-analysis">#</a></h3>
<p>这个比较好理解，它的原理就是将一些不必要的堆分配变成栈分配，例如在一个函数之中，如果一个对象不会被传递到外部，Escape analysis 就可以将它从堆分配变为栈分配从而减少所需要的垃圾收集量。</p>
<h2 id="ulisp-gc">ulisp GC<a hidden class="anchor" aria-hidden="true" href="#ulisp-gc">#</a></h2>
<p>这是一种很 naive 的 GC ，采用的是最为朴素的 mark-and-sweep 中的双色标记法。</p>
<p>首先调用 markobject() 函数对所有还能够访问的对象进行标记</p>
<blockquote>
<p>ulisp 是一种广泛用于嵌入式的 lisp 方言</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> markobject (object *obj) {
</span></span><span style="display:flex;"><span>MARK:
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> (obj == <span style="color:#fff;font-weight:bold">NULL</span>) <span style="color:#fff;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> (marked(obj)) <span style="color:#fff;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  object* arg = car(obj);
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> type = obj-&gt;type;
</span></span><span style="display:flex;"><span>  mark(obj);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> (type &gt;= PAIR || type == ZERO) { <span style="color:#007f7f">// cons
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    markobject(arg);
</span></span><span style="display:flex;"><span>    obj = cdr(obj);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">goto</span> MARK;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里的 cons 是一种广义表，由两个指针组成，car 提取第一个指针，cdr 提取第二个指针。上面这个函数用了一种不够美观的方式消除了部分递归。</p>
<p>这里的 mark(x) 宏利用内存对齐使用了一个技巧：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#define mark(x)            (car(x) = (object *)(((unsigned int)(car(x))) | 0x0001))
</span></span></span></code></pre></div><p>因为内存对齐到偶数位，所以最低位为 0 ，将 car(x) 的最低位置为 1 的标记操作是合理的，而且节约了内存。</p>
<p>sweep() 函数则用于清理对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> sweep () {
</span></span><span style="display:flex;"><span>  Freelist = <span style="color:#fff;font-weight:bold">NULL</span>;
</span></span><span style="display:flex;"><span>  Freespace = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i=WORKSPACESIZE-<span style="color:#ff0;font-weight:bold">1</span>; i&gt;=<span style="color:#ff0;font-weight:bold">0</span>; i--) {
</span></span><span style="display:flex;"><span>    object *obj = &amp;Workspace[i];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (!marked(obj)) myfree(obj); <span style="color:#fff;font-weight:bold">else</span> unmark(obj);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">inline</span> <span style="color:#fff;font-weight:bold">void</span> myfree (object *obj) {
</span></span><span style="display:flex;"><span>  car(obj) = <span style="color:#fff;font-weight:bold">NULL</span>;
</span></span><span style="display:flex;"><span>  cdr(obj) = Freelist;
</span></span><span style="display:flex;"><span>  Freelist = obj;
</span></span><span style="display:flex;"><span>  Freespace++;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里的清理没有使用 free 等库函数是因为 ulisp 一般用于嵌入式环境中，它的内存管理就是管理一个保存对象地址的静态大数组，全局变量 Freelist 指向数组第一个为空的地方，Freespace 表示还剩余多少空间。</p>
<p>ulisp 的 gc 周期设置也比较朴素，每次 eval 被调用时检测一下剩余内存空间，如果小于 20 个对象的大小就垃圾收集。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">if</span> (Freespace &lt; <span style="color:#ff0;font-weight:bold">20</span>) gc(form, env);
</span></span></code></pre></div><h2 id="lua-gc">Lua GC<a hidden class="anchor" aria-hidden="true" href="#lua-gc">#</a></h2>
<p>Lua GC 也采用了 mark-and-sweep 的策略，但是它使用的不再是双色标记，而是更加优秀的三色标记法。</p>
<blockquote>
<p>Lua 5.0 之前使用的是双色标记法，和 ulisp 大同小异。</p>
</blockquote>
<h3 id="lua-gc-规则">Lua GC 规则<a hidden class="anchor" aria-hidden="true" href="#lua-gc-规则">#</a></h3>
<ul>
<li>Lua 中所有对象需要垃圾回收，包括了 table 、函数、协程、模组。</li>
<li>只有通过根集(root set)可以访问到的对象才会被保存。
<ul>
<li>root set ::= registry + shared metatables</li>
<li>registry ::= global table(_G) + main thread + package.loaded</li>
</ul>
</li>
<li>Lua 垃圾收集调用的是标准库内存分配函数（其实整个 Lua 都只用了标准库）。</li>
<li>所有的对象都被一个链表储存。</li>
</ul>
<h3 id="lua-gc-pace">Lua GC Pace<a hidden class="anchor" aria-hidden="true" href="#lua-gc-pace">#</a></h3>
<p>如果 GC 从不运行就没有消耗额外的 CPU 周期，但是会浪费大量内存；如果 GC 一直运行就不会浪费额外的内存，但是会消耗大量 CPU 周期。因此我们需要找到一个合适的 GC 运行间隔。</p>
<p>Lua 5.0 采取的方法是当此次内存分配达到上次内存分配的两倍时调用 GC 。但这就造成了一个问题，虚拟机会停下来收集完垃圾再继续执行(stop the world)，这也就是 Lua 5.0 及之前都只能作为小小胶水语言使用的原因。</p>
<h3 id="增量收集">增量收集<a hidden class="anchor" aria-hidden="true" href="#增量收集">#</a></h3>
<p>在 5.1 版本中，Lua 有了一个增量收集器，将收集器的执行与主程序交错执行。这也导致 GC 内保存的不再是一个可以直接分析的静态数据，必须引入三色标记。</p>
<h3 id="三色标记法">三色标记法<a hidden class="anchor" aria-hidden="true" href="#三色标记法">#</a></h3>
<p>采用了一种三色标记的算法。每个对象都有三个状态：无法被访问到的对象是白色，可访问到，但没有递归扫描完全的对象是灰色，完全扫描过的对象是黑色。理想状况下，GC 只需要充分遍历灰色对象就可以完成收集。</p>
<h4 id="mutator-导致的问题">Mutator 导致的问题<a hidden class="anchor" aria-hidden="true" href="#mutator-导致的问题">#</a></h4>
<p>考虑一种情况，一个变量 x 已经被标记为黑色，但是解释执行<code>x.a = {}</code>，很明显<code>{}</code>是一个白色对象，这就形成了黑色对象指向白色对象的问题（导致这个问题的原因是对象的可变性）。此时我们不得不改变 x 的颜色，<del>给死去的变量打复活赛</del>。</p>
<p>这时是将 {} 改变为灰色，还是把 x 变成灰色是个问题，刚好 Lua 提供了这两个接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LUAI_FUNC <span style="color:#fff;font-weight:bold">void</span> luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v);
</span></span><span style="display:flex;"><span>LUAI_FUNC <span style="color:#fff;font-weight:bold">void</span> luaC_barrierback_ (lua_State *L, GCObject *o);
</span></span></code></pre></div><p>何时使用何种方法其实是看设计者的经验。</p>
<p>在刚刚说的这种情况中，Lua 采用的是将 x 变为灰色的方法，因为给一个 table 中的字段赋值说明这个 table 很有可能还要被复用；而在 metatable 中遇到这种情况就采取的是另一种方法。</p>
<h3 id="分代式-gc">分代式 GC<a hidden class="anchor" aria-hidden="true" href="#分代式-gc">#</a></h3>
<p>想象一个场景，我们在代码的某处（甚至可以想象就是代码开头）使用了一个巨大的矩阵，之后再也没有比它更大的内存分配了，那么 Lua 5.1 的 GC 可能只会运行一次。</p>
<p>因此基于假设大部分对象在创建出来后不久就被回收掉(m<em>ost objects die young</em>)的假设，Lua 5.2 设计了分代式 GC ，并在 5.4 中完善。</p>
<h4 id="old-and-young">Old and Young<a hidden class="anchor" aria-hidden="true" href="#old-and-young">#</a></h4>
<p>所有的对象被划分为年轻的(young)和年老的(old)：对象刚被创建时是年轻的，当存活过两轮垃圾收集则变为年老的。在每次次级垃圾收集中，GC 只遍历并清除年轻的变量。</p>
<p>注意在分代中的重要规则：老对象不能指向新对象。因此遇到这种情况时，如果我们将新对象变为老对象(forward)就可能出现大量的老对象，让分代式退化到原来的版本；如果我们将老对象变为新对象(backward)，就可能在别的地方破坏规则（例如这个老对象被别的对象引用）。</p>
<h4 id="the-touched-objects">The Touched Objects<a hidden class="anchor" aria-hidden="true" href="#the-touched-objects">#</a></h4>
<p>为了解决上述的问题，Lua 引入了被触碰过的对象这一概念，在刚刚的情景下，老对象会被标记为被触碰过的对象并被放入一个特殊的列表中。</p>
<p>在每次次级垃圾收集中，被触碰过的变量会被遍历，但不会被收集（可能会收集它们指向的新对象）。</p>
<p>在经历两次垃圾收集（非次级）后，被触碰过的变量指向的子对象都变成老对象了，因此他们也会恢复成为老对象。</p>
<h4 id="lua-52-分代的问题">Lua 5.2 分代的问题<a hidden class="anchor" aria-hidden="true" href="#lua-52-分代的问题">#</a></h4>
<p>在 Lua 5.3 的设计中，一个新对象经历一次收集而不被回收就会成为老对象。如果它刚好在一次回收前被创建而且本应该在那次回收之后不久被回收，本不应该成为老对象的它就会成为老对象。</p>
<p>过多的老对象就导致 5.2 的性能堪忧。</p>
<h3 id="userdata-导致的问题">userdata 导致的问题<a hidden class="anchor" aria-hidden="true" href="#userdata-导致的问题">#</a></h3>
<p>由于 Lua 是一种可以与 C 互相嵌入的语言，因此不可避免地会使用到 C 中的数据结构(userdata)，但又由于 Lua 支持给 userdata 定义 __gc 方法，故要区分有无 __gc 方法的 userdata 。</p>
<p>标记流程要分为两步，先是把包括 userdata 的死对象标记，再将 userdata 中有 __gc 方法的复活，让它们在下一轮被收集。</p>
<h2 id="参考资料">参考资料<a hidden class="anchor" aria-hidden="true" href="#参考资料">#</a></h2>
<ul>
<li><a href="http://www.ulisp.com/show?1BD3">ulisp</a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Rust Arc</a></li>
<li><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">wikipedia</a></li>
<li><a href="https://blog.codingnow.com/2018/10/lua_gc.html">云风的BLOG</a></li>
<li><a href="https://www.lua.org/wshop18/Ierusalimschy.pdf">Lua 之父的演讲ppt</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://vaaandark.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></li>
      <li><a href="https://vaaandark.top/tags/lua/">Lua</a></li>
      <li><a href="https://vaaandark.top/tags/lisp/">Lisp</a></li>
      <li><a href="https://vaaandark.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li>
      <li><a href="https://vaaandark.top/tags/gc/">GC</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://vaaandark.top/posts/80x86-learning/">
    <span class="title">« 上一页</span>
    <br>
    <span>80X86汇编语言学习</span>
  </a>
  <a class="next" href="https://vaaandark.top/posts/freedos-and-masm-environment/">
    <span class="title">下一页 »</span>
    <br>
    <span>FreeDOS和masm开发环境配置</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 垃圾回收 on x"
            href="https://x.com/intent/tweet/?text=%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6&amp;url=https%3a%2f%2fvaaandark.top%2fposts%2fgc%2f&amp;hashtags=%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%2cLua%2cLisp%2c%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%2cGC">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 垃圾回收 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvaaandark.top%2fposts%2fgc%2f&amp;title=%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6&amp;summary=%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6&amp;source=https%3a%2f%2fvaaandark.top%2fposts%2fgc%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 垃圾回收 on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fvaaandark.top%2fposts%2fgc%2f&title=%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 垃圾回收 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvaaandark.top%2fposts%2fgc%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 垃圾回收 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%20-%20https%3a%2f%2fvaaandark.top%2fposts%2fgc%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 垃圾回收 on telegram"
            href="https://telegram.me/share/url?text=%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6&amp;url=https%3a%2f%2fvaaandark.top%2fposts%2fgc%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 垃圾回收 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6&u=https%3a%2f%2fvaaandark.top%2fposts%2fgc%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer><script src="https://giscus.app/client.js"
        data-repo="vaaandark/vaaandark.github.io"
        data-repo-id="R_kgDOGsxTxw"
        data-category="Announcements"
        data-category-id="DIC_kwDOGsxTx84CmAQ1"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://vaaandark.top/">vaaandark&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
