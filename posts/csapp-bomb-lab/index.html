<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CSAPP Bomb Lab | vaaandark&#39;s blog</title>
<meta name="keywords" content="CSAPP, 汇编语言, 反汇编">
<meta name="description" content="之前的 Bomb Lab 没有做，现在刚好在上计算机系统基础这门课，学校使用了 CSAPP 的 Bomb Lab ，可以补交一下 CSAPP 的作业，也可以学习一下 GDB 的使用。
实验简述
遗憾地，CSAPP 的 Bomb Lab 早已提供的是 Linux 的 64 位可执行程序，而我校的 Lab 还是 32 位的 Windows PE32 。不过我还是找老师要到了它的 Linux 版本，不过也是 ELF32 ，可执行文件的名字叫bomb_32。">
<meta name="author" content="vaaandark">
<link rel="canonical" href="https://vaaandark.top/posts/csapp-bomb-lab/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.556a50c7c92c2556e588f602528ac3c41884cdb6e537ce0647b5e200cd1c2094.css" integrity="sha256-VWpQx8ksJVbliPYCUorDxBiEzbblN84GR7XiAM0cIJQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://vaaandark.top/image/vaaandark.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://vaaandark.top/image/vaaandark.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://vaaandark.top/image/vaaandark.png">
<link rel="apple-touch-icon" href="https://vaaandark.top/image/vaaandark.png">
<link rel="mask-icon" href="https://vaaandark.top/image/vaaandark.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://vaaandark.top/posts/csapp-bomb-lab/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://vaaandark.top/posts/csapp-bomb-lab/">
  <meta property="og:site_name" content="vaaandark&#39;s blog">
  <meta property="og:title" content="CSAPP Bomb Lab">
  <meta property="og:description" content="之前的 Bomb Lab 没有做，现在刚好在上计算机系统基础这门课，学校使用了 CSAPP 的 Bomb Lab ，可以补交一下 CSAPP 的作业，也可以学习一下 GDB 的使用。
实验简述 遗憾地，CSAPP 的 Bomb Lab 早已提供的是 Linux 的 64 位可执行程序，而我校的 Lab 还是 32 位的 Windows PE32 。不过我还是找老师要到了它的 Linux 版本，不过也是 ELF32 ，可执行文件的名字叫bomb_32。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-10-29T22:24:22+00:00">
    <meta property="article:modified_time" content="2022-10-29T22:24:22+00:00">
    <meta property="article:tag" content="CSAPP">
    <meta property="article:tag" content="汇编语言">
    <meta property="article:tag" content="反汇编">
    <meta property="og:image" content="https://vaaandark.top/image/bomb.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://vaaandark.top/image/bomb.jpg">
<meta name="twitter:title" content="CSAPP Bomb Lab">
<meta name="twitter:description" content="之前的 Bomb Lab 没有做，现在刚好在上计算机系统基础这门课，学校使用了 CSAPP 的 Bomb Lab ，可以补交一下 CSAPP 的作业，也可以学习一下 GDB 的使用。
实验简述
遗憾地，CSAPP 的 Bomb Lab 早已提供的是 Linux 的 64 位可执行程序，而我校的 Lab 还是 32 位的 Windows PE32 。不过我还是找老师要到了它的 Linux 版本，不过也是 ELF32 ，可执行文件的名字叫bomb_32。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://vaaandark.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "CSAPP Bomb Lab",
      "item": "https://vaaandark.top/posts/csapp-bomb-lab/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CSAPP Bomb Lab",
  "name": "CSAPP Bomb Lab",
  "description": "之前的 Bomb Lab 没有做，现在刚好在上计算机系统基础这门课，学校使用了 CSAPP 的 Bomb Lab ，可以补交一下 CSAPP 的作业，也可以学习一下 GDB 的使用。\n实验简述 遗憾地，CSAPP 的 Bomb Lab 早已提供的是 Linux 的 64 位可执行程序，而我校的 Lab 还是 32 位的 Windows PE32 。不过我还是找老师要到了它的 Linux 版本，不过也是 ELF32 ，可执行文件的名字叫bomb_32。\n",
  "keywords": [
    "CSAPP", "汇编语言", "反汇编"
  ],
  "articleBody": "之前的 Bomb Lab 没有做，现在刚好在上计算机系统基础这门课，学校使用了 CSAPP 的 Bomb Lab ，可以补交一下 CSAPP 的作业，也可以学习一下 GDB 的使用。\n实验简述 遗憾地，CSAPP 的 Bomb Lab 早已提供的是 Linux 的 64 位可执行程序，而我校的 Lab 还是 32 位的 Windows PE32 。不过我还是找老师要到了它的 Linux 版本，不过也是 ELF32 ，可执行文件的名字叫bomb_32。\n该 Lab 是 CSAPP Bomb Lab 的老版 32 位程序，所以之后我还是看一下新版的 Bomb Lab 较好，不能完全不了解 64 位汇编嘛 :(\n实验环境 GNU gdb (GDB) Fedora 12.1-2.fc36 GNU objdump version 2.37-36.fc36 实验过程 首先反汇编生成汇编代码：\n$ objdump -S -C bomb_32 \u003e bomb.disas 由于我不是很会看 AT\u0026T 的汇编代码，所以我的 objdump 是 aliased 的，默认使用 Intel 的语法。\n$ which objdump objdump='objdump --disassembler-options=intel' /usr/bin/objdump gdb 也默认使用 Intel 的语法：\n$ cat ~/.gdbinit set disassembly-flavor intel 再使用 gdb 开始调试程序：\n$ gdb --args ./bomb_32 input phase_1 由于老师给了这个程序运行的流程图，我也看过 Bomb Lab 中提供的 .c 文件，所以我知道每个字符串都在phase_n的函数中输入或者检验。\n可以直接查看phase_1函数的反汇编代码，并注意到这个函数中的一个函数调用：\n(gdb) disas phase_1 Dump of assembler code for function phase_1: ...... 0x08048b2c \u003c+12\u003e:\tpush 0x80497c0 0x08048b31 \u003c+17\u003e:\tpush eax 0x08048b32 \u003c+18\u003e:\tcall 0x8049030 ...... 可以看到它在压入两个参数之后调用了一个函数strings_not_equal，我们直接查看0x80497c0里面是什么内容，我首先猜测它是一个字符串：\n(gdb) p (char *)0x80497c0 $1 = 0x80497c0 \"Public speaking is very easy.\" 在之后的测试中，这个字符串也让我过了第一关。\nphase_2 直接查看phase_2的汇编代码：\n; phase_2 的参数为字符串 input ，在 [ebp+0x8] 08048b48 : 8048b48:\t55 push ebp 8048b49:\t89 e5 mov ebp,esp ; 为局部变量腾出空间 8048b4b:\t83 ec 20 sub esp,0x20 ; 可能是内部调用的函数需要使用这两个寄存器 ; 所以根据 caller save 在这里保存 8048b4e:\t56 push esi 8048b4f:\t53 push ebx ; 将 input 放入 edx 中 8048b50:\t8b 55 08 mov edx,DWORD PTR [ebp+0x8] ; 等于 sub esp, 0x8 8048b53:\t83 c4 f8 add esp,0xfffffff8 ; 将局部变量的地址 [ebp-0x18] 放入 eax 中 ; 不妨给它起名为变量 A ; 由于给局部变量预留的位置很大，猜测 A 是一个数组 8048b56:\t8d 45 e8 lea eax,[ebp-0x18] ; 压栈传参，传入的是 input, A 8048b59:\t50 push eax 8048b5a:\t52 push edx ; 调用函数 read_six_numbers 根据名字合理怀疑这里是读入六个数字，A 可能有 6 个元素 8048b5b:\te8 78 04 00 00 call 8048fd8 ; 这里 esp 加了 0x10 相当于把之前的参数退栈了，还把之前 add esp,0xfffffff8 的加回去了。我猜测之前的 add 可能和内存对齐有关 8048b60:\t83 c4 10 add esp,0x10 ; 将 A[0] 与 1 比较 ; 由于之前传递的是地址，这个变量应该在 read_six_numbers 中被修改了 8048b63:\t83 7d e8 01 cmp DWORD PTR [ebp-0x18],0x1 ; 如果是 1 则成功，不是 1 则引爆炸弹 8048b67:\t74 05 je 8048b6e 8048b69:\te8 8e 09 00 00 call 80494fc ; ebx \u003c- 0x1 8048b6e:\tbb 01 00 00 00 mov ebx,0x1 ; 将 A 放入 esi 中 8048b73:\t8d 75 e8 lea esi,[ebp-0x18] ; eax \u003c- 0x2 8048b76:\t8d 43 01 lea eax,[ebx+0x1] ; 这步骤操作之后 eax 的值为 (ebx + 1) * A[ebx - 1] ; ebx 初始为 1 8048b79:\t0f af 44 9e fc imul eax,DWORD PTR [esi+ebx*4-0x4] ; 相当于判断 A[ebx] 是不是 A[ebx - 1] 两倍 8048b7e:\t39 04 9e cmp DWORD PTR [esi+ebx*4],eax 8048b81:\t74 05 je 8048b88 8048b83:\te8 74 09 00 00 call 80494fc 8048b88:\t43 inc ebx 8048b89:\t83 fb 05 cmp ebx,0x5 ; 我读到这里才发现是一个循环，终止条件为 ebx \u003e 5 8048b8c:\t7e e8 jle 8048b76 ; 所以根据递推公式可知字符串为 1 2 6 24 120 720 8048b8e:\t8d 65 d8 lea esp,[ebp-0x28] 8048b91:\t5b pop ebx 8048b92:\t5e pop esi 8048b93:\t89 ec mov esp,ebp 8048b95:\t5d pop ebp 8048b96:\tc3 ret 8048b97:\t90 nop 它调用了函数read_six_numbers，所以我们也分析一下它：\n; 参数为字符串 input 和数组 A 08048fd8 : 8048fd8:\t55 push ebp 8048fd9:\t89 e5 mov ebp,esp 8048fdb:\t83 ec 08 sub esp,0x8 ; 传入的输入字符串 8048fde:\t8b 4d 08 mov ecx,DWORD PTR [ebp+0x8] ; 传入的数组 A 8048fe1:\t8b 55 0c mov edx,DWORD PTR [ebp+0xc] ; A[5] 8048fe4:\t8d 42 14 lea eax,[edx+0x14] 8048fe7:\t50 push eax ; A[4] 8048fe8:\t8d 42 10 lea eax,[edx+0x10] 8048feb:\t50 push eax ; A[3] 8048fec:\t8d 42 0c lea eax,[edx+0xc] 8048fef:\t50 push eax ; A[2] 8048ff0:\t8d 42 08 lea eax,[edx+0x8] 8048ff3:\t50 push eax ; A[1] 8048ff4:\t8d 42 04 lea eax,[edx+0x4] 8048ff7:\t50 push eax ; A[0] 8048ff8:\t52 push edx ; format 字符串 \"%d %d %d %d %d %d\" 8048ff9:\t68 1b 9b 04 08 push 0x8049b1b ; input 输入字符串 8048ffe:\t51 push ecx 8048fff:\te8 5c f8 ff ff call 8048860 8049004:\t83 c4 20 add esp,0x20 8049007:\t83 f8 05 cmp eax,0x5 804900a:\t7f 05 jg 8049011 804900c:\te8 eb 04 00 00 call 80494fc 8049011:\t89 ec mov esp,ebp 8049013:\t5d pop ebp 8049014:\tc3 ret 8049015:\t8d 76 00 lea esi,[esi+0x0] 使用字符串1 2 6 24 120 720成功通过第二关。\nphase_3 ; phase_3 的参数为字符串 input ，在 [ebp+0x8] 08048b98 : 8048b98:\t55 push ebp 8048b99:\t89 e5 mov ebp,esp ; 预留 20 个字节 8048b9b:\t83 ec 14 sub esp,0x14 8048b9e:\t53 push ebx ; 将 input 放入 edx 8048b9f:\t8b 55 08 mov edx,DWORD PTR [ebp+0x8] ; sub esp, 0x4 8048ba2:\t83 c4 f4 add esp,0xfffffff4 ; ; int_b 8048ba5:\t8d 45 fc lea eax,[ebp-0x4] 8048ba8:\t50 push eax ; char_c 8048ba9:\t8d 45 fb lea eax,[ebp-0x5] 8048bac:\t50 push eax ; int_a 8048bad:\t8d 45 f4 lea eax,[ebp-0xc] 8048bb0:\t50 push eax ; 通过 GBD 调试可以知道这个地址内容为 \"%d %c %d\" 8048bb1:\t68 de 97 04 08 push 0x80497de ; input 8048bb6:\t52 push edx 8048bb7:\te8 a4 fc ff ff call 8048860 8048bbc:\t83 c4 20 add esp,0x20 ; 如果 sscanf 匹配并赋值的个数不多于 2 ，则爆炸 8048bbf:\t83 f8 02 cmp eax,0x2 8048bc2:\t7f 05 jg 8048bc9 8048bc4:\te8 33 09 00 00 call 80494fc ; 将 int_a 与 0x7 比较 ; 怀疑是一个防止数组越界的操作 8048bc9:\t83 7d f4 07 cmp DWORD PTR [ebp-0xc],0x7 ; 如果大于则爆炸 8048bcd:\t0f 87 b5 00 00 00 ja 8048c88 ; 将 int_a 赋值给 eax 8048bd3:\t8b 45 f4 mov eax,DWORD PTR [ebp-0xc] ; 这里存在一个跳转表，对应到 C 语言中应该是一个 switch-case 结构 ; 可以在 gdb 里面查看一下对应的表 `(gdb) p/x *(int *)0x80497e8` ; [0x80497e8] 对应 8048be0 ; [0x80497e8+1*4] 对应 8048c00 ; [0x80497e8+2*4] 对应 8048c16 ; [0x80497e8+3*4] 对应 8048c28 ; [0x80497e8+4*4] 对应 8048c40 ; [0x80497e8+5*4] 对应 8048c52 ; [0x80497e8+6*4] 对应 8048c64 ; [0x80497e8+7*4] 对应 8048c76 ; switch-case(int_a) 8048bd6:\tff 24 85 e8 97 04 08 jmp DWORD PTR [eax*4+0x80497e8] 8048bdd:\t8d 76 00 lea esi,[esi+0x0] ; case 0: ; bl \u003c- 0x71 8048be0:\tb3 71 mov bl,0x71 ; 将 int_b 与 0x309 比较 8048be2:\t81 7d fc 09 03 00 00 cmp DWORD PTR [ebp-0x4],0x309 ; 如果等于就 break 8048be9:\t0f 84 a0 00 00 00 je 8048c8f 8048bef:\te8 08 09 00 00 call 80494fc 8048bf4:\te9 96 00 00 00 jmp 8048c8f ; eiz 是一个伪寄存器，它始终为 0 8048bf9:\t8d b4 26 00 00 00 00 lea esi,[esi+eiz*1+0x0] ; 后面几个 case 都是相同的道理 ...... ; bl 与 char_c 比较 8048c8f:\t3a 5d fb cmp bl,BYTE PTR [ebp-0x5] ; 所以基本流程就是根据 int_a 的值确定进去哪一个 case ， ; 然后在该分支中将 int_b 和某一值比较，并确定 char_c 应该等于的值 ; 所以答案应该不唯一，通过 int_a 的值确定后面两个答案 ...... 我使用0 q 777通过了这一关。\nphase_4 这一关包含了递归函数，但是挑战性不是很大。\n; phase_4 的参数为字符串 input ，在 [ebp+0x8] 08048ce0 : 8048ce0:\t55 push ebp 8048ce1:\t89 e5 mov ebp,esp 8048ce3:\t83 ec 18 sub esp,0x18 ; input -\u003e edx 8048ce6:\t8b 55 08 mov edx,DWORD PTR [ebp+0x8] ; sub esp, 0xc 8048ce9:\t83 c4 fc add esp,0xfffffffc ; 不妨令该局部变量为 A 8048cec:\t8d 45 fc lea eax,[ebp-0x4] 8048cef:\t50 push eax ; 根据 GDB `p (char *)0x8049808` 可得该字符串为 `%d` 8048cf0:\t68 08 98 04 08 push 0x8049808 8048cf5:\t52 push edx 8048cf6:\te8 65 fb ff ff call 8048860 8048cfb:\t83 c4 10 add esp,0x10 ; 判断 sscanf 是否成功 8048cfe:\t83 f8 01 cmp eax,0x1 8048d01:\t75 06 jne 8048d09 ; 判断 A 和 0x0 ，如果不大于 0 则爆炸 8048d03:\t83 7d fc 00 cmp DWORD PTR [ebp-0x4],0x0 8048d07:\t7f 05 jg 8048d0e 8048d09:\te8 ee 07 00 00 call 80494fc ; sub esp, 0x4 8048d0e:\t83 c4 f4 add esp,0xfffffff4 ; A -\u003e eax 8048d11:\t8b 45 fc mov eax,DWORD PTR [ebp-0x4] ; 参数入栈并调用 func4 8048d14:\t50 push eax 8048d15:\te8 86 ff ff ff call 8048ca0 8048d1a:\t83 c4 10 add esp,0x10 ; 返回值如果不是 55 则爆炸 8048d1d:\t83 f8 37 cmp eax,0x37 8048d20:\t74 05 je 8048d27 8048d22:\te8 d5 07 00 00 call 80494fc 8048d27:\t89 ec mov esp,ebp 8048d29:\t5d pop ebp 8048d2a:\tc3 ret 8048d2b:\t90 nop 现在我们来看看func4\n; phase_4 的参数为整型 A ，在 [ebp+0x8] 08048ca0 : 8048ca0:\t55 push ebp 8048ca1:\t89 e5 mov ebp,esp 8048ca3:\t83 ec 10 sub esp,0x10 8048ca6:\t56 push esi 8048ca7:\t53 push ebx ; ebx \u003c- A 8048ca8:\t8b 5d 08 mov ebx,DWORD PTR [ebp+0x8] ; 如果 A 不大于 1 则跳转到 退出，这里应该是递归出口，返回值为 1 8048cab:\t83 fb 01 cmp ebx,0x1 8048cae:\t7e 20 jle 8048cd0 8048cb0:\t83 c4 f4 add esp,0xfffffff4 8048cb3:\t8d 43 ff lea eax,[ebx-0x1] 8048cb6:\t50 push eax ; func(A - 1) 8048cb7:\te8 e4 ff ff ff call 8048ca0 8048cbc:\t89 c6 mov esi,eax 8048cbe:\t83 c4 f4 add esp,0xfffffff4 8048cc1:\t8d 43 fe lea eax,[ebx-0x2] 8048cc4:\t50 push eax ; func(A - 2) ; 写到这里可以猜到这是斐波那契数列， ; 之前要求返回值是 55 ，所以输入应该是 9 8048cc5:\te8 d6 ff ff ff call 8048ca0 8048cca:\t01 f0 add eax,esi 8048ccc:\teb 07 jmp 8048cd5 8048cce:\t89 f6 mov esi,esi 8048cd0:\tb8 01 00 00 00 mov eax,0x1 8048cd5:\t8d 65 e8 lea esp,[ebp-0x18] 8048cd8:\t5b pop ebx 8048cd9:\t5e pop esi 8048cda:\t89 ec mov esp,ebp 8048cdc:\t5d pop ebp 8048cdd:\tc3 ret 8048cde:\t89 f6 mov esi,esi 输入9成功通过了这一关。\nphase_5 ; phase_5 的参数为字符串 input ，在 [ebp+0x8] 08048d2c : 8048d2c:\t55 push ebp 8048d2d:\t89 e5 mov ebp,esp 8048d2f:\t83 ec 10 sub esp,0x10 8048d32:\t56 push esi 8048d33:\t53 push ebx ; input -\u003e ebx 8048d34:\t8b 5d 08 mov ebx,DWORD PTR [ebp+0x8] 8048d37:\t83 c4 f4 add esp,0xfffffff4 8048d3a:\t53 push ebx ; 计算 input 字符串长度，如果长度不为 6 则爆炸 8048d3b:\te8 d8 02 00 00 call 8049018 8048d40:\t83 c4 10 add esp,0x10 8048d43:\t83 f8 06 cmp eax,0x6 8048d46:\t74 05 je 8048d4d 8048d48:\te8 af 07 00 00 call 80494fc ; 小知识：由于两数相同，所以使用 xor 来清零快一些 8048d4d:\t31 d2 xor edx,edx ; 不妨令这个变量为 str_a 8048d4f:\t8d 4d f8 lea ecx,[ebp-0x8] ; 地址 0x804b220 \"isrveawhobpnutfg\\260\\001\" ; 怀疑是通过一些操作从上述字符串中取出字符重新拼接 ; 不妨令这个字符串为 dict 8048d52:\tbe 20 b2 04 08 mov esi,0x804b220 ; 从这里开始是循环六次，后面的字符串常量长度也刚好为 6 ; al \u003c- input[edx] 8048d57:\t8a 04 1a mov al,BYTE PTR [edx+ebx*1] ; 取 al 低四位 8048d5a:\t24 0f and al,0xf ; 拓展长度到 32 位 8048d5c:\t0f be c0 movsx eax,al ; al \u003c- dict[eax] 8048d5f:\t8a 04 30 mov al,BYTE PTR [eax+esi*1] ; str_a[edx] \u003c- al 8048d62:\t88 04 0a mov BYTE PTR [edx+ecx*1],al 8048d65:\t42 inc edx 8048d66:\t83 fa 05 cmp edx,0x5 8048d69:\t7e ec jle 8048d57 ; 循环结束 ; 给字符串 str_a 结尾补上 '\\0' 8048d6b:\tc6 45 fe 00 mov BYTE PTR [ebp-0x2],0x0 8048d6f:\t83 c4 f8 add esp,0xfffffff8 ; 地址 0x804980b \"giants\" 8048d72:\t68 0b 98 04 08 push 0x804980b 8048d77:\t8d 45 f8 lea eax,[ebp-0x8] 8048d7a:\t50 push eax ; 比较 str_a 和 \"giants\" ; 所以输入字符串只看最低四位应该是 15 0 5 11 13 1 ，十六进制是 f 0 5 b d 1 ; 查看 ASCII 表，找到方便输入的内容，a-z 及其附近的字符很符合要求 ; 所以使用 o`ekma 8048d7b:\te8 b0 02 00 00 call 8049030 ...... 输入o`ekma成功通过了这一关。\nphase_6 这一关比较长，我将它分为几个部分。\n一开始就能看到局部变量被赋值到一个神秘的地址，这应该解这题的关键。之后使用了read_six_numbers这个函数读入六个数字。\n; phase_6 的参数为字符串 input ，在 [ebp+0x8] 08048d98 : ...... ; input \u003c- edx 8048da1:\t8b 55 08 mov edx,DWORD PTR [ebp+0x8] ; *(int *)0x804b26c 153 ; 不妨令该局部变量为指针 C ; C \u003c- 0x804b26c ; 它直接指向了一个神秘的结构 8048da4:\tc7 45 cc 6c b2 04 08 mov DWORD PTR [ebp-0x34],0x804b26c 8048dab:\t83 c4 f8 add esp,0xfffffff8 ; 不妨令该局部变量为数组 A 8048dae:\t8d 45 e8 lea eax,[ebp-0x18] 8048db1:\t50 push eax 8048db2:\t52 push edx 8048db3:\te8 20 02 00 00 call 8048fd8 碰到的第一个循环：\n; for (int i = 0; i \u003c= 5; ++i) { ; if (A[i] \u003e 6) ; explode_bomb(); ; for (int j = i + 1; j \u003c= 5; ++j) { ; if (A[i] == A[j]) ; explode_bomb(); ; } ; } ; edi \u003c- 0 不妨令其为 i 8048db8:\t31 ff xor edi,edi 8048dba:\t83 c4 10 add esp,0x10 8048dbd:\t8d 76 00 lea esi,[esi+0x0] ; eax \u003c- A ; 循环 6 次 8048dc0:\t8d 45 e8 lea eax,[ebp-0x18] ; eax \u003c- A[i] 8048dc3:\t8b 04 b8 mov eax,DWORD PTR [eax+edi*4] ; eax \u003c- A[i] - 1 8048dc6:\t48 dec eax ; 如果 eax 大于 5 就爆炸，不能大于 6 8048dc7:\t83 f8 05 cmp eax,0x5 8048dca:\t76 05 jbe 8048dd1 8048dcc:\te8 2b 07 00 00 call 80494fc ; ebx \u003c- i + 1 不妨令其为 j 8048dd1:\t8d 5f 01 lea ebx,[edi+0x1] ; if (j \u003c= 5) 8048dd4:\t83 fb 05 cmp ebx,0x5 8048dd7:\t7f 23 jg 8048dfc ; eax \u003c- 4 * edi 8048dd9:\t8d 04 bd 00 00 00 00 lea eax,[edi*4+0x0] ; 不妨令这个局部变量为 B ; B \u003c- 4 * edi 8048de0:\t89 45 c8 mov DWORD PTR [ebp-0x38],eax ; esi \u003c- A 8048de3:\t8d 75 e8 lea esi,[ebp-0x18] ; 内层循环 8048de6:\t8b 55 c8 mov edx,DWORD PTR [ebp-0x38] ; eax \u003c- A[i] 8048de9:\t8b 04 32 mov eax,DWORD PTR [edx+esi*1] ; 比较 A[i] 和 A[j] 8048dec:\t3b 04 9e cmp eax,DWORD PTR [esi+ebx*4] ; 如果相等则引爆炸弹 8048def:\t75 05 jne 8048df6 8048df1:\te8 06 07 00 00 call 80494fc 8048df6:\t43 inc ebx 8048df7:\t83 fb 05 cmp ebx,0x5 8048dfa:\t7e ea jle 8048de6 ; 结束内层循环 8048dfc:\t47 inc edi 8048dfd:\t83 ff 05 cmp edi,0x5 8048e00:\t7e be jle 8048dc0 ; 结束循环 至此可以得出初步结论，第一个数字一定不大于 6 ，而且任意两个数字不相等\n碰到第二个循环：\n; E = D; ; for (int i = 0, p = C; i \u003c= 5; ++i) { ; j = 1; ; while (j \u003c A[i]) { ; p = p-\u003enext; ; j++; ; } ; E[i] = p; ; } ; edi \u003c- 0 不妨令其为 i 8048e02:\t31 ff xor edi,edi ; ecx \u003c- A 8048e04:\t8d 4d e8 lea ecx,[ebp-0x18] ; 不妨令该局部变量为数组 D 8048e07:\t8d 45 d0 lea eax,[ebp-0x30] ; 不妨令该局部变量为指针 E ; E \u003c- D 8048e0a:\t89 45 c4 mov DWORD PTR [ebp-0x3c],eax 8048e0d:\t8d 76 00 lea esi,[esi+0x0] ; 循环 6 次 ; esi \u003c- C 不妨令其为指针 p ; C 初值为 0x804b26c 8048e10:\t8b 75 cc mov esi,DWORD PTR [ebp-0x34] ; ebx \u003c- 1 不妨令其为 j 8048e13:\tbb 01 00 00 00 mov ebx,0x1 8048e18:\t8d 04 bd 00 00 00 00 lea eax,[edi*4+0x0] 8048e1f:\t89 c2 mov edx,eax ; 将 j 与 A[i] 比较 8048e21:\t3b 1c 08 cmp ebx,DWORD PTR [eax+ecx*1] 8048e24:\t7d 12 jge 8048e38 ; 如果小于则执行下面这段 ; eax \u003c- A[i] 8048e26:\t8b 04 0a mov eax,DWORD PTR [edx+ecx*1] 8048e29:\t8d b4 26 00 00 00 00 lea esi,[esi+eiz*1+0x0] ; 内层循环 ; 感觉是一个链表结构 ; 猜测偏移为 0x8 的位置是 next 字段 ; p \u003c- p-\u003enext 8048e30:\t8b 76 08 mov esi,DWORD PTR [esi+0x8] ; j++ 8048e33:\t43 inc ebx ; while (j \u003c A[i]) 8048e34:\t39 c3 cmp ebx,eax 8048e36:\t7c f8 jl 8048e30 ; 结束内层循环 ; edx \u003c- E 8048e38:\t8b 55 c4 mov edx,DWORD PTR [ebp-0x3c] ; E[i] \u003c- p 8048e3b:\t89 34 ba mov DWORD PTR [edx+edi*4],esi ; i++ 8048e3e:\t47 inc edi ; while (i \u003c= 5) 8048e3f:\t83 ff 05 cmp edi,0x5 8048e42:\t7e cc jle 8048e10 ; 结束循环 使用 GDB 查看一下那个神秘地址果然有了收获：\n(gdb) x/3x 0x804b26c 0x804b26c :\t0x000000fd\t0x00000001\t0x0804b260 (gdb) x/3x 0x804b260 0x804b260 :\t0x000002d5\t0x00000002\t0x0804b254 (gdb) x/3x 0x804b254 0x804b254 :\t0x0000012d\t0x00000003\t0x0804b248 (gdb) x/3x 0x804b248 0x804b248 :\t0x000003e5\t0x00000004\t0x0804b23c (gdb) x/3x 0x804b23c 0x804b23c :\t0x000000d4\t0x00000005\t0x0804b230 (gdb) x/3x 0x804b230 0x804b230 :\t0x000001b0\t0x00000006\t0x00000000 一共有六个节点 猜测三个字段分别为：value, id, next\n碰到第三个循环：\n; p = D; ; C = D; ; for (int i = 1; i \u003c= 5; ++i) { ; p-\u003enext = D[i]; ; p = p-\u003enext; ; } ; esi \u003c- D 不妨令其为指针 p 8048e44:\t8b 75 d0 mov esi,DWORD PTR [ebp-0x30] ; C \u003c- D 8048e47:\t89 75 cc mov DWORD PTR [ebp-0x34],esi ; edi \u003c- 1 令其为 i 8048e4a:\tbf 01 00 00 00 mov edi,0x1 ; edx \u003c- D 8048e4f:\t8d 55 d0 lea edx,[ebp-0x30] ; 循环 6 次 ; eax \u003c- D[i] 8048e52:\t8b 04 ba mov eax,DWORD PTR [edx+edi*4] ; p-\u003enext \u003c- D[i] 8048e55:\t89 46 08 mov DWORD PTR [esi+0x8],eax ; p \u003c- p-\u003enext 8048e58:\t89 c6 mov esi,eax ; i++ 8048e5a:\t47 inc edi ; while (i \u003c= 5) 8048e5b:\t83 ff 05 cmp edi,0x5 8048e5e:\t7e f2 jle 8048e52 ; 结束循环 ; p-\u003enext = NULL; 8048e60:\tc7 46 08 00 00 00 00 mov DWORD PTR [esi+0x8],0x0 上面这部分代码相当于把数组D串起来变为一个链表。\n碰到第四个循环：\n; p = C; ; for (int i = 0; i \u003c= 4; ++i) { ; if (p-\u003evalue \u003c p-\u003enext-\u003evalue) ; explode_bomb(); ; p = p-\u003enext; ; i++; ; } ; 数组 D 组成的数列应该递减 ; 所以我们可以将 6 个 node 排序 ; 从大到小：node4 node2 node 6 node3 node1 node5 8048e67:\t8b 75 cc mov esi,DWORD PTR [ebp-0x34] 8048e6a:\t31 ff xor edi,edi 8048e6c:\t8d 74 26 00 lea esi,[esi+eiz*1+0x0] ; 循环 5 次 ; edx \u003c- p-\u003enext 8048e70:\t8b 56 08 mov edx,DWORD PTR [esi+0x8] ; eax \u003c- p-\u003evalue 8048e73:\t8b 06 mov eax,DWORD PTR [esi] ; 将 p-\u003evalue 和 p-\u003enext-\u003evalue 比较 ; 即如果小于，则爆炸 8048e75:\t3b 02 cmp eax,DWORD PTR [edx] 8048e77:\t7d 05 jge 8048e7e 8048e79:\te8 7e 06 00 00 call 80494fc ; p \u003c- p-\u003enext 8048e7e:\t8b 76 08 mov esi,DWORD PTR [esi+0x8] ; i++ 8048e81:\t47 inc edi ; while (i \u003c= 4) 8048e82:\t83 ff 04 cmp edi,0x4 8048e85:\t7e e9 jle 8048e70 ; 结束循环 由于从大到小是node4, node2, node6, node3, node1, node5。\n输入字符串4 2 6 3 1 5便能通过这关。\nsecret_phase 其实在 6 关之后还有一个隐藏关卡，需要一定的条件触发。\n可以直接在bomb.disas里面查找函数secret_phase，然后可以发现它在函数phase_defused中被调用。\n首先在phase_6打上断点，发现在phase_defused中发现有怪异之处：\n8049543:\t50 push eax ; 格式化字符串 ; (gdb) x/s 0x8049d03 ; 0x8049d03:\t\"%d %s\" 8049544:\t68 03 9d 04 08 push 0x8049d03 ; 没有解锁隐藏关卡时，输入字符串只有一个 9 ，这与两个占位符的不相符 ; 所以我们应该在 9 后面补上一个字符串 ; 在 phase_6 打上断点 ; (gdb) break phase_6 ; (gdb) run ; (gdb) x/s 0x804b770 ; 0x804b770 :\t\"9\" 8049549:\t68 70 b7 04 08 push 0x804b770 804954e:\te8 0d f3 ff ff call 8048860 8049553:\t83 c4 10 add esp,0x10 发现这里有个用于调试的标签input_strings，我们可以看看input_strings +0 +80 +160 都是什么：\n(gdb) x/s 0x804b770-240 0x804b680 :\t\"Public speaking is very easy.\" (gdb) x/s 0x804b770-240+80 0x804b6d0 :\t\"1 2 6 24 120 720\" (gdb) x/s 0x804b770-240+160 0x804b720 :\t\"0 q 777\" 发现是前三关输入的字符，所以\"9\"对应的是我们第四关的输入\n; 如果成功给两个参数赋值 8049556:\t83 f8 02 cmp eax,0x2 8049559:\t75 37 jne 8049592 804955b:\t83 c4 f8 add esp,0xfffffff8 ; 字符串比对 ; (gdb) x/s 0x8049d09 ; 0x8049d09:\t\"austinpowers\" ; 可以得知第四关时后面应该添加一个\"austinpowers\" ; 由此可以进入隐藏关卡 ...... 804958d:\te8 56 f9 ff ff call 8048ee8 现在我们开始看函数secret_phase：\n08048ee8 : 8048ee8:\t55 push ebp 8048ee9:\t89 e5 mov ebp,esp 8048eeb:\t83 ec 14 sub esp,0x14 8048eee:\t53 push ebx ; 将输入的字符串转换为数字 ; 返回值在 eax 8048eef:\te8 08 03 00 00 call 80491fc 8048ef4:\t6a 00 push 0x0 8048ef6:\t6a 0a push 0xa 8048ef8:\t6a 00 push 0x0 8048efa:\t50 push eax 8048efb:\te8 f0 f8 ff ff call 80487f0 \u003c__strtol_internal@plt\u003e 8048f00:\t83 c4 10 add esp,0x10 8048f03:\t89 c3 mov ebx,eax 8048f05:\t8d 43 ff lea eax,[ebx-0x1] ; 如果 input-1 大于 0x3e8 则爆炸 8048f08:\t3d e8 03 00 00 cmp eax,0x3e8 8048f0d:\t76 05 jbe 8048f14 8048f0f:\te8 e8 05 00 00 call 80494fc 8048f14:\t83 c4 f8 add esp,0xfffffff8 8048f17:\t53 push ebx ; 该地址可能指向一个数组或者结构 8048f18:\t68 20 b3 04 08 push 0x804b320 8048f1d:\te8 72 ff ff ff call 8048e94 8048f22:\t83 c4 10 add esp,0x10 ; 如果返回值为 7 则成功 8048f25:\t83 f8 07 cmp eax,0x7 8048f28:\t74 05 je 8048f2f ...... 由于调用了函数fun7，我们直接来看它。func7是一个比较简单的递归函数，主要是结构体较为复杂：\n08048e94 : 8048e94:\t55 push ebp 8048e95:\t89 e5 mov ebp,esp 8048e97:\t83 ec 08 sub esp,0x8 8048e9a:\t8b 55 08 mov edx,DWORD PTR [ebp+0x8] 8048e9d:\t8b 45 0c mov eax,DWORD PTR [ebp+0xc] 8048ea0:\t85 d2 test edx,edx 8048ea2:\t75 0c jne 8048eb0 8048ea4:\tb8 ff ff ff ff mov eax,0xffffffff 8048ea9:\teb 37 jmp 8048ee2 8048eab:\t90 nop 8048eac:\t8d 74 26 00 lea esi,[esi+eiz*1+0x0] 8048eb0:\t3b 02 cmp eax,DWORD PTR [edx] 8048eb2:\t7d 11 jge 8048ec5 8048eb4:\t83 c4 f8 add esp,0xfffffff8 8048eb7:\t50 push eax ; 类似链表的结构 8048eb8:\t8b 42 04 mov eax,DWORD PTR [edx+0x4] 8048ebb:\t50 push eax 8048ebc:\te8 d3 ff ff ff call 8048e94 8048ec1:\t01 c0 add eax,eax 8048ec3:\teb 1d jmp 8048ee2 8048ec5:\t3b 02 cmp eax,DWORD PTR [edx] 8048ec7:\t74 17 je 8048ee0 8048ec9:\t83 c4 f8 add esp,0xfffffff8 8048ecc:\t50 push eax ; 类似链表的结构 8048ecd:\t8b 42 08 mov eax,DWORD PTR [edx+0x8] 8048ed0:\t50 push eax 8048ed1:\te8 be ff ff ff call 8048e94 8048ed6:\t01 c0 add eax,eax 8048ed8:\t40 inc eax 8048ed9:\teb 07 jmp 8048ee2 8048edb:\t90 nop 8048edc:\t8d 74 26 00 lea esi,[esi+eiz*1+0x0] 8048ee0:\t31 c0 xor eax,eax 8048ee2:\t89 ec mov esp,ebp 8048ee4:\t5d pop ebp 8048ee5:\tc3 ret 8048ee6:\t89 f6 mov esi,esi 可以看到有类似链表的结构，但是它拥有两个指针域，我们可以把它想象为一棵树：\n// fun7 输入参数：指针 p 和 整型 n // p 可以理解为二叉树的节点 typedef struct TreeNode { int value; struct TreeNode *left; struct TreeNode *right; } TreeNode; 这样一来fun7马上可以写成 C 语言：\nint fun7(TreeNode *p, int n) { if (p == 0) { return -1; } else { if (n-\u003evalue \u003c p[0]) { return 2 * fun7(p-\u003eleft, n); } else if (n == p[0]) { return 0; } else { return 2 * fun7(p-\u003eright, n) + 1; } } } 由于需要递归函数返回 7 (参数(p, n))，所以内一层只能返回 3 (参数(p-\u003eright, n))， 再内一层只能返回 1 (p-\u003eright-\u003eright, n)，最里面一层返回 0 (p-\u003eright-\u003eright-\u003eright, n)。 所以第一次调用时p-\u003erigh-\u003eright-\u003eright-\u003evalue应该与n相等\n可以通过 GDB 很快找到：\n# value left right (gdb) x/3x 0x804b320 0x804b320 : 0x00000024 0x0804b314 0x0804b308 (gdb) x/3x 0x0804b308 0x804b308 : 0x00000032 0x0804b2f0 0x0804b2d8 (gdb) x/3x 0x0804b2d8 0x804b2d8 : 0x0000006b 0x0804b2b4 0x0804b278 (gdb) x/3x 0x0804b278 0x804b278 : 0x000003e9 0x00000000 0x00000000 所以应该输入3e9也就是十进制1001。\n输入文件 如下是最后通过测试的输入文件：\n$ cat input Public speaking is very easy. 1 2 6 24 120 720 0 q 777 9 austinpowers o`ekma 4 2 6 3 1 5 1001 实验感受 这六关分别涉及了字符串常量、循环、switch-case（跳转表）、递归、数组、链表等知识，难度没有想象中那么大，耐心看汇编代码其实是很容易看懂的。而隐藏关卡需要细心或者运气发现，但是解决它并不是问题。\n做 Lab 时没有动态调试这个程序，感觉也没有动态调试的必要，只要看到了“魔法”地址就可以直接 GDB 查看它。\n",
  "wordCount" : "5980",
  "inLanguage": "zh",
  "image":"https://vaaandark.top/image/bomb.jpg","datePublished": "2022-10-29T22:24:22Z",
  "dateModified": "2022-10-29T22:24:22Z",
  "author":{
    "@type": "Person",
    "name": "vaaandark"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://vaaandark.top/posts/csapp-bomb-lab/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "vaaandark's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://vaaandark.top/image/vaaandark.png"
    }
  }
}
</script>


</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://vaaandark.top/" accesskey="h" title="vaaandark&#39;s blog (Alt + H)">
                <img src="https://vaaandark.top/image/vaaandark.png" alt="" aria-label="logo"
                    height="35">vaaandark&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://vaaandark.top/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://vaaandark.top/posts/" title="Posts">
                    <span>📄 归档</span>
                </a>
            </li>
            <li>
                <a href="https://vaaandark.top/categories/" title="categories">
                    <span>📂 分类</span>
                </a>
            </li>
            <li>
                <a href="https://vaaandark.top/tags/" title="tags">
                    <span>🔖 标签</span>
                </a>
            </li>
            <li>
                <a href="https://vaaandark.top/about/" title="关于我">
                    <span>🙋 关于</span>
                </a>
            </li>
            <li>
                <a href="https://vaaandark.top/links/" title="友链">
                    <span>🤝 友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://vaaandark.top/">主页</a>&nbsp;»&nbsp;<a href="https://vaaandark.top/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      CSAPP Bomb Lab
    </h1>
    <div class="post-meta"><span title='2022-10-29 22:24:22 +0000 UTC'>2022 10月 29</span>&nbsp;·&nbsp;12 分钟&nbsp;·&nbsp;vaaandark

</div>
  </header> 
<figure class="entry-cover"><img loading="eager" src="https://vaaandark.top/image/bomb.jpg" alt="">
        
</figure><div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%ae%9e%e9%aa%8c%e7%ae%80%e8%bf%b0" aria-label="实验简述">实验简述</a></li>
                <li>
                    <a href="#%e5%ae%9e%e9%aa%8c%e7%8e%af%e5%a2%83" aria-label="实验环境">实验环境</a></li>
                <li>
                    <a href="#%e5%ae%9e%e9%aa%8c%e8%bf%87%e7%a8%8b" aria-label="实验过程">实验过程</a><ul>
                        
                <li>
                    <a href="#phase_1" aria-label="phase_1">phase_1</a></li>
                <li>
                    <a href="#phase_2" aria-label="phase_2">phase_2</a></li>
                <li>
                    <a href="#phase_3" aria-label="phase_3">phase_3</a></li>
                <li>
                    <a href="#phase_4" aria-label="phase_4">phase_4</a></li>
                <li>
                    <a href="#phase_5" aria-label="phase_5">phase_5</a></li>
                <li>
                    <a href="#phase_6" aria-label="phase_6">phase_6</a></li>
                <li>
                    <a href="#secret_phase" aria-label="secret_phase">secret_phase</a></li>
                <li>
                    <a href="#%e8%be%93%e5%85%a5%e6%96%87%e4%bb%b6" aria-label="输入文件">输入文件</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e9%aa%8c%e6%84%9f%e5%8f%97" aria-label="实验感受">实验感受</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>之前的 Bomb Lab 没有做，现在刚好在上计算机系统基础这门课，学校使用了 CSAPP 的 Bomb Lab ，可以补交一下 CSAPP 的作业，也可以学习一下 GDB 的使用。</p>
<h2 id="实验简述">实验简述<a hidden class="anchor" aria-hidden="true" href="#实验简述">#</a></h2>
<p>遗憾地，CSAPP 的 Bomb Lab 早已提供的是 Linux 的 64 位可执行程序，而我校的 Lab 还是 32 位的 Windows PE32 。不过我还是找老师要到了它的 Linux 版本，不过也是 ELF32 ，可执行文件的名字叫<code>bomb_32</code>。</p>
<p>该 Lab 是 CSAPP Bomb Lab 的老版 32 位程序，所以之后我还是看一下新版的 Bomb Lab 较好，不能完全不了解 64 位汇编嘛 :(</p>
<h2 id="实验环境">实验环境<a hidden class="anchor" aria-hidden="true" href="#实验环境">#</a></h2>
<ul>
<li>GNU gdb (GDB) Fedora 12.1-2.fc36</li>
<li>GNU objdump version 2.37-36.fc36</li>
</ul>
<h2 id="实验过程">实验过程<a hidden class="anchor" aria-hidden="true" href="#实验过程">#</a></h2>
<p>首先反汇编生成汇编代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>$ objdump -S -C bomb_32 &gt; bomb.disas
</span></span></code></pre></div><p>由于我不是很会看 AT&amp;T 的汇编代码，所以我的 objdump 是 aliased 的，默认使用 Intel 的语法。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>$ which objdump
</span></span><span style="display:flex;"><span>objdump=&#39;objdump --disassembler-options=intel&#39;
</span></span><span style="display:flex;"><span>        /usr/bin/objdump
</span></span></code></pre></div><p>gdb 也默认使用 Intel 的语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>$ cat ~/.gdbinit
</span></span><span style="display:flex;"><span>set disassembly-flavor intel
</span></span></code></pre></div><p>再使用 gdb 开始调试程序：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>$ gdb --args ./bomb_32 input
</span></span></code></pre></div><h3 id="phase_1">phase_1<a hidden class="anchor" aria-hidden="true" href="#phase_1">#</a></h3>
<p>由于老师给了这个程序运行的流程图，我也看过 Bomb Lab 中提供的 .c 文件，所以我知道每个字符串都在<code>phase_n</code>的函数中输入或者检验。</p>
<p>可以直接查看<code>phase_1</code>函数的反汇编代码，并注意到这个函数中的一个函数调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>(gdb) disas phase_1
</span></span><span style="display:flex;"><span>Dump of assembler code for function phase_1:
</span></span><span style="display:flex;"><span>   ......
</span></span><span style="display:flex;"><span>   0x08048b2c &lt;+12&gt;:	push   0x80497c0
</span></span><span style="display:flex;"><span>   0x08048b31 &lt;+17&gt;:	push   eax
</span></span><span style="display:flex;"><span>   0x08048b32 &lt;+18&gt;:	call   0x8049030 &lt;strings_not_equal&gt;
</span></span><span style="display:flex;"><span>   ......
</span></span></code></pre></div><p>可以看到它在压入两个参数之后调用了一个函数<code>strings_not_equal</code>，我们直接查看<code>0x80497c0</code>里面是什么内容，我首先猜测它是一个字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>(gdb) p (char *)0x80497c0
</span></span><span style="display:flex;"><span>$1 = 0x80497c0 &#34;Public speaking is very easy.&#34;
</span></span></code></pre></div><p>在之后的测试中，这个字符串也让我过了第一关。</p>
<h3 id="phase_2">phase_2<a hidden class="anchor" aria-hidden="true" href="#phase_2">#</a></h3>
<p>直接查看<code>phase_2</code>的汇编代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>; phase_2 的参数为字符串 input ，在 [ebp+0x8]
</span></span><span style="display:flex;"><span>08048b48 &lt;phase_2&gt;:
</span></span><span style="display:flex;"><span> 8048b48:	55                   	push   ebp
</span></span><span style="display:flex;"><span> 8048b49:	89 e5                	mov    ebp,esp
</span></span><span style="display:flex;"><span> ; 为局部变量腾出空间
</span></span><span style="display:flex;"><span> 8048b4b:	83 ec 20             	sub    esp,0x20
</span></span><span style="display:flex;"><span> ; 可能是内部调用的函数需要使用这两个寄存器
</span></span><span style="display:flex;"><span> ; 所以根据 caller save 在这里保存
</span></span><span style="display:flex;"><span> 8048b4e:	56                   	push   esi
</span></span><span style="display:flex;"><span> 8048b4f:	53                   	push   ebx
</span></span><span style="display:flex;"><span> ; 将 input 放入 edx 中
</span></span><span style="display:flex;"><span> 8048b50:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
</span></span><span style="display:flex;"><span> ; 等于 sub esp, 0x8
</span></span><span style="display:flex;"><span> 8048b53:	83 c4 f8             	add    esp,0xfffffff8
</span></span><span style="display:flex;"><span> ; 将局部变量的地址 [ebp-0x18] 放入 eax 中
</span></span><span style="display:flex;"><span> ; 不妨给它起名为变量 A
</span></span><span style="display:flex;"><span> ; 由于给局部变量预留的位置很大，猜测 A 是一个数组
</span></span><span style="display:flex;"><span> 8048b56:	8d 45 e8             	lea    eax,[ebp-0x18]
</span></span><span style="display:flex;"><span> ; 压栈传参，传入的是 input, A
</span></span><span style="display:flex;"><span> 8048b59:	50                   	push   eax
</span></span><span style="display:flex;"><span> 8048b5a:	52                   	push   edx
</span></span><span style="display:flex;"><span> ; 调用函数 read_six_numbers 根据名字合理怀疑这里是读入六个数字，A 可能有 6 个元素
</span></span><span style="display:flex;"><span> 8048b5b:	e8 78 04 00 00       	call   8048fd8 &lt;read_six_numbers&gt;
</span></span><span style="display:flex;"><span> ; 这里 esp 加了 0x10 相当于把之前的参数退栈了，还把之前 add esp,0xfffffff8 的加回去了。我猜测之前的 add 可能和内存对齐有关
</span></span><span style="display:flex;"><span> 8048b60:	83 c4 10             	add    esp,0x10
</span></span><span style="display:flex;"><span> ; 将 A[0] 与 1 比较
</span></span><span style="display:flex;"><span> ; 由于之前传递的是地址，这个变量应该在 read_six_numbers 中被修改了
</span></span><span style="display:flex;"><span> 8048b63:	83 7d e8 01          	cmp    DWORD PTR [ebp-0x18],0x1
</span></span><span style="display:flex;"><span> ; 如果是 1 则成功，不是 1 则引爆炸弹
</span></span><span style="display:flex;"><span> 8048b67:	74 05                	je     8048b6e &lt;phase_2+0x26&gt;
</span></span><span style="display:flex;"><span> 8048b69:	e8 8e 09 00 00       	call   80494fc &lt;explode_bomb&gt;
</span></span><span style="display:flex;"><span> ; ebx &lt;- 0x1
</span></span><span style="display:flex;"><span> 8048b6e:	bb 01 00 00 00       	mov    ebx,0x1
</span></span><span style="display:flex;"><span> ; 将 A 放入 esi 中
</span></span><span style="display:flex;"><span> 8048b73:	8d 75 e8             	lea    esi,[ebp-0x18]
</span></span><span style="display:flex;"><span> ; eax &lt;- 0x2
</span></span><span style="display:flex;"><span> 8048b76:	8d 43 01             	lea    eax,[ebx+0x1]
</span></span><span style="display:flex;"><span> ; 这步骤操作之后 eax 的值为 (ebx + 1) * A[ebx - 1]
</span></span><span style="display:flex;"><span> ; ebx 初始为 1
</span></span><span style="display:flex;"><span> 8048b79:	0f af 44 9e fc       	imul   eax,DWORD PTR [esi+ebx*4-0x4]
</span></span><span style="display:flex;"><span> ; 相当于判断 A[ebx] 是不是 A[ebx - 1] 两倍
</span></span><span style="display:flex;"><span> 8048b7e:	39 04 9e             	cmp    DWORD PTR [esi+ebx*4],eax
</span></span><span style="display:flex;"><span> 8048b81:	74 05                	je     8048b88 &lt;phase_2+0x40&gt;
</span></span><span style="display:flex;"><span> 8048b83:	e8 74 09 00 00       	call   80494fc &lt;explode_bomb&gt;
</span></span><span style="display:flex;"><span> 8048b88:	43                   	inc    ebx
</span></span><span style="display:flex;"><span> 8048b89:	83 fb 05             	cmp    ebx,0x5
</span></span><span style="display:flex;"><span> ; 我读到这里才发现是一个循环，终止条件为 ebx &gt; 5
</span></span><span style="display:flex;"><span> 8048b8c:	7e e8                	jle    8048b76 &lt;phase_2+0x2e&gt;
</span></span><span style="display:flex;"><span> ; 所以根据递推公式可知字符串为 1 2 6 24 120 720
</span></span><span style="display:flex;"><span> 8048b8e:	8d 65 d8             	lea    esp,[ebp-0x28]
</span></span><span style="display:flex;"><span> 8048b91:	5b                   	pop    ebx
</span></span><span style="display:flex;"><span> 8048b92:	5e                   	pop    esi
</span></span><span style="display:flex;"><span> 8048b93:	89 ec                	mov    esp,ebp
</span></span><span style="display:flex;"><span> 8048b95:	5d                   	pop    ebp
</span></span><span style="display:flex;"><span> 8048b96:	c3                   	ret    
</span></span><span style="display:flex;"><span> 8048b97:	90                   	nop
</span></span></code></pre></div><p>它调用了函数<code>read_six_numbers</code>，所以我们也分析一下它：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>; 参数为字符串 input 和数组 A
</span></span><span style="display:flex;"><span>08048fd8 &lt;read_six_numbers&gt;:
</span></span><span style="display:flex;"><span> 8048fd8:	55                   	push   ebp
</span></span><span style="display:flex;"><span> 8048fd9:	89 e5                	mov    ebp,esp
</span></span><span style="display:flex;"><span> 8048fdb:	83 ec 08             	sub    esp,0x8
</span></span><span style="display:flex;"><span> ; 传入的输入字符串
</span></span><span style="display:flex;"><span> 8048fde:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
</span></span><span style="display:flex;"><span> ; 传入的数组 A
</span></span><span style="display:flex;"><span> 8048fe1:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
</span></span><span style="display:flex;"><span> ; A[5]
</span></span><span style="display:flex;"><span> 8048fe4:	8d 42 14             	lea    eax,[edx+0x14]
</span></span><span style="display:flex;"><span> 8048fe7:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; A[4]
</span></span><span style="display:flex;"><span> 8048fe8:	8d 42 10             	lea    eax,[edx+0x10]
</span></span><span style="display:flex;"><span> 8048feb:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; A[3]
</span></span><span style="display:flex;"><span> 8048fec:	8d 42 0c             	lea    eax,[edx+0xc]
</span></span><span style="display:flex;"><span> 8048fef:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; A[2]
</span></span><span style="display:flex;"><span> 8048ff0:	8d 42 08             	lea    eax,[edx+0x8]
</span></span><span style="display:flex;"><span> 8048ff3:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; A[1]
</span></span><span style="display:flex;"><span> 8048ff4:	8d 42 04             	lea    eax,[edx+0x4]
</span></span><span style="display:flex;"><span> 8048ff7:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; A[0]
</span></span><span style="display:flex;"><span> 8048ff8:	52                   	push   edx
</span></span><span style="display:flex;"><span> ; format 字符串 &#34;%d %d %d %d %d %d&#34;
</span></span><span style="display:flex;"><span> 8048ff9:	68 1b 9b 04 08       	push   0x8049b1b
</span></span><span style="display:flex;"><span> ; input 输入字符串
</span></span><span style="display:flex;"><span> 8048ffe:	51                   	push   ecx
</span></span><span style="display:flex;"><span> 8048fff:	e8 5c f8 ff ff       	call   8048860 &lt;sscanf@plt&gt;
</span></span><span style="display:flex;"><span> 8049004:	83 c4 20             	add    esp,0x20
</span></span><span style="display:flex;"><span> 8049007:	83 f8 05             	cmp    eax,0x5
</span></span><span style="display:flex;"><span> 804900a:	7f 05                	jg     8049011 &lt;read_six_numbers+0x39&gt;
</span></span><span style="display:flex;"><span> 804900c:	e8 eb 04 00 00       	call   80494fc &lt;explode_bomb&gt;
</span></span><span style="display:flex;"><span> 8049011:	89 ec                	mov    esp,ebp
</span></span><span style="display:flex;"><span> 8049013:	5d                   	pop    ebp
</span></span><span style="display:flex;"><span> 8049014:	c3                   	ret    
</span></span><span style="display:flex;"><span> 8049015:	8d 76 00             	lea    esi,[esi+0x0]
</span></span></code></pre></div><p>使用字符串<code>1 2 6 24 120 720</code>成功通过第二关。</p>
<h3 id="phase_3">phase_3<a hidden class="anchor" aria-hidden="true" href="#phase_3">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>; phase_3 的参数为字符串 input ，在 [ebp+0x8]
</span></span><span style="display:flex;"><span>08048b98 &lt;phase_3&gt;:
</span></span><span style="display:flex;"><span> 8048b98:	55                   	push   ebp
</span></span><span style="display:flex;"><span> 8048b99:	89 e5                	mov    ebp,esp
</span></span><span style="display:flex;"><span> ; 预留 20 个字节
</span></span><span style="display:flex;"><span> 8048b9b:	83 ec 14             	sub    esp,0x14
</span></span><span style="display:flex;"><span> 8048b9e:	53                   	push   ebx
</span></span><span style="display:flex;"><span> ; 将 input 放入 edx
</span></span><span style="display:flex;"><span> 8048b9f:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
</span></span><span style="display:flex;"><span> ; sub esp, 0x4
</span></span><span style="display:flex;"><span> 8048ba2:	83 c4 f4             	add    esp,0xfffffff4
</span></span><span style="display:flex;"><span> ; 
</span></span><span style="display:flex;"><span> ; int_b
</span></span><span style="display:flex;"><span> 8048ba5:	8d 45 fc             	lea    eax,[ebp-0x4]
</span></span><span style="display:flex;"><span> 8048ba8:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; char_c
</span></span><span style="display:flex;"><span> 8048ba9:	8d 45 fb             	lea    eax,[ebp-0x5]
</span></span><span style="display:flex;"><span> 8048bac:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; int_a
</span></span><span style="display:flex;"><span> 8048bad:	8d 45 f4             	lea    eax,[ebp-0xc]
</span></span><span style="display:flex;"><span> 8048bb0:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; 通过 GBD 调试可以知道这个地址内容为 &#34;%d %c %d&#34;
</span></span><span style="display:flex;"><span> 8048bb1:	68 de 97 04 08       	push   0x80497de
</span></span><span style="display:flex;"><span> ; input
</span></span><span style="display:flex;"><span> 8048bb6:	52                   	push   edx
</span></span><span style="display:flex;"><span> 8048bb7:	e8 a4 fc ff ff       	call   8048860 &lt;sscanf@plt&gt;
</span></span><span style="display:flex;"><span> 8048bbc:	83 c4 20             	add    esp,0x20
</span></span><span style="display:flex;"><span> ; 如果 sscanf 匹配并赋值的个数不多于 2 ，则爆炸
</span></span><span style="display:flex;"><span> 8048bbf:	83 f8 02             	cmp    eax,0x2
</span></span><span style="display:flex;"><span> 8048bc2:	7f 05                	jg     8048bc9 &lt;phase_3+0x31&gt;
</span></span><span style="display:flex;"><span> 8048bc4:	e8 33 09 00 00       	call   80494fc &lt;explode_bomb&gt;
</span></span><span style="display:flex;"><span> ; 将 int_a 与 0x7 比较
</span></span><span style="display:flex;"><span> ; 怀疑是一个防止数组越界的操作
</span></span><span style="display:flex;"><span> 8048bc9:	83 7d f4 07          	cmp    DWORD PTR [ebp-0xc],0x7
</span></span><span style="display:flex;"><span> ; 如果大于则爆炸
</span></span><span style="display:flex;"><span> 8048bcd:	0f 87 b5 00 00 00    	ja     8048c88 &lt;phase_3+0xf0&gt;
</span></span><span style="display:flex;"><span> ; 将 int_a 赋值给 eax
</span></span><span style="display:flex;"><span> 8048bd3:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
</span></span><span style="display:flex;"><span> ; 这里存在一个跳转表，对应到 C 语言中应该是一个 switch-case 结构
</span></span><span style="display:flex;"><span> ; 可以在 gdb 里面查看一下对应的表 `(gdb) p/x *(int *)0x80497e8`
</span></span><span style="display:flex;"><span> ; [0x80497e8] 对应 8048be0
</span></span><span style="display:flex;"><span> ; [0x80497e8+1*4] 对应 8048c00
</span></span><span style="display:flex;"><span> ; [0x80497e8+2*4] 对应 8048c16
</span></span><span style="display:flex;"><span> ; [0x80497e8+3*4] 对应 8048c28
</span></span><span style="display:flex;"><span> ; [0x80497e8+4*4] 对应 8048c40
</span></span><span style="display:flex;"><span> ; [0x80497e8+5*4] 对应 8048c52
</span></span><span style="display:flex;"><span> ; [0x80497e8+6*4] 对应 8048c64
</span></span><span style="display:flex;"><span> ; [0x80497e8+7*4] 对应 8048c76
</span></span><span style="display:flex;"><span> ; switch-case(int_a)
</span></span><span style="display:flex;"><span> 8048bd6:	ff 24 85 e8 97 04 08 	jmp    DWORD PTR [eax*4+0x80497e8]
</span></span><span style="display:flex;"><span> 8048bdd:	8d 76 00             	lea    esi,[esi+0x0]
</span></span><span style="display:flex;"><span> ; case 0:
</span></span><span style="display:flex;"><span> ; bl &lt;- 0x71
</span></span><span style="display:flex;"><span> 8048be0:	b3 71                	mov    bl,0x71
</span></span><span style="display:flex;"><span> ; 将 int_b 与 0x309 比较
</span></span><span style="display:flex;"><span> 8048be2:	81 7d fc 09 03 00 00 	cmp    DWORD PTR [ebp-0x4],0x309
</span></span><span style="display:flex;"><span> ; 如果等于就 break
</span></span><span style="display:flex;"><span> 8048be9:	0f 84 a0 00 00 00    	je     8048c8f &lt;phase_3+0xf7&gt;
</span></span><span style="display:flex;"><span> 8048bef:	e8 08 09 00 00       	call   80494fc &lt;explode_bomb&gt;
</span></span><span style="display:flex;"><span> 8048bf4:	e9 96 00 00 00       	jmp    8048c8f &lt;phase_3+0xf7&gt;
</span></span><span style="display:flex;"><span> ; eiz 是一个伪寄存器，它始终为 0
</span></span><span style="display:flex;"><span> 8048bf9:	8d b4 26 00 00 00 00 	lea    esi,[esi+eiz*1+0x0]
</span></span><span style="display:flex;"><span> ; 后面几个 case 都是相同的道理
</span></span><span style="display:flex;"><span> ......
</span></span><span style="display:flex;"><span> ; bl 与 char_c 比较
</span></span><span style="display:flex;"><span> 8048c8f:	3a 5d fb             	cmp    bl,BYTE PTR [ebp-0x5]
</span></span><span style="display:flex;"><span> ; 所以基本流程就是根据 int_a 的值确定进去哪一个 case ，
</span></span><span style="display:flex;"><span> ; 然后在该分支中将 int_b 和某一值比较，并确定 char_c 应该等于的值
</span></span><span style="display:flex;"><span> ; 所以答案应该不唯一，通过 int_a 的值确定后面两个答案
</span></span><span style="display:flex;"><span> ......
</span></span></code></pre></div><p>我使用<code>0 q 777</code>通过了这一关。</p>
<h3 id="phase_4">phase_4<a hidden class="anchor" aria-hidden="true" href="#phase_4">#</a></h3>
<p>这一关包含了递归函数，但是挑战性不是很大。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>; phase_4 的参数为字符串 input ，在 [ebp+0x8]
</span></span><span style="display:flex;"><span>08048ce0 &lt;phase_4&gt;:
</span></span><span style="display:flex;"><span> 8048ce0:	55                   	push   ebp
</span></span><span style="display:flex;"><span> 8048ce1:	89 e5                	mov    ebp,esp
</span></span><span style="display:flex;"><span> 8048ce3:	83 ec 18             	sub    esp,0x18
</span></span><span style="display:flex;"><span> ; input -&gt; edx
</span></span><span style="display:flex;"><span> 8048ce6:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
</span></span><span style="display:flex;"><span> ; sub esp, 0xc
</span></span><span style="display:flex;"><span> 8048ce9:	83 c4 fc             	add    esp,0xfffffffc
</span></span><span style="display:flex;"><span> ; 不妨令该局部变量为 A
</span></span><span style="display:flex;"><span> 8048cec:	8d 45 fc             	lea    eax,[ebp-0x4]
</span></span><span style="display:flex;"><span> 8048cef:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; 根据 GDB `p (char *)0x8049808` 可得该字符串为 `%d`
</span></span><span style="display:flex;"><span> 8048cf0:	68 08 98 04 08       	push   0x8049808
</span></span><span style="display:flex;"><span> 8048cf5:	52                   	push   edx
</span></span><span style="display:flex;"><span> 8048cf6:	e8 65 fb ff ff       	call   8048860 &lt;sscanf@plt&gt;
</span></span><span style="display:flex;"><span> 8048cfb:	83 c4 10             	add    esp,0x10
</span></span><span style="display:flex;"><span> ; 判断 sscanf 是否成功
</span></span><span style="display:flex;"><span> 8048cfe:	83 f8 01             	cmp    eax,0x1
</span></span><span style="display:flex;"><span> 8048d01:	75 06                	jne    8048d09 &lt;phase_4+0x29&gt;
</span></span><span style="display:flex;"><span> ; 判断 A 和 0x0 ，如果不大于 0 则爆炸
</span></span><span style="display:flex;"><span> 8048d03:	83 7d fc 00          	cmp    DWORD PTR [ebp-0x4],0x0
</span></span><span style="display:flex;"><span> 8048d07:	7f 05                	jg     8048d0e &lt;phase_4+0x2e&gt;
</span></span><span style="display:flex;"><span> 8048d09:	e8 ee 07 00 00       	call   80494fc &lt;explode_bomb&gt;
</span></span><span style="display:flex;"><span> ; sub esp, 0x4
</span></span><span style="display:flex;"><span> 8048d0e:	83 c4 f4             	add    esp,0xfffffff4
</span></span><span style="display:flex;"><span> ; A -&gt; eax
</span></span><span style="display:flex;"><span> 8048d11:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
</span></span><span style="display:flex;"><span> ; 参数入栈并调用 func4
</span></span><span style="display:flex;"><span> 8048d14:	50                   	push   eax
</span></span><span style="display:flex;"><span> 8048d15:	e8 86 ff ff ff       	call   8048ca0 &lt;func4&gt;
</span></span><span style="display:flex;"><span> 8048d1a:	83 c4 10             	add    esp,0x10
</span></span><span style="display:flex;"><span> ; 返回值如果不是 55 则爆炸
</span></span><span style="display:flex;"><span> 8048d1d:	83 f8 37             	cmp    eax,0x37
</span></span><span style="display:flex;"><span> 8048d20:	74 05                	je     8048d27 &lt;phase_4+0x47&gt;
</span></span><span style="display:flex;"><span> 8048d22:	e8 d5 07 00 00       	call   80494fc &lt;explode_bomb&gt;
</span></span><span style="display:flex;"><span> 8048d27:	89 ec                	mov    esp,ebp
</span></span><span style="display:flex;"><span> 8048d29:	5d                   	pop    ebp
</span></span><span style="display:flex;"><span> 8048d2a:	c3                   	ret    
</span></span><span style="display:flex;"><span> 8048d2b:	90                   	nop
</span></span></code></pre></div><p>现在我们来看看<code>func4</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>; phase_4 的参数为整型 A ，在 [ebp+0x8]
</span></span><span style="display:flex;"><span>08048ca0 &lt;func4&gt;:
</span></span><span style="display:flex;"><span> 8048ca0:	55                   	push   ebp
</span></span><span style="display:flex;"><span> 8048ca1:	89 e5                	mov    ebp,esp
</span></span><span style="display:flex;"><span> 8048ca3:	83 ec 10             	sub    esp,0x10
</span></span><span style="display:flex;"><span> 8048ca6:	56                   	push   esi
</span></span><span style="display:flex;"><span> 8048ca7:	53                   	push   ebx
</span></span><span style="display:flex;"><span> ; ebx &lt;- A
</span></span><span style="display:flex;"><span> 8048ca8:	8b 5d 08             	mov    ebx,DWORD PTR [ebp+0x8]
</span></span><span style="display:flex;"><span> ; 如果 A 不大于 1 则跳转到 退出，这里应该是递归出口，返回值为 1
</span></span><span style="display:flex;"><span> 8048cab:	83 fb 01             	cmp    ebx,0x1
</span></span><span style="display:flex;"><span> 8048cae:	7e 20                	jle    8048cd0 &lt;func4+0x30&gt;
</span></span><span style="display:flex;"><span> 8048cb0:	83 c4 f4             	add    esp,0xfffffff4
</span></span><span style="display:flex;"><span> 8048cb3:	8d 43 ff             	lea    eax,[ebx-0x1]
</span></span><span style="display:flex;"><span> 8048cb6:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; func(A - 1)
</span></span><span style="display:flex;"><span> 8048cb7:	e8 e4 ff ff ff       	call   8048ca0 &lt;func4&gt;
</span></span><span style="display:flex;"><span> 8048cbc:	89 c6                	mov    esi,eax
</span></span><span style="display:flex;"><span> 8048cbe:	83 c4 f4             	add    esp,0xfffffff4
</span></span><span style="display:flex;"><span> 8048cc1:	8d 43 fe             	lea    eax,[ebx-0x2]
</span></span><span style="display:flex;"><span> 8048cc4:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; func(A - 2)
</span></span><span style="display:flex;"><span> ; 写到这里可以猜到这是斐波那契数列，
</span></span><span style="display:flex;"><span> ; 之前要求返回值是 55 ，所以输入应该是 9
</span></span><span style="display:flex;"><span> 8048cc5:	e8 d6 ff ff ff       	call   8048ca0 &lt;func4&gt;
</span></span><span style="display:flex;"><span> 8048cca:	01 f0                	add    eax,esi
</span></span><span style="display:flex;"><span> 8048ccc:	eb 07                	jmp    8048cd5 &lt;func4+0x35&gt;
</span></span><span style="display:flex;"><span> 8048cce:	89 f6                	mov    esi,esi
</span></span><span style="display:flex;"><span> 8048cd0:	b8 01 00 00 00       	mov    eax,0x1
</span></span><span style="display:flex;"><span> 8048cd5:	8d 65 e8             	lea    esp,[ebp-0x18]
</span></span><span style="display:flex;"><span> 8048cd8:	5b                   	pop    ebx
</span></span><span style="display:flex;"><span> 8048cd9:	5e                   	pop    esi
</span></span><span style="display:flex;"><span> 8048cda:	89 ec                	mov    esp,ebp
</span></span><span style="display:flex;"><span> 8048cdc:	5d                   	pop    ebp
</span></span><span style="display:flex;"><span> 8048cdd:	c3                   	ret    
</span></span><span style="display:flex;"><span> 8048cde:	89 f6                	mov    esi,esi
</span></span></code></pre></div><p>输入<code>9</code>成功通过了这一关。</p>
<h3 id="phase_5">phase_5<a hidden class="anchor" aria-hidden="true" href="#phase_5">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>; phase_5 的参数为字符串 input ，在 [ebp+0x8]
</span></span><span style="display:flex;"><span>08048d2c &lt;phase_5&gt;:
</span></span><span style="display:flex;"><span> 8048d2c:	55                   	push   ebp
</span></span><span style="display:flex;"><span> 8048d2d:	89 e5                	mov    ebp,esp
</span></span><span style="display:flex;"><span> 8048d2f:	83 ec 10             	sub    esp,0x10
</span></span><span style="display:flex;"><span> 8048d32:	56                   	push   esi
</span></span><span style="display:flex;"><span> 8048d33:	53                   	push   ebx
</span></span><span style="display:flex;"><span> ; input -&gt; ebx
</span></span><span style="display:flex;"><span> 8048d34:	8b 5d 08             	mov    ebx,DWORD PTR [ebp+0x8]
</span></span><span style="display:flex;"><span> 8048d37:	83 c4 f4             	add    esp,0xfffffff4
</span></span><span style="display:flex;"><span> 8048d3a:	53                   	push   ebx
</span></span><span style="display:flex;"><span> ; 计算 input 字符串长度，如果长度不为 6 则爆炸
</span></span><span style="display:flex;"><span> 8048d3b:	e8 d8 02 00 00       	call   8049018 &lt;string_length&gt;
</span></span><span style="display:flex;"><span> 8048d40:	83 c4 10             	add    esp,0x10
</span></span><span style="display:flex;"><span> 8048d43:	83 f8 06             	cmp    eax,0x6
</span></span><span style="display:flex;"><span> 8048d46:	74 05                	je     8048d4d &lt;phase_5+0x21&gt;
</span></span><span style="display:flex;"><span> 8048d48:	e8 af 07 00 00       	call   80494fc &lt;explode_bomb&gt;
</span></span><span style="display:flex;"><span> ; 小知识：由于两数相同，所以使用 xor 来清零快一些
</span></span><span style="display:flex;"><span> 8048d4d:	31 d2                	xor    edx,edx
</span></span><span style="display:flex;"><span> ; 不妨令这个变量为 str_a
</span></span><span style="display:flex;"><span> 8048d4f:	8d 4d f8             	lea    ecx,[ebp-0x8]
</span></span><span style="display:flex;"><span> ; 地址 0x804b220 &#34;isrveawhobpnutfg\260\001&#34;
</span></span><span style="display:flex;"><span> ; 怀疑是通过一些操作从上述字符串中取出字符重新拼接
</span></span><span style="display:flex;"><span> ; 不妨令这个字符串为 dict
</span></span><span style="display:flex;"><span> 8048d52:	be 20 b2 04 08       	mov    esi,0x804b220
</span></span><span style="display:flex;"><span> ; 从这里开始是循环六次，后面的字符串常量长度也刚好为 6
</span></span><span style="display:flex;"><span> ; al &lt;- input[edx]
</span></span><span style="display:flex;"><span> 8048d57:	8a 04 1a             	mov    al,BYTE PTR [edx+ebx*1]
</span></span><span style="display:flex;"><span> ; 取 al 低四位
</span></span><span style="display:flex;"><span> 8048d5a:	24 0f                	and    al,0xf
</span></span><span style="display:flex;"><span> ; 拓展长度到 32 位
</span></span><span style="display:flex;"><span> 8048d5c:	0f be c0             	movsx  eax,al
</span></span><span style="display:flex;"><span> ; al &lt;- dict[eax]
</span></span><span style="display:flex;"><span> 8048d5f:	8a 04 30             	mov    al,BYTE PTR [eax+esi*1]
</span></span><span style="display:flex;"><span> ; str_a[edx] &lt;- al
</span></span><span style="display:flex;"><span> 8048d62:	88 04 0a             	mov    BYTE PTR [edx+ecx*1],al
</span></span><span style="display:flex;"><span> 8048d65:	42                   	inc    edx
</span></span><span style="display:flex;"><span> 8048d66:	83 fa 05             	cmp    edx,0x5
</span></span><span style="display:flex;"><span> 8048d69:	7e ec                	jle    8048d57 &lt;phase_5+0x2b&gt;
</span></span><span style="display:flex;"><span> ; 循环结束
</span></span><span style="display:flex;"><span> ; 给字符串 str_a 结尾补上 &#39;\0&#39;
</span></span><span style="display:flex;"><span> 8048d6b:	c6 45 fe 00          	mov    BYTE PTR [ebp-0x2],0x0
</span></span><span style="display:flex;"><span> 8048d6f:	83 c4 f8             	add    esp,0xfffffff8
</span></span><span style="display:flex;"><span> ; 地址 0x804980b &#34;giants&#34;
</span></span><span style="display:flex;"><span> 8048d72:	68 0b 98 04 08       	push   0x804980b
</span></span><span style="display:flex;"><span> 8048d77:	8d 45 f8             	lea    eax,[ebp-0x8]
</span></span><span style="display:flex;"><span> 8048d7a:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; 比较 str_a 和 &#34;giants&#34;
</span></span><span style="display:flex;"><span> ; 所以输入字符串只看最低四位应该是 15 0 5 11 13 1 ，十六进制是 f 0 5 b d 1
</span></span><span style="display:flex;"><span> ; 查看 ASCII 表，找到方便输入的内容，a-z 及其附近的字符很符合要求
</span></span><span style="display:flex;"><span> ; 所以使用 o`ekma
</span></span><span style="display:flex;"><span> 8048d7b:	e8 b0 02 00 00       	call   8049030 &lt;strings_not_equal&gt;
</span></span><span style="display:flex;"><span> ......
</span></span></code></pre></div><p>输入<code>o`ekma</code>成功通过了这一关。</p>
<h3 id="phase_6">phase_6<a hidden class="anchor" aria-hidden="true" href="#phase_6">#</a></h3>
<p>这一关比较长，我将它分为几个部分。</p>
<p>一开始就能看到局部变量被赋值到一个神秘的地址，这应该解这题的关键。之后使用了<code>read_six_numbers</code>这个函数读入六个数字。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>; phase_6 的参数为字符串 input ，在 [ebp+0x8]
</span></span><span style="display:flex;"><span>08048d98 &lt;phase_6&gt;:
</span></span><span style="display:flex;"><span> ......
</span></span><span style="display:flex;"><span> ; input &lt;- edx
</span></span><span style="display:flex;"><span> 8048da1:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
</span></span><span style="display:flex;"><span> ; *(int *)0x804b26c 153
</span></span><span style="display:flex;"><span> ; 不妨令该局部变量为指针 C
</span></span><span style="display:flex;"><span> ; C &lt;- 0x804b26c
</span></span><span style="display:flex;"><span> ; 它直接指向了一个神秘的结构
</span></span><span style="display:flex;"><span> 8048da4:	c7 45 cc 6c b2 04 08 	mov    DWORD PTR [ebp-0x34],0x804b26c
</span></span><span style="display:flex;"><span> 8048dab:	83 c4 f8             	add    esp,0xfffffff8
</span></span><span style="display:flex;"><span> ; 不妨令该局部变量为数组 A
</span></span><span style="display:flex;"><span> 8048dae:	8d 45 e8             	lea    eax,[ebp-0x18]
</span></span><span style="display:flex;"><span> 8048db1:	50                   	push   eax
</span></span><span style="display:flex;"><span> 8048db2:	52                   	push   edx
</span></span><span style="display:flex;"><span> 8048db3:	e8 20 02 00 00       	call   8048fd8 &lt;read_six_numbers&gt;
</span></span></code></pre></div><p>碰到的第一个循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> ; for (int i = 0; i &lt;= 5; ++i) {
</span></span><span style="display:flex;"><span> ;     if (A[i] &gt; 6)
</span></span><span style="display:flex;"><span> ;         explode_bomb();
</span></span><span style="display:flex;"><span> ;     for (int j = i + 1; j &lt;= 5; ++j) {
</span></span><span style="display:flex;"><span> ;        if (A[i] == A[j])
</span></span><span style="display:flex;"><span> ;            explode_bomb();
</span></span><span style="display:flex;"><span> ;     }
</span></span><span style="display:flex;"><span> ; }
</span></span><span style="display:flex;"><span> ; edi &lt;- 0 不妨令其为 i
</span></span><span style="display:flex;"><span> 8048db8:	31 ff                	xor    edi,edi
</span></span><span style="display:flex;"><span> 8048dba:	83 c4 10             	add    esp,0x10
</span></span><span style="display:flex;"><span> 8048dbd:	8d 76 00             	lea    esi,[esi+0x0]
</span></span><span style="display:flex;"><span> ; eax &lt;- A
</span></span><span style="display:flex;"><span> ; 循环 6 次
</span></span><span style="display:flex;"><span> 8048dc0:	8d 45 e8             	lea    eax,[ebp-0x18]
</span></span><span style="display:flex;"><span> ; eax &lt;- A[i]
</span></span><span style="display:flex;"><span> 8048dc3:	8b 04 b8             	mov    eax,DWORD PTR [eax+edi*4]
</span></span><span style="display:flex;"><span> ; eax &lt;- A[i] - 1
</span></span><span style="display:flex;"><span> 8048dc6:	48                   	dec    eax
</span></span><span style="display:flex;"><span> ; 如果 eax 大于 5 就爆炸，不能大于 6
</span></span><span style="display:flex;"><span> 8048dc7:	83 f8 05             	cmp    eax,0x5
</span></span><span style="display:flex;"><span> 8048dca:	76 05                	jbe    8048dd1 &lt;phase_6+0x39&gt;
</span></span><span style="display:flex;"><span> 8048dcc:	e8 2b 07 00 00       	call   80494fc &lt;explode_bomb&gt;
</span></span><span style="display:flex;"><span> ; ebx &lt;- i + 1 不妨令其为 j
</span></span><span style="display:flex;"><span> 8048dd1:	8d 5f 01             	lea    ebx,[edi+0x1]
</span></span><span style="display:flex;"><span> ; if (j &lt;= 5)
</span></span><span style="display:flex;"><span> 8048dd4:	83 fb 05             	cmp    ebx,0x5
</span></span><span style="display:flex;"><span> 8048dd7:	7f 23                	jg     8048dfc &lt;phase_6+0x64&gt;
</span></span><span style="display:flex;"><span> ; eax &lt;- 4 * edi
</span></span><span style="display:flex;"><span> 8048dd9:	8d 04 bd 00 00 00 00 	lea    eax,[edi*4+0x0]
</span></span><span style="display:flex;"><span> ; 不妨令这个局部变量为 B
</span></span><span style="display:flex;"><span> ; B &lt;- 4 * edi
</span></span><span style="display:flex;"><span> 8048de0:	89 45 c8             	mov    DWORD PTR [ebp-0x38],eax
</span></span><span style="display:flex;"><span> ; esi &lt;- A
</span></span><span style="display:flex;"><span> 8048de3:	8d 75 e8             	lea    esi,[ebp-0x18]
</span></span><span style="display:flex;"><span> ; 内层循环
</span></span><span style="display:flex;"><span> 8048de6:	8b 55 c8             	mov    edx,DWORD PTR [ebp-0x38]
</span></span><span style="display:flex;"><span> ; eax &lt;- A[i]
</span></span><span style="display:flex;"><span> 8048de9:	8b 04 32             	mov    eax,DWORD PTR [edx+esi*1]
</span></span><span style="display:flex;"><span> ; 比较 A[i] 和 A[j]
</span></span><span style="display:flex;"><span> 8048dec:	3b 04 9e             	cmp    eax,DWORD PTR [esi+ebx*4]
</span></span><span style="display:flex;"><span> ; 如果相等则引爆炸弹
</span></span><span style="display:flex;"><span> 8048def:	75 05                	jne    8048df6 &lt;phase_6+0x5e&gt;
</span></span><span style="display:flex;"><span> 8048df1:	e8 06 07 00 00       	call   80494fc &lt;explode_bomb&gt;
</span></span><span style="display:flex;"><span> 8048df6:	43                   	inc    ebx
</span></span><span style="display:flex;"><span> 8048df7:	83 fb 05             	cmp    ebx,0x5
</span></span><span style="display:flex;"><span> 8048dfa:	7e ea                	jle    8048de6 &lt;phase_6+0x4e&gt;
</span></span><span style="display:flex;"><span> ; 结束内层循环
</span></span><span style="display:flex;"><span> 8048dfc:	47                   	inc    edi
</span></span><span style="display:flex;"><span> 8048dfd:	83 ff 05             	cmp    edi,0x5
</span></span><span style="display:flex;"><span> 8048e00:	7e be                	jle    8048dc0 &lt;phase_6+0x28&gt;
</span></span><span style="display:flex;"><span> ; 结束循环
</span></span></code></pre></div><p>至此可以得出初步结论，第一个数字一定不大于 6 ，而且任意两个数字不相等</p>
<p>碰到第二个循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> ; E = D;
</span></span><span style="display:flex;"><span> ; for (int i = 0, p = C; i &lt;= 5; ++i) {
</span></span><span style="display:flex;"><span> ;     j = 1;
</span></span><span style="display:flex;"><span> ;     while (j &lt; A[i]) {
</span></span><span style="display:flex;"><span> ;         p = p-&gt;next;
</span></span><span style="display:flex;"><span> ;         j++;
</span></span><span style="display:flex;"><span> ;     }
</span></span><span style="display:flex;"><span> ;     E[i] = p;
</span></span><span style="display:flex;"><span> ; }
</span></span><span style="display:flex;"><span> ; edi &lt;- 0 不妨令其为 i
</span></span><span style="display:flex;"><span> 8048e02:	31 ff                	xor    edi,edi
</span></span><span style="display:flex;"><span> ; ecx &lt;- A
</span></span><span style="display:flex;"><span> 8048e04:	8d 4d e8             	lea    ecx,[ebp-0x18]
</span></span><span style="display:flex;"><span> ; 不妨令该局部变量为数组 D
</span></span><span style="display:flex;"><span> 8048e07:	8d 45 d0             	lea    eax,[ebp-0x30]
</span></span><span style="display:flex;"><span> ; 不妨令该局部变量为指针 E
</span></span><span style="display:flex;"><span> ; E &lt;- D
</span></span><span style="display:flex;"><span> 8048e0a:	89 45 c4             	mov    DWORD PTR [ebp-0x3c],eax
</span></span><span style="display:flex;"><span> 8048e0d:	8d 76 00             	lea    esi,[esi+0x0]
</span></span><span style="display:flex;"><span> ; 循环 6 次
</span></span><span style="display:flex;"><span> ; esi &lt;- C 不妨令其为指针 p
</span></span><span style="display:flex;"><span> ; C 初值为 0x804b26c
</span></span><span style="display:flex;"><span> 8048e10:	8b 75 cc             	mov    esi,DWORD PTR [ebp-0x34]
</span></span><span style="display:flex;"><span> ; ebx &lt;- 1 不妨令其为 j
</span></span><span style="display:flex;"><span> 8048e13:	bb 01 00 00 00       	mov    ebx,0x1
</span></span><span style="display:flex;"><span> 8048e18:	8d 04 bd 00 00 00 00 	lea    eax,[edi*4+0x0]
</span></span><span style="display:flex;"><span> 8048e1f:	89 c2                	mov    edx,eax
</span></span><span style="display:flex;"><span> ; 将 j 与 A[i] 比较
</span></span><span style="display:flex;"><span> 8048e21:	3b 1c 08             	cmp    ebx,DWORD PTR [eax+ecx*1]
</span></span><span style="display:flex;"><span> 8048e24:	7d 12                	jge    8048e38 &lt;phase_6+0xa0&gt;
</span></span><span style="display:flex;"><span> ; 如果小于则执行下面这段
</span></span><span style="display:flex;"><span> ; eax &lt;- A[i]
</span></span><span style="display:flex;"><span> 8048e26:	8b 04 0a             	mov    eax,DWORD PTR [edx+ecx*1]
</span></span><span style="display:flex;"><span> 8048e29:	8d b4 26 00 00 00 00 	lea    esi,[esi+eiz*1+0x0]
</span></span><span style="display:flex;"><span> ; 内层循环
</span></span><span style="display:flex;"><span> ; 感觉是一个链表结构
</span></span><span style="display:flex;"><span> ; 猜测偏移为 0x8 的位置是 next 字段
</span></span><span style="display:flex;"><span> ; p &lt;- p-&gt;next
</span></span><span style="display:flex;"><span> 8048e30:	8b 76 08             	mov    esi,DWORD PTR [esi+0x8]
</span></span><span style="display:flex;"><span> ; j++
</span></span><span style="display:flex;"><span> 8048e33:	43                   	inc    ebx
</span></span><span style="display:flex;"><span> ; while (j &lt; A[i])
</span></span><span style="display:flex;"><span> 8048e34:	39 c3                	cmp    ebx,eax
</span></span><span style="display:flex;"><span> 8048e36:	7c f8                	jl     8048e30 &lt;phase_6+0x98&gt;
</span></span><span style="display:flex;"><span> ; 结束内层循环
</span></span><span style="display:flex;"><span> ; edx &lt;- E
</span></span><span style="display:flex;"><span> 8048e38:	8b 55 c4             	mov    edx,DWORD PTR [ebp-0x3c]
</span></span><span style="display:flex;"><span> ; E[i] &lt;- p
</span></span><span style="display:flex;"><span> 8048e3b:	89 34 ba             	mov    DWORD PTR [edx+edi*4],esi
</span></span><span style="display:flex;"><span> ; i++
</span></span><span style="display:flex;"><span> 8048e3e:	47                   	inc    edi
</span></span><span style="display:flex;"><span> ; while (i &lt;= 5)
</span></span><span style="display:flex;"><span> 8048e3f:	83 ff 05             	cmp    edi,0x5
</span></span><span style="display:flex;"><span> 8048e42:	7e cc                	jle    8048e10 &lt;phase_6+0x78&gt;
</span></span><span style="display:flex;"><span> ; 结束循环
</span></span></code></pre></div><p>使用 GDB 查看一下那个神秘地址果然有了收获：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>(gdb) x/3x 0x804b26c
</span></span><span style="display:flex;"><span>0x804b26c &lt;node1&gt;:	0x000000fd	0x00000001	0x0804b260
</span></span><span style="display:flex;"><span>(gdb) x/3x 0x804b260
</span></span><span style="display:flex;"><span>0x804b260 &lt;node2&gt;:	0x000002d5	0x00000002	0x0804b254
</span></span><span style="display:flex;"><span>(gdb) x/3x 0x804b254
</span></span><span style="display:flex;"><span>0x804b254 &lt;node3&gt;:	0x0000012d	0x00000003	0x0804b248
</span></span><span style="display:flex;"><span>(gdb) x/3x 0x804b248
</span></span><span style="display:flex;"><span>0x804b248 &lt;node4&gt;:	0x000003e5	0x00000004	0x0804b23c
</span></span><span style="display:flex;"><span>(gdb) x/3x 0x804b23c
</span></span><span style="display:flex;"><span>0x804b23c &lt;node5&gt;:	0x000000d4	0x00000005	0x0804b230
</span></span><span style="display:flex;"><span>(gdb) x/3x 0x804b230
</span></span><span style="display:flex;"><span>0x804b230 &lt;node6&gt;:	0x000001b0	0x00000006	0x00000000
</span></span><span style="display:flex;"><span>一共有六个节点
</span></span></code></pre></div><p>猜测三个字段分别为：<code>value</code>, <code>id</code>, <code>next</code></p>
<p>碰到第三个循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> ; p = D;
</span></span><span style="display:flex;"><span> ; C = D;
</span></span><span style="display:flex;"><span> ; for (int i = 1; i &lt;= 5; ++i) {
</span></span><span style="display:flex;"><span> ;     p-&gt;next = D[i];
</span></span><span style="display:flex;"><span> ;     p = p-&gt;next;
</span></span><span style="display:flex;"><span> ; }
</span></span><span style="display:flex;"><span> ; esi &lt;- D 不妨令其为指针 p
</span></span><span style="display:flex;"><span> 8048e44:	8b 75 d0             	mov    esi,DWORD PTR [ebp-0x30]
</span></span><span style="display:flex;"><span> ; C &lt;- D
</span></span><span style="display:flex;"><span> 8048e47:	89 75 cc             	mov    DWORD PTR [ebp-0x34],esi
</span></span><span style="display:flex;"><span> ; edi &lt;- 1 令其为 i
</span></span><span style="display:flex;"><span> 8048e4a:	bf 01 00 00 00       	mov    edi,0x1
</span></span><span style="display:flex;"><span> ; edx &lt;- D
</span></span><span style="display:flex;"><span> 8048e4f:	8d 55 d0             	lea    edx,[ebp-0x30]
</span></span><span style="display:flex;"><span> ; 循环 6 次
</span></span><span style="display:flex;"><span> ; eax &lt;- D[i]
</span></span><span style="display:flex;"><span> 8048e52:	8b 04 ba             	mov    eax,DWORD PTR [edx+edi*4]
</span></span><span style="display:flex;"><span> ; p-&gt;next &lt;- D[i]
</span></span><span style="display:flex;"><span> 8048e55:	89 46 08             	mov    DWORD PTR [esi+0x8],eax
</span></span><span style="display:flex;"><span> ; p &lt;- p-&gt;next
</span></span><span style="display:flex;"><span> 8048e58:	89 c6                	mov    esi,eax
</span></span><span style="display:flex;"><span> ; i++
</span></span><span style="display:flex;"><span> 8048e5a:	47                   	inc    edi
</span></span><span style="display:flex;"><span> ; while (i &lt;= 5)
</span></span><span style="display:flex;"><span> 8048e5b:	83 ff 05             	cmp    edi,0x5
</span></span><span style="display:flex;"><span> 8048e5e:	7e f2                	jle    8048e52 &lt;phase_6+0xba&gt;
</span></span><span style="display:flex;"><span> ; 结束循环
</span></span><span style="display:flex;"><span> ; p-&gt;next = NULL;
</span></span><span style="display:flex;"><span> 8048e60:	c7 46 08 00 00 00 00 	mov    DWORD PTR [esi+0x8],0x0
</span></span></code></pre></div><p>上面这部分代码相当于把数组<code>D</code>串起来变为一个链表。</p>
<p>碰到第四个循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> ; p = C;
</span></span><span style="display:flex;"><span> ; for (int i = 0; i &lt;= 4; ++i) {
</span></span><span style="display:flex;"><span> ;     if (p-&gt;value &lt; p-&gt;next-&gt;value) 
</span></span><span style="display:flex;"><span> ;         explode_bomb();
</span></span><span style="display:flex;"><span> ;     p = p-&gt;next;
</span></span><span style="display:flex;"><span> ;     i++;
</span></span><span style="display:flex;"><span> ; }
</span></span><span style="display:flex;"><span> ; 数组 D 组成的数列应该递减
</span></span><span style="display:flex;"><span> ; 所以我们可以将 6 个 node 排序
</span></span><span style="display:flex;"><span> ; 从大到小：node4 node2 node 6 node3 node1 node5
</span></span><span style="display:flex;"><span> 8048e67:	8b 75 cc             	mov    esi,DWORD PTR [ebp-0x34]
</span></span><span style="display:flex;"><span> 8048e6a:	31 ff                	xor    edi,edi
</span></span><span style="display:flex;"><span> 8048e6c:	8d 74 26 00          	lea    esi,[esi+eiz*1+0x0]
</span></span><span style="display:flex;"><span> ; 循环 5 次
</span></span><span style="display:flex;"><span> ; edx &lt;- p-&gt;next
</span></span><span style="display:flex;"><span> 8048e70:	8b 56 08             	mov    edx,DWORD PTR [esi+0x8]
</span></span><span style="display:flex;"><span> ; eax &lt;- p-&gt;value
</span></span><span style="display:flex;"><span> 8048e73:	8b 06                	mov    eax,DWORD PTR [esi]
</span></span><span style="display:flex;"><span> ; 将 p-&gt;value 和 p-&gt;next-&gt;value 比较
</span></span><span style="display:flex;"><span> ; 即如果小于，则爆炸
</span></span><span style="display:flex;"><span> 8048e75:	3b 02                	cmp    eax,DWORD PTR [edx]
</span></span><span style="display:flex;"><span> 8048e77:	7d 05                	jge    8048e7e &lt;phase_6+0xe6&gt;
</span></span><span style="display:flex;"><span> 8048e79:	e8 7e 06 00 00       	call   80494fc &lt;explode_bomb&gt;
</span></span><span style="display:flex;"><span> ; p &lt;- p-&gt;next 
</span></span><span style="display:flex;"><span> 8048e7e:	8b 76 08             	mov    esi,DWORD PTR [esi+0x8]
</span></span><span style="display:flex;"><span> ; i++
</span></span><span style="display:flex;"><span> 8048e81:	47                   	inc    edi
</span></span><span style="display:flex;"><span> ; while (i &lt;= 4)
</span></span><span style="display:flex;"><span> 8048e82:	83 ff 04             	cmp    edi,0x4
</span></span><span style="display:flex;"><span> 8048e85:	7e e9                	jle    8048e70 &lt;phase_6+0xd8&gt;
</span></span><span style="display:flex;"><span> ; 结束循环
</span></span></code></pre></div><p>由于从大到小是<code>node4</code>, <code>node2</code>, <code>node6</code>, <code>node3</code>, <code>node1</code>, <code>node5</code>。</p>
<p>输入字符串<code>4 2 6 3 1 5</code>便能通过这关。</p>
<h3 id="secret_phase">secret_phase<a hidden class="anchor" aria-hidden="true" href="#secret_phase">#</a></h3>
<p>其实在 6 关之后还有一个隐藏关卡，需要一定的条件触发。</p>
<p>可以直接在<code>bomb.disas</code>里面查找函数<code>secret_phase</code>，然后可以发现它在函数<code>phase_defused</code>中被调用。</p>
<p>首先在<code>phase_6</code>打上断点，发现在<code>phase_defused</code>中发现有怪异之处：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 8049543:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; 格式化字符串
</span></span><span style="display:flex;"><span> ; (gdb) x/s 0x8049d03
</span></span><span style="display:flex;"><span> ; 0x8049d03:	&#34;%d %s&#34;
</span></span><span style="display:flex;"><span> 8049544:	68 03 9d 04 08       	push   0x8049d03
</span></span><span style="display:flex;"><span> ; 没有解锁隐藏关卡时，输入字符串只有一个 9 ，这与两个占位符的不相符
</span></span><span style="display:flex;"><span> ; 所以我们应该在 9 后面补上一个字符串
</span></span><span style="display:flex;"><span> ; 在 phase_6 打上断点
</span></span><span style="display:flex;"><span> ; (gdb) break phase_6
</span></span><span style="display:flex;"><span> ; (gdb) run
</span></span><span style="display:flex;"><span> ; (gdb) x/s 0x804b770
</span></span><span style="display:flex;"><span> ; 0x804b770 &lt;input_strings+240&gt;:	&#34;9&#34;
</span></span><span style="display:flex;"><span> 8049549:	68 70 b7 04 08       	push   0x804b770
</span></span><span style="display:flex;"><span> 804954e:	e8 0d f3 ff ff       	call   8048860 &lt;sscanf@plt&gt;
</span></span><span style="display:flex;"><span> 8049553:	83 c4 10             	add    esp,0x10
</span></span></code></pre></div><p>发现这里有个用于调试的标签<code>input_strings</code>，我们可以看看<code>input_strings</code> +0 +80 +160 都是什么：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>(gdb) x/s 0x804b770-240
</span></span><span style="display:flex;"><span>0x804b680 &lt;input_strings&gt;:	&#34;Public speaking is very easy.&#34;
</span></span><span style="display:flex;"><span>(gdb) x/s 0x804b770-240+80
</span></span><span style="display:flex;"><span>0x804b6d0 &lt;input_strings+80&gt;:	&#34;1 2 6 24 120 720&#34;
</span></span><span style="display:flex;"><span>(gdb) x/s 0x804b770-240+160
</span></span><span style="display:flex;"><span>0x804b720 &lt;input_strings+160&gt;:	&#34;0 q 777&#34;
</span></span></code></pre></div><p>发现是前三关输入的字符，所以&quot;9&quot;对应的是我们第四关的输入</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> ; 如果成功给两个参数赋值
</span></span><span style="display:flex;"><span> 8049556:	83 f8 02             	cmp    eax,0x2
</span></span><span style="display:flex;"><span> 8049559:	75 37                	jne    8049592 &lt;phase_defused+0x66&gt;
</span></span><span style="display:flex;"><span> 804955b:	83 c4 f8             	add    esp,0xfffffff8
</span></span><span style="display:flex;"><span> ; 字符串比对
</span></span><span style="display:flex;"><span> ; (gdb) x/s 0x8049d09
</span></span><span style="display:flex;"><span> ; 0x8049d09:	&#34;austinpowers&#34;
</span></span><span style="display:flex;"><span> ; 可以得知第四关时后面应该添加一个&#34;austinpowers&#34;
</span></span><span style="display:flex;"><span> ; 由此可以进入隐藏关卡
</span></span><span style="display:flex;"><span> ......
</span></span><span style="display:flex;"><span> 804958d:	e8 56 f9 ff ff       	call   8048ee8 &lt;secret_phase&gt;
</span></span></code></pre></div><p>现在我们开始看函数<code>secret_phase</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>08048ee8 &lt;secret_phase&gt;:
</span></span><span style="display:flex;"><span> 8048ee8:	55                   	push   ebp
</span></span><span style="display:flex;"><span> 8048ee9:	89 e5                	mov    ebp,esp
</span></span><span style="display:flex;"><span> 8048eeb:	83 ec 14             	sub    esp,0x14
</span></span><span style="display:flex;"><span> 8048eee:	53                   	push   ebx
</span></span><span style="display:flex;"><span> ; 将输入的字符串转换为数字
</span></span><span style="display:flex;"><span> ; 返回值在 eax
</span></span><span style="display:flex;"><span> 8048eef:	e8 08 03 00 00       	call   80491fc &lt;read_line&gt;
</span></span><span style="display:flex;"><span> 8048ef4:	6a 00                	push   0x0
</span></span><span style="display:flex;"><span> 8048ef6:	6a 0a                	push   0xa
</span></span><span style="display:flex;"><span> 8048ef8:	6a 00                	push   0x0
</span></span><span style="display:flex;"><span> 8048efa:	50                   	push   eax
</span></span><span style="display:flex;"><span> 8048efb:	e8 f0 f8 ff ff       	call   80487f0 &lt;__strtol_internal@plt&gt;
</span></span><span style="display:flex;"><span> 8048f00:	83 c4 10             	add    esp,0x10
</span></span><span style="display:flex;"><span> 8048f03:	89 c3                	mov    ebx,eax
</span></span><span style="display:flex;"><span> 8048f05:	8d 43 ff             	lea    eax,[ebx-0x1]
</span></span><span style="display:flex;"><span> ; 如果 input-1 大于 0x3e8 则爆炸
</span></span><span style="display:flex;"><span> 8048f08:	3d e8 03 00 00       	cmp    eax,0x3e8
</span></span><span style="display:flex;"><span> 8048f0d:	76 05                	jbe    8048f14 &lt;secret_phase+0x2c&gt;
</span></span><span style="display:flex;"><span> 8048f0f:	e8 e8 05 00 00       	call   80494fc &lt;explode_bomb&gt;
</span></span><span style="display:flex;"><span> 8048f14:	83 c4 f8             	add    esp,0xfffffff8
</span></span><span style="display:flex;"><span> 8048f17:	53                   	push   ebx
</span></span><span style="display:flex;"><span> ; 该地址可能指向一个数组或者结构
</span></span><span style="display:flex;"><span> 8048f18:	68 20 b3 04 08       	push   0x804b320
</span></span><span style="display:flex;"><span> 8048f1d:	e8 72 ff ff ff       	call   8048e94 &lt;fun7&gt;
</span></span><span style="display:flex;"><span> 8048f22:	83 c4 10             	add    esp,0x10
</span></span><span style="display:flex;"><span> ; 如果返回值为 7 则成功
</span></span><span style="display:flex;"><span> 8048f25:	83 f8 07             	cmp    eax,0x7
</span></span><span style="display:flex;"><span> 8048f28:	74 05                	je     8048f2f &lt;secret_phase+0x47&gt;
</span></span><span style="display:flex;"><span> ......
</span></span></code></pre></div><p>由于调用了函数<code>fun7</code>，我们直接来看它。<code>func7</code>是一个比较简单的递归函数，主要是结构体较为复杂：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>08048e94 &lt;fun7&gt;:
</span></span><span style="display:flex;"><span> 8048e94:	55                   	push   ebp
</span></span><span style="display:flex;"><span> 8048e95:	89 e5                	mov    ebp,esp
</span></span><span style="display:flex;"><span> 8048e97:	83 ec 08             	sub    esp,0x8
</span></span><span style="display:flex;"><span> 8048e9a:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
</span></span><span style="display:flex;"><span> 8048e9d:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
</span></span><span style="display:flex;"><span> 8048ea0:	85 d2                	test   edx,edx
</span></span><span style="display:flex;"><span> 8048ea2:	75 0c                	jne    8048eb0 &lt;fun7+0x1c&gt;
</span></span><span style="display:flex;"><span> 8048ea4:	b8 ff ff ff ff       	mov    eax,0xffffffff
</span></span><span style="display:flex;"><span> 8048ea9:	eb 37                	jmp    8048ee2 &lt;fun7+0x4e&gt;
</span></span><span style="display:flex;"><span> 8048eab:	90                   	nop
</span></span><span style="display:flex;"><span> 8048eac:	8d 74 26 00          	lea    esi,[esi+eiz*1+0x0]
</span></span><span style="display:flex;"><span> 8048eb0:	3b 02                	cmp    eax,DWORD PTR [edx]
</span></span><span style="display:flex;"><span> 8048eb2:	7d 11                	jge    8048ec5 &lt;fun7+0x31&gt;
</span></span><span style="display:flex;"><span> 8048eb4:	83 c4 f8             	add    esp,0xfffffff8
</span></span><span style="display:flex;"><span> 8048eb7:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; 类似链表的结构
</span></span><span style="display:flex;"><span> 8048eb8:	8b 42 04             	mov    eax,DWORD PTR [edx+0x4]
</span></span><span style="display:flex;"><span> 8048ebb:	50                   	push   eax
</span></span><span style="display:flex;"><span> 8048ebc:	e8 d3 ff ff ff       	call   8048e94 &lt;fun7&gt;
</span></span><span style="display:flex;"><span> 8048ec1:	01 c0                	add    eax,eax
</span></span><span style="display:flex;"><span> 8048ec3:	eb 1d                	jmp    8048ee2 &lt;fun7+0x4e&gt;
</span></span><span style="display:flex;"><span> 8048ec5:	3b 02                	cmp    eax,DWORD PTR [edx]
</span></span><span style="display:flex;"><span> 8048ec7:	74 17                	je     8048ee0 &lt;fun7+0x4c&gt;
</span></span><span style="display:flex;"><span> 8048ec9:	83 c4 f8             	add    esp,0xfffffff8
</span></span><span style="display:flex;"><span> 8048ecc:	50                   	push   eax
</span></span><span style="display:flex;"><span> ; 类似链表的结构
</span></span><span style="display:flex;"><span> 8048ecd:	8b 42 08             	mov    eax,DWORD PTR [edx+0x8]
</span></span><span style="display:flex;"><span> 8048ed0:	50                   	push   eax
</span></span><span style="display:flex;"><span> 8048ed1:	e8 be ff ff ff       	call   8048e94 &lt;fun7&gt;
</span></span><span style="display:flex;"><span> 8048ed6:	01 c0                	add    eax,eax
</span></span><span style="display:flex;"><span> 8048ed8:	40                   	inc    eax
</span></span><span style="display:flex;"><span> 8048ed9:	eb 07                	jmp    8048ee2 &lt;fun7+0x4e&gt;
</span></span><span style="display:flex;"><span> 8048edb:	90                   	nop
</span></span><span style="display:flex;"><span> 8048edc:	8d 74 26 00          	lea    esi,[esi+eiz*1+0x0]
</span></span><span style="display:flex;"><span> 8048ee0:	31 c0                	xor    eax,eax
</span></span><span style="display:flex;"><span> 8048ee2:	89 ec                	mov    esp,ebp
</span></span><span style="display:flex;"><span> 8048ee4:	5d                   	pop    ebp
</span></span><span style="display:flex;"><span> 8048ee5:	c3                   	ret    
</span></span><span style="display:flex;"><span> 8048ee6:	89 f6                	mov    esi,esi
</span></span></code></pre></div><p>可以看到有类似链表的结构，但是它拥有两个指针域，我们可以把它想象为一棵树：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#007f7f">// fun7 输入参数：指针 p 和 整型 n
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// p 可以理解为二叉树的节点
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> TreeNode {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> value;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">struct</span> TreeNode *left;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">struct</span> TreeNode *right;
</span></span><span style="display:flex;"><span>} TreeNode;
</span></span></code></pre></div><p>这样一来<code>fun7</code>马上可以写成 C 语言：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> fun7(TreeNode *p, <span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (p == <span style="color:#ff0;font-weight:bold">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> -<span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (n-&gt;value &lt; p[<span style="color:#ff0;font-weight:bold">0</span>]) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">2</span> * fun7(p-&gt;left, n);
</span></span><span style="display:flex;"><span>        } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (n == p[<span style="color:#ff0;font-weight:bold">0</span>]) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">2</span> * fun7(p-&gt;right, n) + <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>由于需要递归函数返回 7 (参数<code>(p, n)</code>)，所以内一层只能返回 3 (参数<code>(p-&gt;right, n)</code>)， 再内一层只能返回 1 <code>(p-&gt;right-&gt;right, n)</code>，最里面一层返回 0 <code>(p-&gt;right-&gt;right-&gt;right, n)</code>。 所以第一次调用时<code>p-&gt;righ-&gt;right-&gt;right-&gt;value</code>应该与<code>n</code>相等</p>
<p>可以通过 GDB 很快找到：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>#                   value         left          right
</span></span><span style="display:flex;"><span>(gdb) x/3x 0x804b320
</span></span><span style="display:flex;"><span>0x804b320 &lt;n1&gt;:     0x00000024    0x0804b314    0x0804b308
</span></span><span style="display:flex;"><span>(gdb) x/3x 0x0804b308
</span></span><span style="display:flex;"><span>0x804b308 &lt;n22&gt;:    0x00000032    0x0804b2f0    0x0804b2d8
</span></span><span style="display:flex;"><span>(gdb) x/3x 0x0804b2d8
</span></span><span style="display:flex;"><span>0x804b2d8 &lt;n34&gt;:    0x0000006b    0x0804b2b4    0x0804b278
</span></span><span style="display:flex;"><span>(gdb) x/3x 0x0804b278
</span></span><span style="display:flex;"><span>0x804b278 &lt;n48&gt;:    0x000003e9    0x00000000    0x00000000
</span></span></code></pre></div><p>所以应该输入<code>3e9</code>也就是十进制<code>1001</code>。</p>
<h3 id="输入文件">输入文件<a hidden class="anchor" aria-hidden="true" href="#输入文件">#</a></h3>
<p>如下是最后通过测试的输入文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>$ cat input
</span></span><span style="display:flex;"><span>Public speaking is very easy.
</span></span><span style="display:flex;"><span>1 2 6 24 120 720
</span></span><span style="display:flex;"><span>0 q 777
</span></span><span style="display:flex;"><span>9 austinpowers
</span></span><span style="display:flex;"><span>o`ekma
</span></span><span style="display:flex;"><span>4 2 6 3 1 5
</span></span><span style="display:flex;"><span>1001
</span></span></code></pre></div><h2 id="实验感受">实验感受<a hidden class="anchor" aria-hidden="true" href="#实验感受">#</a></h2>
<p>这六关分别涉及了字符串常量、循环、switch-case（跳转表）、递归、数组、链表等知识，难度没有想象中那么大，耐心看汇编代码其实是很容易看懂的。而隐藏关卡需要细心或者运气发现，但是解决它并不是问题。</p>
<p>做 Lab 时没有动态调试这个程序，感觉也没有动态调试的必要，只要看到了“魔法”地址就可以直接 GDB 查看它。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://vaaandark.top/tags/csapp/">CSAPP</a></li>
      <li><a href="https://vaaandark.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a></li>
      <li><a href="https://vaaandark.top/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/">反汇编</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://vaaandark.top/posts/2022.11.6-man-utd-vs-aston-villa/">
    <span class="title">« 上一页</span>
    <br>
    <span>2022.11.6 维拉 3 : 1 曼联</span>
  </a>
  <a class="next" href="https://vaaandark.top/posts/dive-in-vla/">
    <span class="title">下一页 »</span>
    <br>
    <span>稍微深入VLA</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CSAPP Bomb Lab on x"
            href="https://x.com/intent/tweet/?text=CSAPP%20Bomb%20Lab&amp;url=https%3a%2f%2fvaaandark.top%2fposts%2fcsapp-bomb-lab%2f&amp;hashtags=CSAPP%2c%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%2c%e5%8f%8d%e6%b1%87%e7%bc%96">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CSAPP Bomb Lab on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvaaandark.top%2fposts%2fcsapp-bomb-lab%2f&amp;title=CSAPP%20Bomb%20Lab&amp;summary=CSAPP%20Bomb%20Lab&amp;source=https%3a%2f%2fvaaandark.top%2fposts%2fcsapp-bomb-lab%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CSAPP Bomb Lab on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fvaaandark.top%2fposts%2fcsapp-bomb-lab%2f&title=CSAPP%20Bomb%20Lab">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CSAPP Bomb Lab on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvaaandark.top%2fposts%2fcsapp-bomb-lab%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CSAPP Bomb Lab on whatsapp"
            href="https://api.whatsapp.com/send?text=CSAPP%20Bomb%20Lab%20-%20https%3a%2f%2fvaaandark.top%2fposts%2fcsapp-bomb-lab%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CSAPP Bomb Lab on telegram"
            href="https://telegram.me/share/url?text=CSAPP%20Bomb%20Lab&amp;url=https%3a%2f%2fvaaandark.top%2fposts%2fcsapp-bomb-lab%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CSAPP Bomb Lab on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=CSAPP%20Bomb%20Lab&u=https%3a%2f%2fvaaandark.top%2fposts%2fcsapp-bomb-lab%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer><script src="https://giscus.app/client.js"
        data-repo="vaaandark/vaaandark.github.io"
        data-repo-id="R_kgDOGsxTxw"
        data-category="Announcements"
        data-category-id="DIC_kwDOGsxTx84CmAQ1"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://vaaandark.top/">vaaandark&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
