<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>数据结构与算法 on vaaandark&#39;s blog</title>
    <link>https://vaaandark.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 数据结构与算法 on vaaandark&#39;s blog</description>
    <generator>Hugo -- 0.140.2</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 27 Mar 2024 20:02:33 +0800</lastBuildDate>
    <atom:link href="https://vaaandark.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>求 n 个数中前 k 小的数</title>
      <link>https://vaaandark.top/posts/the-smallest-k-numbers/</link>
      <pubDate>Wed, 27 Mar 2024 20:02:33 +0800</pubDate>
      <guid>https://vaaandark.top/posts/the-smallest-k-numbers/</guid>
      <description>&lt;p&gt;面试时遇到的一道题：给出给出 n 个数，求出前 k 小的数字。&lt;/p&gt;
&lt;p&gt;输入是 n + 1 行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一行是 n 和 k&lt;/li&gt;
&lt;li&gt;之后 n 行是这个数列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出是 k 个数。&lt;/p&gt;
&lt;p&gt;当时没想出来怎么做，直接嗯排序，然后输出，OJ 的时限比较宽容，竟然过了😄。&lt;/p&gt;</description>
    </item>
    <item>
      <title>说说链表</title>
      <link>https://vaaandark.top/posts/facts-about-linklist/</link>
      <pubDate>Sun, 14 Aug 2022 16:01:24 +0000</pubDate>
      <guid>https://vaaandark.top/posts/facts-about-linklist/</guid>
      <description>&lt;p&gt;最近看到了一些关于侵入式和非侵入式链表的讨论，决定研究一下它们两个。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;侵入式和非侵入式链表的区别&#34;&gt;侵入式和非侵入式链表的区别&lt;/h2&gt;
&lt;p&gt;这里的侵入是相对于链表的指针域来说，所以最主要的区别就是非侵入式的链表容器中保存了一份用户传入的值。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lua Table</title>
      <link>https://vaaandark.top/posts/lua-table/</link>
      <pubDate>Wed, 11 May 2022 23:49:28 +0000</pubDate>
      <guid>https://vaaandark.top/posts/lua-table/</guid>
      <description>&lt;p&gt;之前学习 Lua 的时候就对它的 Table 很感兴趣，最近在看 Lua 解释器的源码，因此就想研究一下具体是怎么实现这个 Lua 之中最为重要的数据结构的。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;lua-table-简介&#34;&gt;Lua Table 简介&lt;/h2&gt;
&lt;p&gt;在 Lua 语言之中，数组是 table ，字典是 table ，就连对象、模块、包也是通过 table 实现的：&lt;/p&gt;</description>
    </item>
    <item>
      <title>斐波那契堆</title>
      <link>https://vaaandark.top/posts/fibonacci-heap/</link>
      <pubDate>Mon, 31 Jan 2022 12:51:49 +0000</pubDate>
      <guid>https://vaaandark.top/posts/fibonacci-heap/</guid>
      <description>&lt;p&gt;联创 Lab 组新人任务第一弹。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;关于斐波那契堆&#34;&gt;关于斐波那契堆&lt;/h2&gt;
&lt;h3 id=&#34;结构与特点&#34;&gt;结构与特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。&lt;/li&gt;
&lt;li&gt;斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。&lt;/li&gt;
&lt;li&gt;斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。&lt;/li&gt;
&lt;li&gt;使用一个指针指向斐波那契堆中最小元素。
斐波那契堆将操作尽可能地延后，它的插入是懒惰的，只有在不得不进行合并操作时才进行合并。在极端情况下，它甚至是一个长度很大的链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插入操作&#34;&gt;插入操作&lt;/h3&gt;
&lt;p&gt;将一个节点直接插入到根链表中，并比较键值的大小，如果新节点的键值小于原有节点的键值，就将斐波那契堆的指向最小节点的指针指向它。&lt;/p&gt;</description>
    </item>
    <item>
      <title>左偏红黑树</title>
      <link>https://vaaandark.top/posts/llrb/</link>
      <pubDate>Mon, 31 Jan 2022 12:51:39 +0000</pubDate>
      <guid>https://vaaandark.top/posts/llrb/</guid>
      <description>&lt;p&gt;联创 Lab 组新人任务第一弹。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;关于llrb&#34;&gt;关于LLRB&lt;/h2&gt;
&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;根节点是黑色的。&lt;/li&gt;
&lt;li&gt;红色节点的儿子一定是黑色的。&lt;/li&gt;
&lt;li&gt;任意节点到任意叶子的最短路径上都有相同数量的黑色节点。&lt;/li&gt;
&lt;li&gt;黑色节点的儿子要么全是黑色，要么只有左儿子是黑色。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;前三点与红黑树的性质相同，第四点为左偏红黑树的特殊性质，这导致了它的操作相对红黑树更加简单。&lt;/li&gt;
&lt;li&gt;左偏红黑树也可以认为其相邻节点的边是有颜色的。&lt;/li&gt;
&lt;li&gt;空节点的颜色认为是黑色。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插入操作&#34;&gt;插入操作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;可以先就像向二叉查找树中插入节点一样操作，插入时将其颜色赋为红色。如果插入时是黑色，这会导致破坏了LLRB的平衡性质。&lt;/li&gt;
&lt;li&gt;保持住了黑色平衡性质之后再来调整其他结构性质，要对连续两个红色节点、只有右儿子是红色节点进行旋转，对左右儿子都是红色的节点进行颜色翻转（拆分2-3-4树中的4-node）。&lt;/li&gt;
&lt;li&gt;其操作可以是递归的，编写代码也将更加容易实现。
优先保持平衡性质的原因有：在一开始插入时保持平衡性质最容易实现（只需要给新节点赋红色），此时若优先考虑其他性质，会导致需要考虑的情况过多，而且在后续进行修补（旋转、颜色翻转）的时候不会破坏其平衡性质。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;删除操作&#34;&gt;删除操作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;依然优先考虑其平衡性质，删除的节点需要是红色的，因此思路就是先将需要删除的节点变成红色的。&lt;/li&gt;
&lt;li&gt;此时需要考虑的是，如何将红色节点向下移动（向左下或右下）。当左右儿子都不是红色时也不用担心，可以通过颜色翻转实现，翻转后需要考虑移动的另一个方向是否会出现不满足左倾红黑树的情况，并对其进行修补。&lt;/li&gt;
&lt;li&gt;由于LLRB的左偏特性，因此会出现想要向右下移动时，左儿子是红色而右儿子是黑色，因此需要对该节点进行右旋，让向右下的路径上出现红色。&lt;/li&gt;
&lt;li&gt;当找到删除的目标节点后，如果是一个叶子节点，直接删去，如果是一个内部节点，便从它的右儿子的分支中找到最小节点与之替换，再删掉。&lt;/li&gt;
&lt;li&gt;在向上返回的途中修补节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt; 中判断是否为叶子节点不应该用它是否有左儿子来判断，而是用它是否有右儿子来判断，因为在前一步中有右旋操作。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
