[{"content":"2024 年过得真快，我的本科也过得飞快，已经是十二月末了，再有五六个月我就毕业了，而且我已经打了半年多的工了。相比心态上的转变，生活工作方式和节奏的变化则是真真切切而且无法回避的。\n今年有太多的第一次尝试：第一次在另一座城市生活，第一次实习，第一次转正答辩，第一次获得国家级竞赛一等奖，第一次听音乐会……也做出了太多选择：选择实习去向，选择放弃保研……\n今年去过六个城市，按照时间先后是武汉、上海、宜昌、深圳、香港和成都，在武汉生活和读书，在上海参加了一场超算比赛，在深圳实习，去了香港和重庆旅游。\n在上海的 ASC 超算比赛是轻松加愉快的，我作为编外运维打了酱油，被学长学姐请吃饭，还和高中同学连玩两天，甚至在上海收获了我的实习 offer。等到国际劳动节前夕，我又和室友错峰游了宜昌，在清江峡谷收获了我的微信头像，还见识了三峡大坝的人造伟力。之后我便马不停蹄飞往深圳实习。\n我对实习秋招其实是缺乏准备的，八股也没好好背，题目也没好好刷，所以面试中自己的长板和短板都展现得淋漓尽致。比如我可以跟面试官畅谈操作系统和协程涉及，但遇到数据库直接说我不会。非常感谢腾讯☁️的面试官，可以说是不拘一格降人才了，也可能是非常对胃口（根据之后他做我导师的情况来看）。在经过了一次技术面，一次总监面，一次 hr 面后我进入了腾讯云实习，在云原生的容器团队做分布式相关的工作。\n在这之前我从未在家乡之外的城市生活，生活状态的转换其实没有那么困难。和从初中开始同学的朋友一起来到深圳实习，合租一间两居室，一起交给中介半个月的房租。从一开始一起上班下班，到后来我下班晚早上起不来，我们分别上下班。我周末到处闲逛，探索深圳；他中途暑研，平时复习考试并准备英语。我准备转正和直接工作；他充实简历并准备出国：我们都做着各自认为正确的事情。直到我开始准备转正答辩，他发现了更适合他的实习岗位。最后我们都离开那间两居室，他去向上海，我去向隔壁的一居室……\n工作和转正都比我想象中顺利很多，组内氛围很好，同事和老板都很好。尤其是导师帮助了我很多，在我入职前一天就做好了我的培养计划发给了我，密密麻麻的好几页。我不知道我在别的地方是否会收到这样的重视和培养——我觉得不会，所以我直接准备了实习转正，没有考虑实习。我也喜欢这个工作，我并没有接触过后端业务，也并不喜欢 curd，我更喜欢 infra 和解决 Linux 的疑难杂症。\n暑假和我妈去了香港转了一下，在之后和朋友去重庆穷游。顺带一提，重庆和香港真像，路上都是黄色的出租车，路上都没有电动车。我好像除了初中毕业和高中毕业时，感觉从来没有这么自由过。\n实习答辩后我回到了武汉上学（其实是翘课在武汉的 base 上班），在上车前接到老板的电话告诉我可以留用，在欣喜过后的恍惚间我才发现我其实可以不用准备秋招了。\n我好像没有做什么选择，被机缘推着前行，但又在每个命运的十字路口做出了坚定的选择。在八月份我被带着打了操作系统赛获得了一等奖，我又突然意识，我可能有保研的机会。结果九月份时我发现我上个学期的体育课成绩因为提前考试并跑路去实习而没有作数，我必须快速做出选择，是全力争取体育成绩生效争取保研，还是尽力争取就行，本科毕业直接工作。\n熟悉我的朋友都知道后来发生的故事了，我放弃了保研，我在国庆长假后回到了深圳继续实习。只不过那个时候暑期已过，深圳再没有同级的同学一起实习，我原以为后续实习的基调是孤独而无聊的，但我发现我已经融入了团队：我先是被同事邀请去他乔迁之喜，时隔多年再次打了三国杀，这是在大学这个充满年轻人的地方都不曾有过的体验；又去了惠州团建，人生第一次看到如此清晰的星空。我也发现了其他有趣的活动，我在十一月左右开始每周末独自爬两座山，这是生在江汉平原的我从未有过的体验：中午起床，骑行前往山脚下，傍晚前登顶欣赏日落，走夜路下山，再骑行回家。乘兴而来，兴尽而归。\n到前几天，也就是圣诞前夕，我又和朋友去香港听了弥撒亚音乐会，又是新奇的人生体验。在哈利路亚的大合唱中，我看到所有信徒起立，向受难羔羊致敬；在维港海边的轻风和音乐中，我又感到文艺电影重庆森林般的氛围。\n我在香港的书店又看到了我想看而一直没时间看的卡夫卡的《城堡》，我却联想到中间件消息队列工具 kafka，也许我可以把我下一个写的云原生组件命名为卡尔维诺（按照☁️上工具的命名习惯把c改成k），这也是我最喜欢的作家。或者可以叫柯西莫，让🌳上的男爵变成☁️上的男爵。\n再见我的 2024，我已上☁️，状态良好。希望生活在☁️上不是生活在🌳上，不是离群索居，而是命运与共……\n","permalink":"https://vaaandark.top/posts/2024-look-back/","summary":"\u003cp\u003e2024 年过得真快，我的本科也过得飞快，已经是十二月末了，再有五六个月我就毕业了，而且我已经打了半年多的工了。相比心态上的转变，生活工作方式和节奏的变化则是真真切切而且无法回避的。\u003c/p\u003e","title":"双城记——2024 回顾"},{"content":"面试时遇到的一道题：给出给出 n 个数，求出前 k 小的数字。\n输入是 n + 1 行：\n第一行是 n 和 k 之后 n 行是这个数列 输出是 k 个数。\n当时没想出来怎么做，直接嗯排序，然后输出，OJ 的时限比较宽容，竟然过了😄。\n不过在面试官那里肯定是没过的。\n直接排序的时间复杂度是 $O(nlg{n})$ ，如果维护一个大小为 k 的堆则是能够优化成 $O(nlg{k})$ ，肯定有更好的方法。\n后来想到了类似快排的划分的思想，代码和思路如下：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 打印范围在 [begin, end) 的数组切片 void print_slice(vector\u0026lt;int\u0026gt; \u0026amp;a, int begin, int end) { // cout \u0026lt;\u0026lt; \u0026#34;-------\u0026#34; \u0026lt;\u0026lt; endl; for (int i = begin; i \u0026lt; end; ++i) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // cout \u0026lt;\u0026lt; endl; // cout \u0026lt;\u0026lt; \u0026#34;-------\u0026#34; \u0026lt;\u0026lt; endl; } // 类似二分的思想，对于范围在 [begin, end) 的数组切片进行划分 void sol(vector\u0026lt;int\u0026gt; \u0026amp;a, int begin, int end, int k) { if (begin \u0026gt;= end || k \u0026lt;= 0) { return; } int lower = begin; int upper = end - 1; // 以最左边的为轴 // 小于它的放左边，大于它的放右边 int pivot = a[lower]; while (lower \u0026lt; upper) { while (lower \u0026lt; upper \u0026amp;\u0026amp; a[upper] \u0026gt; pivot) { upper -= 1; } if (lower \u0026lt; upper) { a[lower] = a[upper]; lower += 1; } while (lower \u0026lt; upper \u0026amp;\u0026amp; a[lower] \u0026lt; pivot) { lower += 1; } if (lower \u0026lt; upper) { a[upper] = a[lower]; upper -= 1; } } a[lower] = pivot; int left_count = lower - begin; // 左边的数就是前 left_count 小的数 // 如果轴左边数的数量刚好为 k - 1 ，则说明已经找到了前 k 小的数 // 如果小于 k - 1 ，则说明还需要在右边找前 k - 1 - left_count 小的数 // 如果大于 k - 1 ，则说明需要在左边找前 k 小的数 if (left_count \u0026lt;= k - 1) { print_slice(a, begin, lower + 1); sol(a, lower + 1, end, k - left_count - 1); } else { sol(a, begin, lower, k); } } int main() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; a(n); for (int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; a[i]; } sol(a, 0, n, k); cout \u0026lt;\u0026lt; endl; return 0; } 这道题在 力扣 上也有，看了题解之后发现这是算法导论上讲过的，感觉自己不仅算法水平低下，而且还读书不认真😭。\n","permalink":"https://vaaandark.top/posts/the-smallest-k-numbers/","summary":"\u003cp\u003e面试时遇到的一道题：给出给出 n 个数，求出前 k 小的数字。\u003c/p\u003e\n\u003cp\u003e输入是 n + 1 行：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第一行是 n 和 k\u003c/li\u003e\n\u003cli\u003e之后 n 行是这个数列\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e输出是 k 个数。\u003c/p\u003e\n\u003cp\u003e当时没想出来怎么做，直接嗯排序，然后输出，OJ 的时限比较宽容，竟然过了😄。\u003c/p\u003e","title":"求 n 个数中前 k 小的数"},{"content":" 首发于知乎\n我从未对很少阅读近三十年的文学作品感到遗憾，因为我并没有从那些已经加入作协的“主流”作家那里汲取过营养，我觉得作家不靠稿费而是靠体制的工资生活是一件奇怪而又羞耻的事情。\n不过我的确也曾读过他们作品的片段，那是在初中和高中的阅读之中，但这使我常常感到厌烦。倒不是因为对应试的反感，可能就是性格让我读不进去这些文章。我会反感余秋雨的“文化大散文”，也会觉得韩少功的作品充满了小农思想，还会觉得《南渡北归》对民国和民国知识精英过度美化……无一例外，这都是老师们推荐的作家，不过我隐隐约约感觉我就是对这样的文学难以接受。\n我前天看到了一些视频，讲的是矿工诗人陈年喜的故事。矿工，大家都知道这是一种高危职业，但很少有人能够理解他们的日常工作到底有多么危险。他们既是远离乡土的农民，也是深山深井中的工人，他们注定了不会获得社会的过多关注，就像我的输入法矿工在“旷工”和“狂攻”的后面一样。\n我回想起某次综艺事故，演员高某身亡，一堆所谓明星在微博发声“演员是高危职业”，要求保障演员权利。有些网友用许多职业的例子来反驳演员算高危职业的观点，更多网友只是把他们当做了公猴和母猴。是啊，这些明星光鲜亮丽、收入不菲，已经是名利双收，但他们还想要更多，也许是“学霸人设”，也许是“职业精神”，也许是公众对他们“社会责任感”认同。我又发现了我好像很少看这些明星的作品，更会觉得明星的综艺就是垃圾。想到这里，我又模糊地感觉我好像知道了我对文艺作品的评判标准。\n当我看完讲这位矿工诗人的视频后，我终于明白了我为何会有如此的好恶观，那就是我不会去喜欢脱离了人民生活的作品。陈年喜的作品是从土里面生长出来的。这里的土，并不是文联主席、副主席衣锦还乡，市委县委作陪时踏上的“乡土”，而是我国最为广大的劳动人民遭受且消化过的无尽苦难和通过劳动创造出的少许幸福。陈年喜爱秦腔，爱孝歌，他的作品集的名字叫做《活着就是冲天一喊》，他的诗集叫做《炸裂志》。\n他写的有些诗句并不逊色顾城、海子太多，当他知道母亲身患食道癌时，他写下“我在五千米深处打发中年/我把岩层一次次炸裂/借此/把一生重新组合/我微小的亲人/远在商山脚下/他们有病/身体落满灰尘/我的中年裁下多少/他们的晚年就能延长多少/我身体里有炸药三吨/他们是引信部分/就在昨夜/在他们床前/我岩石一样/轰地炸裂一地”。他的文字深沉质朴，不用过多修饰也不喜渲染苦难，犹如从土里带着泥巴钻出，但又有着炸裂地底最坚硬岩石的力量。这力量也是柔软的，能令猛士堕泪。\n说实话，大部分现代诗歌的文学意义我难以理解，凭借着时代背景和他人的评价我才能够理解文学史的意义。中国上个世纪的诗人，有多少都是文学史意义大于文学意义。但我时常在想，若不是“主流”的批评家可以看到他们的诗句，若不是他们的诗句带动了那个写诗的时代，他们的文学史意义又从何而来？再如果陈年喜或是其他的工农诗人，他们的作品能够带动公众目光对劳动的关注，对劳动者的关切，以及人民娱乐方式和精神生活的转变升华，他们的文学史意义岂不是比“主流”作家更高更高。\n再谈回到我所讨厌的几种文学吧。\n上个世纪的“伤痕文学”，还有所谓的“新伤痕文学”，他们大多数的反思还是停留在自己的苦难上，并把它归结到人祸之上，于是他们可以批评伟人，讽刺养活他们的所谓“落后体制”，解构中国的传统，滥用中国人的劣根性。但他们从未意识到自己身为知识青年体会到的只是农民的日常，他们应该反思的难道不应该是，为什么自己能够娇柔做作到将几亿人的生活日常视作自己不该承受的灾难。\n而一些有关自然和生态环境的作品，并不是通过表现生态灾难来表达环境保护的重要性，而是以文人对美感的追求出发，空洞地谈过去的自然是美的，现在是不美的。也许这只是我身为理科生的偏见，但他们的确也对工业化和科技发展有偏见。还记得一片文章里，韩少功以他的极其无知，组织着不属于他认知范围的专业名词，冷嘲热讽着人工智能。估计说来也就是答应给某个落魄纸媒的主编的人情，帮他写一篇能够蹭到社会热点的评论文章。发展带来的问题不是发展本身的过错，对发展的贬低莫不是对那些为建设付出血汗的人的背叛。坐在办公室里喝茶的作家老爷们，怎么可能看到工厂开工时对当地就业的贡献、职业病对工人身体的摧残，他们或许也早已失去了或者从未有过能够书写过量劳动和污染对人民的伤害的艺术技巧。说的低情商一点，他们需要去找到自己的初心和良心。\n我网购了《活着就是冲天一喊》和《炸裂志》，就当是支持身患矽肺病的老陈，可惜出版社只有简装版。但我转念一想，那些被我内涵的“主流”作家们，又有多少作品有精装版呢？在这个娱乐至死的时代，他们虽然被关注，但也不过是那余光的一瞥。不过作家们可以开个公众号，再抢一抢流量的残羹冷饭嘛。\n如今的文艺太轻太轻，飘得太高太高，离土地太远太远。\n编辑于 2021-08-13 15:34\n","permalink":"https://vaaandark.top/posts/scribble-in-august/","summary":"\u003cblockquote\u003e\n\u003cp\u003e首发于知乎\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e我从未对很少阅读近三十年的文学作品感到遗憾，因为我并没有从那些已经加入作协的“主流”作家那里汲取过营养，我觉得作家不靠稿费而是靠体制的工资生活是一件奇怪而又羞耻的事情。\u003c/p\u003e","title":"2021 年八月杂感【补档】"},{"content":"代码仓库为 hustos riscv-pke\n以下内容基于 lab2 代码\n入口在哪？ 入口为 kernel/machine/mentry.S 的 _mentry ，它调用了 kernel/machine/minit.c 的 m_start(uintptr_t hartid, uintptr_t dtb) ，两个参数并没有在 _mentry 中设置，这是因为 spike 会自动设置 a0 寄存器为 CPU id ，设置 a1 寄存器为设备树字符串，这刚好也符合 RV 的传参规则。\n值得注意的是， spike 模拟执行 pke 代码时是从 M 模式开始的。\n_mentry 里面做了什么？ 首先是给 mscratch 寄存器赋值为 0 ，再设置操作系统的堆栈。\n设置操作系统堆栈的具体步骤是：将 mhartid 寄存器的值读到 a4 寄存器，之后一系列四则运算重新计算栈底寄存器，让不同 CPU 核心的堆栈不会冲突。比如 thread0 的栈底是 a ， thread1 的栈底就应该是 a + 4096 。\nm_start 函数里面做了什么？ 初始化了一些 spike 的东西，这些不是很重要。\n之后就是将保存中断时上下文的 g_itrframe 的地址赋值给了 mscratch 寄存器（也就是 _mentry 中的注释， mscratch 指向 M 模式下的栈底）。\n将 MPP 设置成了 S 模式，这个 MPP(machine previous privilege) 是指进入 M 模式之前的模式，这样设置的目的是在之后的 mret 后能进入 S 模式。之后将 mepc 寄存器设置为 s_start ，这就能在之后的 mret 后不仅能进入 S 模式，还能从 s_start 开始执行。\n操作系统要在 M 模式执行系统调用，所以要设置系统调用时的入口，也就是把 mtvec 寄存器赋值为 mtrapvec 。之后分析如何进入系统调用时再详细介绍。\n值得注意的是 mtrapvec 要 4-byte 对齐， mtvec 寄存器虽然是 MXLEN 长度的，但是它后两位使用来标识是直接系统调用还是向量系统调用的，所以它只能存 4-byte 对齐的函数入口地址。\n之后依次，打开 M 模式中断，将所有中断和异常委托到 S 模式执行，再打开 S 模式中断，初始化时钟中断。\n最后调用 mret 退出 M 模式，进入到预设好的 S 模式代码，也就是 s_start 。\ns_start 函数里面做了什么？ (未完待续)\n","permalink":"https://vaaandark.top/posts/how-riscv-pke-startup/","summary":"\u003cp\u003e代码仓库为 \u003ca href=\"https://gitee.com/hustos/riscv-pke\"\u003ehustos riscv-pke\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e以下内容基于 lab2 代码\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"入口在哪\"\u003e入口在哪？\u003c/h3\u003e\n\u003cp\u003e入口为 \u003ccode\u003ekernel/machine/mentry.S\u003c/code\u003e 的 \u003ccode\u003e_mentry\u003c/code\u003e ，它调用了 \u003ccode\u003ekernel/machine/minit.c\u003c/code\u003e 的 \u003ccode\u003em_start(uintptr_t hartid, uintptr_t dtb)\u003c/code\u003e ，两个参数并没有在 \u003ccode\u003e_mentry\u003c/code\u003e 中设置，这是因为 spike 会自动设置 \u003ccode\u003ea0\u003c/code\u003e 寄存器为 CPU id ，设置 \u003ccode\u003ea1\u003c/code\u003e 寄存器为设备树字符串，这刚好也符合 RV 的传参规则。\u003c/p\u003e","title":"华科 OS 实验的 RISC-V 代理内核是如何启动的？"},{"content":"昨天朋友跟我说我的 MIT6.S081 lab1 的 xargs 命令的代码无法通过，看到他的测试方法才知道原来是这样测试的，感觉之前写的测的都太简略了。\n例如测试 xargs 命令这一关可以这样测试：\n$ make GRADEFLAGS=xargs grade 之前的博客在这里：MIT6.S081 Lab: Xv6 and Unix Utilities\n检查了一下我之前的代码，发现完全没有处理多行的情况，在测试的时候就会出现问题。\n偷看一下测试用的脚本：\nmkdir a echo hello \u0026gt; a/b mkdir c echo hello \u0026gt; c/b echo hello \u0026gt; b find . b | xargs grep hello 所以对于 find . b ，它的结果会是三行：\n./a/b ./c/b ./b 管道之后的 xargs 应该执行三次 grep ，这才是正确的行为：\ngrep hello ./a/b grep hello ./c/b grep hello ./b 但是我使用 read() 处理的时候又发现了新的问题，管道不是行缓冲的，不方便直接读入一行，想要换用 scanf() 但是 xv6 没有提供，所以只能一个字符一个字符手动处理：\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/param.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { char buf[1024]; char *cmd[MAXARG]; memset(buf, 0, 1024); memset(cmd, 0, sizeof(char *) * MAXARG); for (int i = 1; i \u0026lt; argc; ++i) { cmd[i-1] = argv[i]; } char ch; char *p = buf; int blanked = 1; int ncmd = argc - 1; while (read(0, \u0026amp;ch, 1) \u0026gt; 0) { if (ch == \u0026#39; \u0026#39; || ch == \u0026#39;\\t\u0026#39;) { *p = \u0026#39;\\0\u0026#39;; blanked = 1; p += 1; } else if (ch == \u0026#39;\\n\u0026#39;) { if (fork() == 0) { exec(cmd[0], cmd); } else { wait(0); } memset(buf, 0, sizeof buf); p = buf; ncmd = argc - 1; } else { if (blanked) { blanked = 0; cmd[ncmd] = p; ncmd += 1; } *p = ch; p += 1; } } exit(0); } ","permalink":"https://vaaandark.top/posts/mit6.s081-labfixup-xargs/","summary":"\u003cp\u003e昨天朋友跟我说我的 MIT6.S081 lab1 的 \u003ccode\u003exargs\u003c/code\u003e 命令的代码无法通过，看到他的测试方法才知道原来是这样测试的，感觉之前写的测的都太简略了。\u003c/p\u003e\n\u003cp\u003e例如测试 \u003ccode\u003exargs\u003c/code\u003e 命令这一关可以这样测试：\u003c/p\u003e","title":"MIT6.S081 Lab:Fixup Xargs"},{"content":"即是知识回顾，也是最近学到知识的拓展延伸。\nARMv6 Manual: \u0026ldquo;The only architecturally-guaranteed way to invalidate all aliases of a physical address from a VIPT instruction cache is to invalidate the entire instruction cache.\u0026rdquo;\nCache 的基本情况 Cache 也就是缓存，作为高速的 CPU 和低速的内存之间的缓冲，用于加速访问。\n一个内存地址一般分为三个部分，由高到低分别为 tag, index 和 offset 。index 用于索引缓存行，offset 用于确定在缓存行的位置。\n为什么需要 tag 呢？这是因为缓存的大小是远远小于内存大小的，所以不同的 index 可能对应同一个缓存行，所以需要使用 tag 来区分。\n那为什么 tag 是高位，而 index 是低位呢？这是因为一般情况下访问的内存都是若干块连续的，处于不同块的内存地址低位可能重复而高位不重复。\n有三种 Cache 组织方式，分别是全相连、组相连和直接相连，其中全相连不划分 index ，直接比对 tag 。\n多级 Cache 为了进一步提升访存速度，人们引入了多级 Cache 。现代 CPU 一般有 3 级，以 Cortex-A53 为例，它的 L1 cache 是 CPU 私有的，L2 cache 是同一个 cluster 共享的，L3 cache 是所有 CPU 共享的，并以总线与内存相连。\nicache/dcache 及其一致性 在 L1 或者 L2 cache 中，一些 CPU 会将 cache 分为 instruction cache 和 data cache 。这有两个考虑，一是性能，二是成本。本质原因是 CPU 对指令和数据的访问方式不同，指令一般是只读的，不需要把电路设计得非常复杂。\n不过现实还是比较残酷的，很多时候 icache 是不能保证只读，比如 GCC 调试打断点的时候就会修改指令，它先将数据加载到 dcache 中再修改，这时就需要解决 icache 和 dcache 的一致性问题。\nMMU 和 TLB MMU 是 Memory Management Unit ，用于将把虚拟地址转换为物理地址。Linux 中的页表一般是四级的，也可以配置为五级。从高到底分别为：\nPGD：page Global directory(47-39), 页全局目录 PUD：Page Upper Directory(38-30)，页上级目录 PMD：page middle directory(29-21)，页中间目录 PTE：page table entry(20-12)，页表项 这解决了利用少量页面数据管理大量内存的问题，但是也会让一次查询需要在内存中查四次页表，大大降低了访存速度，所以 MMU 中也需要一个类似 Cache 的存在，那就是 TLB 。TLB 的访问速度比 L1 还要快，和寄存器相当。\n由于页面大小一般为 4KB ，因此 TLB 不需要管最低的 12 位。而且 TLB 的一个 entry 只存一个物理地址，所以也不需要类似 cache 的 offset 字段，虚拟地址只需要分成 tag 和 index 两个部分。\nVIVT vs VIPT vs PIPT 这里的 V 代表 virtual ， P 代表 physical ， I 和 T 分别代表 index(ed) 和 tag(ged) 。\n前面说了通过 tag 和 index 在 cache 中查找，但是这里的 tag 和 index 位于虚拟地址还是物理地址呢？\n歧义和别名 我们也可以先注意两个问题：歧义(ambiguity)和别名(aliasing)。\n歧义指不同的数据有相同的 tag 和 index ，从而导致无法区别。 别名指不同的虚拟地址映射相同的物理地址（这在 Linux 中很常见），这容易导致 cache 的数据不一致问题。 VIVT 这种 index 和 tag 都取自虚拟地址的方法又叫虚拟高速缓存。在这种情况下，只要 cache 命中，就不需要进行地址翻译，这提升了速度，也设计简单。\n但是这样的设计暂时还不能解决 ambiguity 和 aliasing 问题。\n想要解决 ambiguity ，可以在每次切换进程的时候 flush 所有的 cache ，但是这样又会导致大量的 cache miss 。\n想要解决不同进程的 aliasing ，也可以在每次切换进程的时候 flush 所有的 cache 。\n如果是同一个进程的 aliasing ，就没有很好的办法了。\nPIPT 这种 index 和 tag 都取自物理地址的方法又叫物理高速缓存。这样的设计可以让操作系统少操心，完全避免了 ambiguity 和 aliasing 问题。\n虽然 PIPT 在软件层面基本不需要维护，但是硬件设计上比 VIVT 复杂很多，成本也更高。而且由于虚拟地址每次都要先翻译成物理地址，因此在查找性能上低于 VIVT 。\nVIPT 在索引 cache 时，可以使用虚拟地址的一部分作为 cache 的inde 。而 cache 的 tag 则使用物理地址中的 PFN （独一无二，后文也会说到）。这种方法的好处是，TLB 翻译得到 PFN 和 index 索引 cache 是同时进行的。\n为什么没有歧义问题？ 我们可能有种思维惯性， tag 就是地址的一部分，和 index 合在一起才能成为一个低 offset 位为 0 的地址。这种说法在 VIVT 中是对的，但是在 VIPT 中是错的。tag 本来就是标签的意思，只是用于区分相同 index ，它并不意味着它是减去 index 的那些位。 只是在 cache 的查询中， tag 和 index 没有重合而且合起来刚好覆盖了地址中除了 offset 的位。\n现在再看 MMU ，一般情况下 64 位地址只用了低 48 位表示地址，而一个页面一般是 4KB 。这样一来， MMU 只需要将 47 位到 12 位进行地址映射，这和 VIVT 的 index 和 tag 的那些位是不同的。\n既然都使用了 MMU 把虚拟地址的全部位翻译成了物理地址，那么为什么还要取物理地址中和 VIVT 中的 tag 一样的位呢？所以 VIPT 使用这 47 位到 12 位作为 tag ，这些 tag 是独一无二的，可以完全避免 ambiguity 的问题。\n什么时候没有别名问题？ 可以发现， VIPT 虽然没有直接解决别名问题，但有些情况下可以避免别名，那就是 cache size 除以路数小于 page 大小时。即 index + offset \u0026lt;= 12bit 不会发生重名，即只要 cache 每一路小于等于 4KB ，就不会发生重名。即 4KB 直接映射、 8KB 两路组相联、 32KB 八路组相联等，都不会有问题。此时 VIPT 的功能和 PIPT 一致，但速度和 VIVT 一致，可以说综合了两者的优点。\n但是，当 index + offset \u0026gt; 12bit （页面大小为 4KB ）时，对应同一个物理地址的两个虚拟地址可能被分配到两个 cache set 中，就出现了重名现象。\n如果无法避免别名，如何解决？ 很多 CPU 的 L1 dcache 都遵循了上述的 cache 每一路小于 4KB 的规律。但是继续增加 cache size 的同时继续增加相联度会导致过于复杂的时序。此时，我们不得不增大 cacheline 和增加组数，最后导致 index + offset \u0026gt; 4KB 。\n解决办法其实也很简单，可以在操作系统层面上创建共享内存的时候地址要按照一路 cache size 对齐，这样就完全避免了别名问题。这也就是 page coloring 技术。它相当于将一路 cache 按照 page 的大小切分了。\n例如 page size 是 4KB ，而一路 cache size 是 16 KB ，则我们可以将页面按顺序填上 16 / 4 = 4 种颜色，只有颜色相同的虚拟页面才能分配到对应的物理地址上，这也就做到了按照一路 cache size 对齐了。\n对于上例，一些 CPU 的做法：\n最简单的方法是确保给定虚拟地址的第 12 位和第 13 位（也就是 VPN 的低两位）与相应物理地址中的相同位匹配。即相当于将页面大小改大为 16KB ，这需要 CPU 支持修改 MMU 粒度。 如果仅使用 4KB 页面，则可以构建保留颜色限制的映射，并允许虚拟地址和物理地址之间的第 12 位和第 13 位不同。这种做法会增加额外的复杂性。 硬件方法解决，例如 香山架构 。 现代 CPU 的选择 多数的选择 绝大多数 CPU 的 L2 L3 都是 PIPT 的，不同点在于 L1 cache 的设计。\nL1 cache 的 dcache 和 icache 可以采用不同的设计，分别选用 VIPT 或者 PIPT 。很多 CPU 的 L1 dcache 使用的是 PIPT 而 icache 是 VIPT 。\n少数 VIVT 的 L1 设计 传统上，虚拟地址的缓存有很多缺点：它们会在上下文切换或 TLB 维护操作时被刷新，因为更改虚拟地址到物理地址的映射意味着一个虚拟地址的缓存的内容不再是最新的。\n但是可以通过引入 ASID （标记不同进程）来避免上下文切换时刷新，还可以通过记录 VA 到 PA 的别名来解决别名问题。\n趣事：ARM 与 mmap ARMv6 和 ARMv7 执行相同的 mmap 代码会有不同的结果， v6 会失败，而 v7 会成功：\n// Preconditions: // - fd is a file descriptor as returned from open() (or a related function). // - The file is at least 4096 bytes long (and so can fill the mapping). // - The file\u0026#39;s permissions are compatible with those in the mmap calls. // - MAP_FIXED is supported. // - The addresses provided can be mapped by the process, and are not // allocated or otherwise reserved or invalid. void * buffer0 = mmap((void*)(0x12340000), 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fd, 0); void * buffer1 = mmap((void*)(0xdebc1000), 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fd, 0); 这段代码将文件映射到了两种颜色的虚拟地址上，可以看到 0x12340000 的第十二十三位是 00 ，而 0xdebc1000 的第十二十三位是 01 ，这违背了 page coloring 的原则。\n两代架构执行代码的结果不同是因为：v6 的 dcache 是 vipt 的，而 v7 的 dcache 是 pipt 的，所以 v7 不存在别名问题，而 v6 存在。\n参考资料 HotChips 2023: Ventana 不寻常的 Veyron V1 香山官方文档 arm community: Page Colouring on ARMv6 (and a bit on ARMv7) ","permalink":"https://vaaandark.top/posts/relearning-cpu-2-cache-and-tlb/","summary":"\u003cp\u003e即是知识回顾，也是最近学到知识的拓展延伸。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eARMv6 Manual: \u0026ldquo;The only architecturally-guaranteed way to invalidate all aliases of a physical address from a VIPT instruction cache is to invalidate the entire instruction cache.\u0026rdquo;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"cache-的基本情况\"\u003eCache 的基本情况\u003c/h2\u003e\n\u003cp\u003eCache 也就是缓存，作为高速的 CPU 和低速的内存之间的缓冲，用于加速访问。\u003c/p\u003e","title":"恶补 CPU 知识之 Cache 和 TLB"},{"content":"前因 最近看了一篇介绍 Ventana 的 Veyron V1 核心的博客 HotChips 2023: Ventana 不寻常的 Veyron V1 ，里面出现了很多我没听说过或者不甚了解的名词，在阅读这篇博客和查找资料的过程中，我学到了很多新的 CPU 知识。\nBTB 是什么？ BTB 即分支目标缓冲(Branch Target Buffer)，本质上是 Cache ，通过当前 PC 的一部分进行索引，与 entry 中的 tag 进行比对，输出的是 target address 。\nBTB 解决的是什么问题呢？解决的是如何快速定位跳转地址的问题。但是，跳转的地址一般就在指令中，取出来几乎是无延迟的，那为什么需要快速定位呢？原因在于分支预测在取指阶段之前！只有先做预测才能快速取出多条指令进行译码。\n2-bit 饱和计数器是什么？ 解决了跳转地址的问题还需要解决是否跳转的问题，这个一般叫做 Taken / Not taken ，这也是分支预测的核心。\n分支预测的前提是程序执行顺序有一定的规律，或者说有一定的惯性，所以有人就设计出来了 2-bit 饱和计数器：\n之所以叫 2-bit 是因为它有四种状态：strongly taken, weakly taken, weakly not taken, strongly not taken 。每次 actually taken 了，状态就将向左迁移；每次 actually not taken ,状态就将向右迁移。 之所以叫「饱和」是因为当处于 strongly (not) taken 状态时再 (not) taken 不会再迁移状态。 2-bit 饱和计数器是如今分支预测方案的基础，但是单纯只使用它会导致在一些极端条件下性能很低。举一个很简单的例子 NTNTNTNT\u0026hellip; ，它的准确率只有 50% ，这显然是不可接受的。\nBHR 是什么？局部历史分支预测器是什么？ BHR 即分支历史寄存器(Branch History Register)，它的出现是为了配合 2-bit 饱和计数器来提高预测准确率。\nBHR 是一个 n 位的可以不断左移的寄存器，用于存储 n 次分支跳转结果。\n一个 BHR 对应 2^n 个 2-bit 饱和计数器，这样的一组饱和计数器被称为 Pattern History Table(PHT) 。可以想到，此时的分支预测就是通过 BHR 的值来索引 PHT 的计数器。\n以之前提到的 NTNTNTNT\u0026hellip; 这个极端情况为例，假设 BHR 的宽度为 2 ，它会在 10 和 01 之间交替，分别对应了两个计数器，一个会饱和于 taken ，另一个则会饱和于 not taken 。这样一来就完美解决了之前的问题。\n整体的工作流程就是：首先通过 BTB 找到分支 PC ，再通过分支 PC 找到对应的 BHR ，最后通过 BHR 在 PHT 中查找，决定是否 taken 。\nPHT/2-bit counter 何时更新？ 现代 CPU 一般都是超标量的，每次可以取出不止一条指令送入流水线中进行乱序执行。为了保证结果的正确性，必须在 commit/retire 阶段更新，此时不会再因为分支预测的错误导致流水线 flush 。\n但是分支预测一般是流水线的第一个阶段， commit/retire 是最后一个阶段。这样一来，预测和更新之间间隔时间过长，在这个间隔时间内这条指令可能已经按照之前的 counter 状态执行多次了，这好像失去了时效性。但其实不需要担心，这种情况一般发生在循环体很短的情况下，由于饱和计数器的性质，它在几次后就会成为 strongly taken 状态，由于已经饱和，不及时更新也没有关系。\nBHR 何时更新？ 一般情况下 BHR 的更新也是在 commit/retire 阶段的。这也是因为如果在其他阶段会遇到正确性问题，需要额外开销来恢复（或者说修正）。\nBHR 同样不用担心间隔时间过长，原因和上面的 PHT 一样。\nGHR 是什么？全局历史分支预测器是什么？ 这一设计的假设是分支的结果之间互相关联，这在我们日常写的代码中有很多体现，显然是很有道理的。\n这样就只需要一个 Global Branch History Register ，记录所有分支在过去的执行结果。\nGHR 何时更新？ GHR 应当在分支预测后更新，因为两个邻近的分支指令会间隔很短的时间进入流水线，GHR 如果不在分支预测后更新便失去了意义，违反了「分支的结果之间相互关联」的假设。\n分支预测错误了，但是后续的分支指令使用了错误的 GHR 怎么办呢？不用管，因为后续的指令都应该被流水线 flush 掉。 不过，还是需要额外的开销来恢复 GHR 。\nAliasing PHT 是什么问题？ 由于所有的分支使用同一个 PHT ，因此容易出现不同分支指向同一个 PHT entry 的问题。解决方案有很多：\n最简单的方法是增大 PHT ，使用 PC 中更多位来寻找 entry ，这会增加面积和功耗。 还有就是使用 hashing/index-randomization ，比如 Tage(TAgged GEometric history length)，最简单的方法是将 GHR 和 PC 进行异或操作后再寻址，香山架构就使用的是这个方法。以此思想还有很多 hash 设计来防止碰撞。 Warmup/Training time 是什么？ PHT entry的计数器达到饱和状态的时间称为 training time ，它和 BHR/GHR 的长度有关，较长的 BHR/GHR 需要更多的时间 warmup ，但也会记录更多的历史信息，提高预测准确度。较短的 BHR/GHR 不能记录分支的所有结果。\n现代 CPU 很多都是超标量的，下一条分支指令开始预测时上一条分支指令可能还远远没有执行结束。为了尽快拿到分支历史，大部分分支预测机制都会选择「推测更新历史」，也就是上文中说到的在分支预测后立即更新 GHR 。\n全局历史分支预测 \u0026gt; 局部历史分支预测？ 记得之前说过全局分支预测只需要一个 GHR 而局部分支预测需要一组 BHR 吗？这会引起存储介质选择的问题，一个 GHR 再怎么长都可以直接用寄存器存，而一组通过 PC 索引的 BHR 表相对较大，只能用和缓存一样的 SRAM 来存。\n使用 SRAM 来存的问题在于，恢复历史时无法在一拍内恢复或者甚至无法在短时间内恢复。这种维护的困难使得局部历史在现代处理器的分支预测器中很少见到。\n更高级的分支预测机制 将局部和全局历史分支预测结合 The Alpha 21264 Microprocessor Architecture。 预测循环，即使用通过计数避免最后一次循环预测错误。 引入机器学习的方法。 参考资料 知乎问题：现代中央处理器（CPU）是怎样进行分支预测的？ HotChips 2023: Ventana 不寻常的 Veyron V1 现代分支预测：从学术界到工业界 香山官方文档 Two-Level Adaptive Training Branch Prediction ","permalink":"https://vaaandark.top/posts/relearning-cpu-1-branch-prediction/","summary":"\u003ch2 id=\"前因\"\u003e前因\u003c/h2\u003e\n\u003cp\u003e最近看了一篇介绍 Ventana 的 Veyron V1 核心的博客 \u003ca href=\"https://blog.eastonman.com/blog/2024/02/hot-chips-2023-ventanas-unconventional-veyron-v1/\"\u003eHotChips 2023: Ventana 不寻常的 Veyron V1\u003c/a\u003e ，里面出现了很多我没听说过或者不甚了解的名词，在阅读这篇博客和查找资料的过程中，我学到了很多新的 CPU 知识。\u003c/p\u003e","title":"恶补 CPU 知识之分支预测"},{"content":" 赛博考古：Linux 支持 POSIX 线程标准的前世今生\n线程是什么 操作系统能够进行运算调度的最小单位。在一般的操作系统上，它被包含在进程之中，是进程中的实际运作单位。\n线程共享了什么 代码段、数据段、堆 文件描述符 进程信息（如 pid ）、用户 id 和组 id Signal Handle 线程没有共享什么 栈 寄存器 线程优先级和调度策略 TLS(Thread Local Storage)（线程局部存储） tid(可以使用 syscall(SYS_gettid) 查看) Signal Mask 值得注意的问题(pid vs tgid, getpid vs gettid) tg for thread group\ngetpid 是 man 3 里面的，因此它是 Library call ；gettid 是 man 2 里面的，因此它是 System Call 。\n我们使用 unistd.h 中的 getpid() 实际上获取的是 tgid ，而 syscall(SYS_gettid) 实际上获取的是 pid 。\n如图所示，每个线程都有独一无二的 pid ，有可能重复的 tgid 。当一个进程属于一个单线程程序时，它的 pid 就等于 tgid ；当它创建了一个线程时，新的线程拥有一个新的 pid ，同时继承了同一线程组的 tgid 。\nUSER VIEW \u0026lt;-- PID 43 --\u0026gt;|\u0026lt;----------------- PID 42 -----------------\u0026gt; | +---------+ | | | process | | | _| pid=42 |_ | __(fork) _/ | tgid=42 | \\_ (new thread) _ / | +---------+ | \\ +---------+ | | +---------+ | process | | | | process | | pid=43 | | | | pid=44 | | tgid=43 | | | | tgid=42 | +---------+ | | +---------+ \u0026lt;-- PID 43 --\u0026gt;|\u0026lt;--------- PID 42 --------\u0026gt;|\u0026lt;--- PID 44 ---\u0026gt; KERNEL VIEW POSIX Thread 与其说是 pthread 的历史，不如说是 kernel 变得更大更强，对线程模型支持得更好的历史。\nLinuxThreads（早期） NPTL(Native POSIX Thread Library)（现在） 查看你的 pthread 实现：\n$ getconf GNU_LIBPTHREAD_VERSION NPTL 2.38 LinuxThreads 在 Linux 操作系统中， LinuxThreads 是 1996 年推出的 POSIX Threads 的部分实现，其主要开发者是 Xavier Leroy 。\n管理线程(Manager Thread) 为什么需要管理线程？\n对致命的信号做出反应(fatal signals)，并杀死或终止整个线程。（后文详细说明这一点的原因，这是由 LinuxThreads 的缺陷导致的） 释放用作线程栈的内存不能由该线程本身执行，必须要等这个线程结束再进行，因此需要特殊的管理线程来收尾。 释放 tls 需要遍历所有线程，因此需要管理线程。 终止线程必须是等待的（由管理线程等待），不然会出现僵尸线程。 当主线程调用 pthread_exit() 时，这个进程不能就此结束。正确的行为是，主线程 sleep ，当其他线程被杀死后管理线程再唤醒主线程，主线程此时才能退出。 缺陷 管理线程带来的额外开销。 使用信号实现同步原语。 基本符合 POSIX 标准，信号处理除外。 LinuxThreads 实现的线程，本质上是共享了内存、文件描述符的进程，它们有着不同的 pid ，它们并不作为进程的一个整体：\n这里的 pid 是抽象概念，当时的 Kernel 并没有 pid 和 tgid 的区别。\n发送到线程 pid 的信号只能由该线程处理。只要没有线程阻塞该信号，该行为就符合标准：程序的一个（未指定）线程处理该信号。 但是，如果向 pid 发送信号的线程阻塞了信号，那么 LinuxThreads 将简单地在该线程中排队，仅当该线程解除阻塞信号时才执行处理程序，而不是立即在不阻塞信号的另一个线程中执行。 实现者的吐槽：This is to be viewed as a LinuxThreads bug, but I currently don\u0026rsquo;t see any way to implement the POSIX behavior without kernel support.\n线程模型 此时就已经出现了 Linux 代表性的一对一(one-to-one)模型。内核对线程和进程不做区分，所谓的内核线程是 task_struct ，而内核调度时也只考虑它们。\none-to-one vs many-to-one 当用户创建出很多用户线程时， Linux 的做法是：每当用户调用库函数创建线程，库函数让内核创建出一个新的内核线程。\n多处理器上，CPU 密集型程序的开销最小，即每个处理器上都可以跑一个线程（思考一下如果是 many-to-one ，一个内核线程对应多个用户线程，则很难在多核上并行）。 I/O 操作开销最小（思考一下如果是 many-to-one ，阻塞 IO 操作实现起来有多么复杂）。 实现简单，不与内核过度耦合（内核调度可以完成大部分复杂工作）。 one-to-one vs many-to-many 那么为什么不用多对多模型呢？\n当时大多数商业 Unix 系统（Solaris、Digital Unix、IRIX）都以这种方式实现 POSIX 线程。该模型结合了“多对一”和“一对一”模型的优点，很有吸引力。\n多对多模型能成功避免两种模型的最坏情况。在上下文切换成本高昂的内核 Digital Unix 上多对多模型几乎可以说是唯一选择。\n但是，多对多模型的实现相当复杂，并且需要 Linux 增加支持很多新的功能。另一方面，Linus Torvalds 和其他 Linux 内核开发人员一直以整体简单性的名义推动一对一模型，更何况 Linux 的上下文切换效率相当出色。\n虽然多对多模型在 pthread 中被放弃，但是它在一些编程语言的运行时中大放异彩。\n管理线程与一对一模型结合导致的问题 管理线程只能在一个核上运行，这导致加速比变低，性能变差。 由于整个系统围绕着管理线程设计，上下文切换开销变大。 NPTL 为了解决 LinuxThreads 的一些问题，内核开发人员设计实现了 NPTL(Native POSIX Thread Library) 。\nNPTL 完全兼容 POSIX 标准。 NPTL 在多处理器机器上效果也很好。 NPTL 的启动开销不大。 NPTL 也能利用到 NUMA 架构的优势。 NPTL 和 LinuxThreads 二进制兼容（LD 实现的）。 利用了新的内核特性 NPTL 无需管理线程： 不需要转发 fatal signal 的工作，内核可以处理好向某一进程发送信号的工作。 不需要由管理线程析构，内核可以处理线程内存的释放。 不需要管理线程来避免僵尸线程，内核可以在清理父线程前等待所有线程。 去掉管理线程，对 SMP 和 NUMA 更友好。 使用 futex 来实现同步，而且 futex 可以在进程间共享，能在更多场景使用。 NPTL 的每个线程都有自己的父线程，在进行资源统计时便于统计整个进程，此前的 LinuxThreads 不能做到。 如何实现 TLS 我们都知道在写声明时加入 __thread 可以声明一个线程局部变量。那它是如何实现的呢？\n在早期 LinuxThreads 的实现中， TLS 直接放在线程栈旁边。而在引入 NPTL 后，各个 libc （如 glibc, uClibc, musl）都是使用新增的 ELF 标准对 TLS 的支持和动态链接器来实现的。\n查看一个 __thread 声明的汇编代码时，我们可能看到 mov %fs:0xfffffffffffffffc,%eax 。\n这也就是 mov %fs:-4,%eax 。\n这是什么？这太奇怪了！\n虽然某些 CPU 架构有专用的寄存器来保存线程特定的上下文，但 x86 没有。众所周知，x86 只有少量的通用寄存器。\n英特尔 80386 引入了 FS 和 GS 作为用户定义的段寄存器，但没有规定它们的用途。然而，随着多线程编程的兴起，人们看到了重新利用 FS 和 GS 的机会，并开始将它们用作线程寄存器。\nTLS 的结构：\n使用 dlopen 加载的 DSO(动态共享对象) 放在动态 TLS 中，其余的放在静态 TLS 中。 $dtv_t$ 可以看作是一个二维数组，可以通过模块 id 和偏移量对任何 TLS 变量进行寻址。TLS 变量偏移量是模块中的本地偏移量，模块 id 是进程中加载的 ELF 对象的索引号。 访问一个 TLS 变量的通用方法：\ndtv[-1].counter; /* Pro tip: The length of this dtv array */ dtv[0].counter; /* Generation counter for the DTV in this thread */ dtv[1].pointer; /* Pointer to the main executable TLS block in this thread */ /* Pointer to a TLS variable defined in a module id `ti_module` */ main_tls_var = *(dtv[tls_index.ti_module].pointer + tls_index.ti_offset); 编译器和动态链接器共同计算出地址，因为可执行文件的 TLS 块和 TLS 偏移量都是提前知道的。\n这种合作依赖于编译器在构建时的以下「事实」：\nFS 寄存器指向 TCB 。 编译器设置的 TLS 变量偏移量在运行时不会更改。 可执行文件的 TLS 块位于 TCB 之前。 同时，将 TLS 放在 TCB 之前可以让经常被访问的内存更持久地留在缓存中。\nReference LinuxThreads Frequently Asked Questions Linux threading models compared: LinuxThreads and NPTL NPTL design uClibc NPTL design ELF Handling for Thread-Local Storage All about thread-local storage A Deep dive into (implicit) Thread Local Storage ","permalink":"https://vaaandark.top/posts/pthread/","summary":"\u003cblockquote\u003e\n\u003cp\u003e赛博考古：Linux 支持 POSIX 线程标准的前世今生\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"线程是什么\"\u003e线程是什么\u003c/h2\u003e\n\u003cp\u003e操作系统能够进行运算调度的最小单位。在一般的操作系统上，它被包含在进程之中，是进程中的实际运作单位。\u003c/p\u003e","title":"Pthread"},{"content":"看到了 xuanwo 的一篇 博客，感觉很有意思。\n完整读一遍也可以，不过也可以看我的省流。\nPython IO 比 C / Rust IO 更快 有人发现在 AMD Ryzen 9 5900X 和 AMD Ryzen 7 5700X 上访问页对齐的前10个 byte 会比其他偏移有更多的 L1 prefetch 和 load 的 miss 。 学过 x86 汇编的应该知道不同于 RISC ，x86 是有专门用于复制字符串的指令的。有人发现上述问题的底层原因来自于 AMD 对 FSRM(Fast Short REP MOV) 的实现，逆天的是在 Zen 3 上，访问页对齐的数据比不对齐慢。 更有趣的事情 作者发现将 C 的分配器换成 jemalloc 后速度就可以击败 Python 了，我个人猜测可能是 mmap 后分配的页对齐的内存使用了更多（也就是大于 glibc 的 10 byte）来存 meta data ，恰巧避免了这个硬件 bug 。 有人使用 eBPF profile 发现 Rust 和 Python 的 fs read 在系统调用的延迟上存在差距，Rust 更慢。 为了解决这个奇怪的性能问题，作者（开源大手子漩涡）和他的开源伙伴（包括了热心网友、国内开源大佬依云和一些内核开发者）使用了 strace, perf, eBPF 等各种性能分析工具，以及分析了各种可能导致性能问题的原因（内存大页、CPU 核亲和性、mmap 分配匿名内存、Linux 启动选项例如 Enable Mitigations、系统调用延迟等）。 有 朋友 告诉我「Intel 前几天刚出了 rep mov 导致的 Dos 漏洞」。 好消息是 FSRM 是微码实现，也许在未来的某一次更新就修好了🥰。 相关链接 Terrible memcpy performance on Zen 3 when using rep movsb ","permalink":"https://vaaandark.top/posts/rust-slower-than-python/","summary":"\u003cp\u003e看到了 \u003ca href=\"https://github.com/Xuanwo/\"\u003exuanwo\u003c/a\u003e 的一篇 \u003ca href=\"https://xuanwo.io/2023/04-rust-std-fs-slower-than-python/\"\u003e博客\u003c/a\u003e，感觉很有意思。\u003c/p\u003e\n\u003cp\u003e完整读一遍也可以，不过也可以看我的省流。\u003c/p\u003e\n\u003ch2 id=\"python-io-比-c--rust-io-更快\"\u003ePython IO 比 C / Rust IO 更快\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e有人发现在 AMD Ryzen 9 5900X 和 AMD Ryzen 7 5700X 上访问页对齐的前10个 byte 会比其他偏移有更多的 L1 prefetch 和 load 的 miss 。\u003c/li\u003e\n\u003cli\u003e学过 x86 汇编的应该知道不同于 RISC ，x86 是有专门用于复制字符串的指令的。有人发现上述问题的底层原因来自于 AMD 对 FSRM(Fast Short REP MOV) 的实现，\u003cstrong\u003e逆天的是在 Zen 3 上，访问页对齐的数据比不对齐慢\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"更有趣的事情\"\u003e更有趣的事情\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e作者发现将 C 的分配器换成 jemalloc 后速度就可以击败 Python 了，我个人猜测可能是 mmap 后分配的页对齐的内存使用了更多（也就是大于 glibc 的 10 byte）来存 meta data ，恰巧避免了这个硬件 bug 。\u003c/li\u003e\n\u003cli\u003e有人使用 eBPF profile 发现 Rust 和 Python 的 fs read 在系统调用的延迟上存在差距，Rust 更慢。\u003c/li\u003e\n\u003cli\u003e为了解决这个奇怪的性能问题，作者（开源大手子漩涡）和他的开源伙伴（包括了热心网友、国内开源大佬依云和一些内核开发者）使用了 strace, perf, eBPF 等各种性能分析工具，以及分析了各种可能导致性能问题的原因（内存大页、CPU 核亲和性、mmap 分配匿名内存、Linux 启动选项例如 Enable Mitigations、系统调用延迟等）。\u003c/li\u003e\n\u003cli\u003e有 \u003ca href=\"https://github.com/Enter-tainer\"\u003e朋友\u003c/a\u003e 告诉我「Intel 前几天刚出了 \u003ccode\u003erep mov\u003c/code\u003e 导致的 Dos 漏洞」。\u003c/li\u003e\n\u003cli\u003e好消息是 FSRM 是微码实现，也许在未来的某一次更新就修好了🥰。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"相关链接\"\u003e相关链接\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://bugs.launchpad.net/ubuntu/+source/glibc/+bug/2030515\"\u003eTerrible memcpy performance on Zen 3 when using rep movsb\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"为什么 Rust std fs 慢于 Python"},{"content":"最近在完成一个使用 Rust 语言编写 Linux 内核引导程序的项目 lboot ，其核心代码和原理在之前的博客中介绍过 UEFI 如何启动 Linux 。\n因为不可能直接在 UEFI 环境下进行代码开发，所以我使用的是交叉编译的方法，目标平台是 x86_64-unknown-uefi 和 aarch64-unknown-uefi 。这就带来了一个问题，使用命令 cargo run 不能直接运行代码，必须使用 qemu 来模拟目标架构的执行。\n真的不行吗？其实是可以的🥳🥳🥳\n在翻阅 Cargo Book 之后发现，在命令行重载这一章中写到可以使用 runner 字段来定义自己的 cargo run 行为。\n当执行 cargo run 时，cargo 会首先将这个 runner 字段中的命令末尾附上构建出的可执行文件的路径（相当于把路径传入 runner 脚本或命令），然后执行这个命令。\n所以我编写了一个包装脚本 ，它接受两个参数，第一个是目标平台，第二个是 UEFI 可执行文件的路径。然后编写 .cargo/config.toml 文件：\n[target.x86_64-unknown-uefi] runner = \u0026#34;test/qemu_run.sh x86_64\u0026#34; [target.aarch64-unknown-uefi] runner = \u0026#34;test/qemu_run.sh aarch64\u0026#34; runner 字段只写一个参数是因为，cargo run 时可执行文件路径会附加到最后。\n现在就可以直接 cargo run 启动 qemu 仿真了！\n","permalink":"https://vaaandark.top/posts/cargo-runner/","summary":"\u003cp\u003e最近在完成一个使用 Rust 语言编写 Linux 内核引导程序的项目 \u003ca href=\"github.com/vaaandark/lboot\"\u003elboot\u003c/a\u003e ，其核心代码和原理在之前的博客中介绍过 \u003ca href=\"https://vaaandark.top/posts/how-uefi-startup-linux/\"\u003eUEFI 如何启动 Linux\u003c/a\u003e 。\u003c/p\u003e\n\u003cp\u003e因为不可能直接在 UEFI 环境下进行代码开发，所以我使用的是交叉编译的方法，目标平台是 \u003ccode\u003ex86_64-unknown-uefi\u003c/code\u003e 和 \u003ccode\u003eaarch64-unknown-uefi\u003c/code\u003e 。这就带来了一个问题，使用命令 \u003ccode\u003ecargo run\u003c/code\u003e 不能直接运行代码，必须使用 qemu 来模拟目标架构的执行。\u003c/p\u003e","title":"Cargo Runner"},{"content":"之前讲到了 Linux 是如何启动的，现在就写一个 UEFI 程序可以启动 Linux ，语言选择的是非常火热的 Rust 。\nLinux Kernel 经过了这么多年的发展，其实完全有着 boot 的能力，使用 UEFI 启动 Kernel 其实是非常简单的一件事情，不再需要像以前 BIOS 启动老版本内核一样要把内核加载到某个内存地址，把参数放到某个内存地址，再将这个地址放到寄存器中等等复杂操作。\n制作 Kernel 镜像 启动 Linux 之前我们首先需要一个 Linux Kernel 的镜像。\n首先从 kernel.org 上拉取最新的 release Linux 6.5.5 ：\n$ wget \u0026#39;https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.5.5.tar.xz\u0026#39; $ tar -xf linux-6.5.5.tar.xz $ cd linux-6.5.5 再配置一下编译选项，要把内核编译成一个 EFI 格式的可执行文件：\n$ make menuconfig 找到并进入 \u0026ldquo;Processor type and features\u0026rdquo; ，并勾选 \u0026ldquo;EFI stub support\u0026rdquo; ，。\n目前的 Kernel 中 \u0026ldquo;EFI stub support\u0026rdquo; 是默认勾选，只是为了确认一下\n然后就可以编译了：\n$ make -j \u0026#34;$(nproc)\u0026#34; 完成之后可以看到在 arch/x86/boot/ 下有个 bzImage ，这就是编译出来的内核：\n$ file arch/x86/boot/bzImage arch/x86/boot/bzImage: Linux kernel x86 boot executable bzImage, version 6.5.5 (vandark@hustcpu01) #2 SMP PREEMPT Fri Sep 29 02:03:58 CST 2023, RO-rootFS, swap_dev 0xB, Normal VGA 构建 initramfs 和 rootfs 只是想要启动看看效果的话其实只需要复制 /boot/initramfs-linux.img 到 esp/efi/boot 中就可以了，这样的话能够进入一个使用内存当作磁盘的 Linux 环境中，但这也足以验证 Linux 的成功启动了。\n编写 Rust UEFI 代码 #![no_main] #![no_std] extern crate alloc; use alloc::vec::Vec; use log::info; use uefi::prelude::*; use uefi::proto::device_path::build::media::FilePath; use uefi::proto::device_path::build::DevicePathBuilder; use uefi::proto::device_path::{DevicePath, DeviceSubType, DeviceType, LoadedImageDevicePath}; use uefi::proto::loaded_image::LoadedImage; use uefi::table::boot::LoadImageSource; use uefi::{ entry, table::{Boot, SystemTable}, Handle, }; #[entry] fn main(image_handle: Handle, mut st: SystemTable\u0026lt;Boot\u0026gt;) -\u0026gt; Status { uefi_services::init(\u0026amp;mut st).unwrap(); let bt = st.boot_services(); info!(\u0026#34;Start booting...\u0026#34;); let mut storage = Vec::new(); let kernel_image_path = get_kernel_device_path(bt, \u0026amp;mut storage); let kernel_image_handle = bt .load_image( image_handle, LoadImageSource::FromDevicePath { device_path: kernel_image_path, from_boot_manager: false, }, ) .expect(\u0026#34;failed to load kernel\u0026#34;); // 加载 kernel image let mut kernel_loaded_image = bt .open_protocol_exclusive::\u0026lt;LoadedImage\u0026gt;(kernel_image_handle) .expect(\u0026#34;failed to open LoadedImage protocol\u0026#34;); // 设置参数，只设置了 initrd 没有设置 root let load_options = cstr16!(r\u0026#34;initrd=efi\\boot\\initramfs-linux.img\u0026#34;); unsafe { kernel_loaded_image.set_load_options( load_options.as_ptr().cast(), load_options.num_bytes() as u32, ); } // 启动 kernel image bt.start_image(kernel_image_handle).expect(\u0026#34;failed to launch kernel\u0026#34;); Status::SUCCESS } fn get_kernel_device_path\u0026lt;\u0026#39;a\u0026gt;(bt: \u0026amp;BootServices, storage: \u0026amp;\u0026#39;a mut Vec\u0026lt;u8\u0026gt;) -\u0026gt; \u0026amp;\u0026#39;a DevicePath { let loaded_image_device_path = bt .open_protocol_exclusive::\u0026lt;LoadedImageDevicePath\u0026gt;(bt.image_handle()) .expect(\u0026#34;failed to open LoadedImageDevicePath protocol\u0026#34;); let mut builder = DevicePathBuilder::with_vec(storage); for node in loaded_image_device_path.node_iter() { if node.full_type() == (DeviceType::MEDIA, DeviceSubType::MEDIA_FILE_PATH) { break; } builder = builder.push(\u0026amp;node).unwrap(); } builder = builder .push(\u0026amp;FilePath { path_name: cstr16!(r\u0026#34;efi\\boot\\bzImage.efi\u0026#34;), }) .unwrap(); builder.finalize().unwrap() } 在 qemu 环境中运行：\n$ mkdir -p esp/efi/boot $ cp target/x86_64-unknown-uefi/debug/boot.efi esp/efi/boot/bootx64.efi $ cp bzImage esp/efi/boot/bzImage.efi $ cargo build --target x86_64-unknown-uefi $ qemu-system-x86_64 -enable-kvm \\ -m 1G \\ -hda disk.qcow2 \\ -serial stdio \\ -drive if=pflash,format=raw,readonly=on,file=OVMF_CODE.fd \\ -drive if=pflash,format=raw,readonly=on,file=OVMF_VARS.fd \\ -drive format=raw,file=fat:rw:esp OVMF 是为虚拟机开启 UEFI 支持的工具\n好耶！成功引导启动了 Linux ！\n","permalink":"https://vaaandark.top/posts/how-uefi-startup-linux/","summary":"\u003cp\u003e之前讲到了 Linux 是如何启动的，现在就写一个 UEFI 程序可以启动 Linux ，语言选择的是非常火热的 Rust 。\u003c/p\u003e\n\u003cp\u003eLinux Kernel 经过了这么多年的发展，其实完全有着 boot 的能力，使用 UEFI 启动 Kernel 其实是非常简单的一件事情，不再需要像以前 BIOS 启动老版本内核一样要把内核加载到某个内存地址，把参数放到某个内存地址，再将这个地址放到寄存器中等等复杂操作。\u003c/p\u003e","title":"UEFI 如何启动 Linux"},{"content":" \u0026ldquo;pull oneself up by one\u0026rsquo;s bootstraps.\u0026rdquo;\n拽着鞋带把自己拉起来\n大家在安装 Arch Linux 或者其他 Linux 发行版时，可能会看到很多有关启动或者引导的名词，例如 BIOS 、UEFI 、GRUB 、ESP 、GPT 、LBA 、MBR 等等。有些名词比较熟悉，有些就会一头雾水，今天就来讲讲这些名词。\nBIOS vs UEFI BIOS（Basic Input Output System，基本输入输出系统）是固化在计算机主板中的程序代码，其主要功能是在计算机上电时对硬件进行初始化配置，并将硬件操作封装为BIOS中断服务。这样，各种硬件间的差异便由 BIOS 负责维护，程序直接调用 BIOS 中断服务即可实现对硬件的控制。\n加电自检程序，在开机时负责检测硬件设备是否正常工作 系统初始化程序，其中包括硬件设备的初始化以及创建 BIOS 中断向量等 适配外围即插即用设备 CMOS 设置程序，负责读写保存在 CMOS 中的系统设置信息 UEFI（Unified Extensible Firmware Interface，统一可扩展固件接口）则是一种规范，它描述了操作系统和平台固件之间的接口，其目的是为操作系统和平台固件定义一种通信方法。在 UEFI 中，设备的访问是通过句柄（Handle）和协议（Protocol）抽象出来的。UEFI 通过将基础实现隔离在规范之外，以避免给设备的访问者带来负担，进而促进现有 BIOS 代码的重用。\nBIOS ，启动！ 在系统上电后，CPU 运行于实模式工作环境中，数据位宽为 16 位，最大物理地址寻址范围是 01 MB，其中的物理地址 0x0C00000x0FFFFF 保留给 BIOS 使用。开机后， CPU 首先跳转到物理地址 0x0FFFF0 处执行程序。一般情况下，这里是一条跳转指令， CPU 通过执行此处的跳转指令跳转到真正的 BIOS 入口地址处执行：\nBIOS代码首先做的是 POST（Power On Self Test，加电自检）操作，主要是检测关键设备是否正常工作，设备设置是否与CMOS中的设置一致。如果发现硬件错误，则通过喇叭报警 初始化显示设备并显示显卡信息，接着初始化其他设备 检测CPU和内存并显示检测结果 检测标准设备，例如硬盘、光驱、串口设备、并口设备等 检测即插即用设备，并为这些设备分配中断号、 I/O 端口和 DMA 通道等资源 如果硬件配置发生变化，那么这些变化的配置将更新到 CMOS 中 根据配置的启动顺序引导设备启动，通过BIOS中断将设备的引导程序入内存 将处理器的控制权交给引导程序，最终引导进入操作系统 UEFI ，启动！ 验证阶段（Security，SEC）。系统上电后，CPU 开始执行第一条指令，此时系统就进入 SEC 阶段。这个阶段的内存尚未被初始化，不可使用。所以， SEC 阶段最主要的工作是建立一些临时内存并将 CPU 切换到保护模式，这里提到的临时内存可以是处理器的缓存，亦或者系统的物理内存。 EFI 环境预初始化阶段（Pre-EFI Initialization Environment，PEI）。PEI 阶段最主要的工作就是对内存、CPU 以及芯片组等关键设备进行初始化。由于这部分代码没有进行压缩，因此代码必须越精简越好。而且，在PEI阶段还要确定操作系统的引导路径，初始化 UEFI 驱动和固件需要的内存。 驱动运行环境阶段（Driver Execution Environment，DXE）。DXE 是 EFI 最重要的阶段，大部分的驱动、固件加载工作都是在这个阶段完成的。 引导设备选择阶段（Boot Device Select，BDS）。BDS 阶段的主要工作是初始化控制台设备的环境变量，尝试加载环境变量列表中记录的驱动，并尝试从环境变量列表中记录的启动设备中启动。 临时系统运行阶段（Transient System Load，TSL）。这个阶段将进入 UEFI 的临时 Shell 系统环境。 运行时阶段（RunTime，RT）。当操作系统调用 EFI_BOOT_SERVICES.ExitBootServices 服务后，系统进入 RT 阶段。此时，DXE 与引导服务都将销毁，只有 EFI 运行时服务和 EFI 系统表可以继续使用。 后世阶段（After Life，AL）。当操作系统调用 EFI_RUNTIME_SERVICES.ResetSystem 服务或者调用 ACPI SleepState，系统进入 AL 阶段。触发异步事件（比如：SMI、NMI）亦可使系统进入 AL 阶段，这在服务器和工作站中比较常见。 BIOS 的缺点 \u0026amp; UEFI 的优点 正如 systemd 取代 init.d 的原因之一，BIOS 不支持异步工作模式，只能使用中断来实现各种服务；而 UEFI 可以舍弃中断这种比较耗时的操作外部设备的方式，仅仅保留了时钟中断。外部设备的操作采用“事件+异步操作”完成。 功能拓展性与拓展性：BIOS 代码采用静态链接，增加硬件功能时，必须将 16 位代码放置在 0x0C0000~0x0DFFFF 区间，初始化时将其设置为约定的中断处理程序。而且 BIOS 没有提供动态加载设备驱动的方案。而 UEFI 系统的可扩展性体现在两个方面：一是驱动的模块化设计；二是软硬件升级的兼容性。大部分硬件的初始化通过 UEFI 驱动实现。每个驱动是一个独立的模块，可以包含在固件中，也可以放在设备上，运行时根据需要动态加载。UEFI 中的每个表和协议（包括驱动）都有版本号，这使得系统升级过程更加简单、平滑。 BIOS 不支持从硬盘 2TB 以上的地址空间引导：受限于 BIOS 硬盘的寻址方式，BIOS 硬盘采用 32 位地址，因而引导扇区的最大逻辑块地址是 2^32（换算成字节地址，即 2^32×512B=2TB） MBR vs GPT Legacy MBR（Master Boot Record）是为 BIOS 引导方式设计的磁盘引导扇区结构，其绝大部分功能结构都保存在磁盘的引导扇区。而 GPT（GUID Partition table）却是区别于 legacy MBR 磁盘布局的一种全新布局，它专为 UEFI 固件使用：\n64 位的LBA（Logical Block Address）磁盘扇区寻址，而不是 32 位 支持更多分区，而不仅仅是四个主分区 为主分区表提供冗余的备份分区表 使用版本号和大小字段为将来做扩展 使用 CRC32 字段改进数据完整性 定义用于唯一标识每个分区的 GUID 使用 GUID 和属性定义分区类型 每个分区包含一个 36 字符的人类可读名称 为了兼容 legacy MBR 磁盘布局，GPT 仍使用 legacy MBR 的引导扇区结构，但 UEFI 固件不会执行 MBR 上的启动代码。GPT 为了与 legacy MBR 的引导扇区结构相区分特将引导扇区结构命名为 Protective MBR（PMBR），并使用 GPT 伪分区模拟 MBR 分区表。\nGPT 的 Protective MBR 引导扇区结构只使用一个分区记录表项，这个分区将占用 Protective MBR 之后的整个磁盘空间，剩余三个表项保留使用并填充 0 。\n可以看到备份分区表的顺序是相反的，这也非常符合我们对这种记录结构的直觉\nGUID 描述 GUID值 未使用 00000000-0000-0000-0000-000000000000 EFI System Partition C12A7328-F81F-11D2-BA4B-00A0C93EC93B Partition Containing a legacy MBR 024DEE41-33E7-11D3-9D69-0008C781F39F FAT12/16/32/NTFS EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 EXT4 0FC63DAF-8483-4772-8E79-3D69D8477DE4 区别于分区的 UUID 。这个 GUID 用于标识分区的内容，类似于MBR中的 OSType 字段。每个文件系统都必须发布其唯一的 GUID 。\nESP \u0026amp; FAT \u0026amp; PE UEFI 的 ESP 文件系统是指 UEFI 系统分区（EFI System Partition）上的文件系统，它是一个使用 FAT32 格式化的小分区，通常为 100MB，其中存储了已安装系统的 UEFI 引导加载程序以及启动时固件使用的应用程序。UEFI 固件在启动时会加载 ESP 分区上的 .efi 文件，开始加载操作系统。\nUEFI 不能运行 ELF 格式的可执行程序，只能运行 PE 格式的。使用 objcopy 处理生成的二进制文件，将其格式改变为 PE+ ，或者使用交叉编译的方式，将 target 设置为 x86_64-unknown-uefi 或 aarch64-unknown-uefi 。\n# file /boot/EFI/GRUB/grubx64.efi /boot/EFI/GRUB/grubx64.efi: PE32+ executable (EFI application) x86-64 (stripped to external PDB), for MS Windows, 4 sections Linux ，启动！ 不管接口或者规范如何变化，计算机的启动一般都会是三个步骤：\nCAR(Cache As RAM) ，这个阶段连内存都用不了 能执行汇编语言 设置堆栈环境，这时能执行 C 等高级语言 这里主要介绍在 BootLoader 阶段完成的工作。\nGRUB ，启动！ grub 是一款不断扩充功能直到最后历史包袱积重难返的软件，因此它的启动过程比较复杂。\nStage 1：执行GRUB主程序。第一阶段是用来执行 GRUB 主程序的，这个主程序必须放在启动区中（也就是 MBR 或者引导扇区中）。但是 MBR 太小了，所以只能安装 GRUB 的最小的主程序，而不能安装 GRUB 的相关配置文件。这个主程序主要是用来启动 Stage 1.5 和 Stage 2 的。\nStage 1.5：识别不同的文件系统。Stage 2 比较大，只能放在文件系统中（分区），但是 Stage 1 不能识别不同的文件系统，所以不能直接加载 Stage 2。这时需要先加载 Stage 1.5，由 Stage 1.5 来加载不同文件系统中的 Stage 2。\n还有一个问题，难道 Stage 1.5 不是放在文件系统中的吗？如果是，那么 Stage 1 同样不能找到 Stage 1.5。其实，Stage 1.5 还真没有放在文件系统中，而是在安装 GRUB 时，直接安装到紧跟 MBR 之后的 32KB 的空间中，这段硬盘空间是空白无用的，而且是没有文件系统的，所以 Stage 1 可以直接读取 Stage 1.5。读取了 Stage 1.5 就能识别不同的文件系统，才能加载 Stage 2。\nStage 2：加载GRUB的配置文件。Stage 2 阶段主要就是加载 GRUB 的配置文件 /boot/grub/grub.conf，然后根据配置文件中的定义，加载内核和虚拟文件系统。接下来内核就可以接管启动过程，继续自检与加载硬件模块了。 GRUB2 ，启动！ grub2 是 grub 的重写版本，启动过程更简单明了。grub2 将 boot.img 转换后的内容安装到 MBR(VBR或EBR) 中的 boot loader 部分，将 diskboot.img 和 kernel.img 结合成为 core.img，同时还会嵌入一些模块或加载模块的代码到 core.img 中，然后将 core.img 转换后的内容安装到磁盘的指定位置处。\ngrub2 的 core 阶段相当于 grub 的 stage1.5 和 stage2 的结合，它可以直接加载不同的文件系统和模块，而不需要额外的驱动程序。\ncore 阶段通常存储在一个专门的 UEFI 分区或者 /boot/grub 目录中。\nStage 1：第一阶段为执行 boot loader 的主程序，这个主程序必须要被安装在引导区，也就是是 MBR 或者启动扇区。但因为 MBR 空间有限，所以，MBR 或启动扇区通常仅安装 boot loader 的最小主程序，并没有安装 loader 的相关配置文件。\nStage 2：第二阶段通过 boot loader 加载所有配置文件与相关的环境参数文件（包括文件系统定义与主要配置文件 grub.cfg），通常配置文件都在 /boot 目录下。\n# ls /boot EFI grub initramfs-linux-fallback.img initramfs-linux.img vmlinuz-linux # file vmlinuz-linux vmlinuz-linux: Linux kernel x86 boot executable bzImage, version 6.4.12-arch1-1 (linux@archlinux) #1 SMP PREEMPT_DYNAMIC Thu, 24 Aug 2023 00:38:14 +0000, RO-rootFS, swap_dev 0XC, Normal VGA # tree EFI EFI └── GRUB └── grubx64.efi 2 directories, 1 file # tree grub grub ├── fonts │ └── unicode.pf2 ├── grub.cfg ├── grubenv ├── locale │ ├── ast.mo │ ├── ca.mo │ ├── da.mo │ ├── de_CH.mo │ ├── de@hebrew.mo ...... .mo 文件都是供 grub 加载的模块，包含了对字体、图像、USB 设备等。而 initramfs-linux.img 是一个初始内存文件系统，它是一个压缩的归档文件，包含了一些必要的程序和驱动，用于在启动过程中加载根文件系统。vmlinuz-linux 是一个 Linux 内核镜像，它是一个可执行的二进制文件，用于在 UEFI 启动模式下被固件直接加载。这两个文件通常位于 /boot 目录下，是 Linux 系统启动的重要组成部分。\ninitramfs 的目的在于提供启动过程中所需要的最重要内核模块，以让系统启动过程可以顺利完成。需要 initramfs 的原因，是因为内核模块放置于 /lib/modules/$(uname -r)/kernel/ 当中， 这些模块必须要根目录被挂载时才能够被读取。但是如果内核本身不具备磁盘的驱动程序时， 就无法挂载根目录，也就没有办法获取到驱动程序，造成无法启动\ninitramfs 可以将 /lib/modules/ 内的启动过程中必需的模块打包到 initramfs 中，然后在启动时，通过主机的 INT 13 硬件功能将该文件读出来解压缩，并且 initramfs 在内存内会模拟成为根目录， 由于此虚拟文件系统主要包含磁盘与文件系统的模块，因此内核最后就能够识别实际的磁盘，然后就能够进行实际根目录的挂载，因此，initramfs 内所包含的模块大多是与启动过程有关，且主要以文件系统及硬盘模块 (如 usb, SCSI 等) 为主的\n通常在以下情况下需要 initramfs：\n根目录所在磁盘为 SATA、USB 或 SCSI 等接口 根目录所在文件系统为 LVM, RAID 等特殊格式 根目录所在文件系统为非传统 Linux 识别的文件系统 其他必须要在内核加载时提供的模块 在发行版更新内核时，一般都会执行一个钩子函数，重新生成这些重要部件：\n:: Running post-transaction hooks... (1/7) Reloading system manager configuration... (2/7) Reloading device manager configuration... (3/7) Arming ConditionNeedsUpdate... (4/7) Updating module dependencies... (5/7) Install DKMS modules ==\u0026gt; dkms install --no-depmod v4l2loopback/0.12.7 -k 6.5.2-arch1-1 ==\u0026gt; depmod 6.5.2-arch1-1 (6/7) Updating linux initcpios... ==\u0026gt; Building image from preset: /etc/mkinitcpio.d/linux.preset: \u0026#39;default\u0026#39; ==\u0026gt; Using default configuration file: \u0026#39;/etc/mkinitcpio.conf\u0026#39; -\u0026gt; -k /boot/vmlinuz-linux -g /boot/initramfs-linux.img --microcode /boot/*-ucode.img ==\u0026gt; Starting build: \u0026#39;6.5.2-arch1-1\u0026#39; -\u0026gt; Running build hook: [base] -\u0026gt; Running build hook: [udev] -\u0026gt; Running build hook: [autodetect] -\u0026gt; Running build hook: [modconf] -\u0026gt; Running build hook: [kms] -\u0026gt; Running build hook: [keyboard] ==\u0026gt; WARNING: Possibly missing firmware for module: \u0026#39;xhci_pci\u0026#39; -\u0026gt; Running build hook: [keymap] -\u0026gt; Running build hook: [consolefont] ==\u0026gt; WARNING: consolefont: no font found in configuration -\u0026gt; Running build hook: [block] -\u0026gt; Running build hook: [filesystems] -\u0026gt; Running build hook: [fsck] ==\u0026gt; Generating module dependencies ==\u0026gt; Creating zstd-compressed initcpio image: \u0026#39;/boot/initramfs-linux.img\u0026#39; ==\u0026gt; Image generation successful ==\u0026gt; Building image from preset: /etc/mkinitcpio.d/linux.preset: \u0026#39;fallback\u0026#39; ==\u0026gt; Using default configuration file: \u0026#39;/etc/mkinitcpio.conf\u0026#39; -\u0026gt; -k /boot/vmlinuz-linux -g /boot/initramfs-linux-fallback.img -S autodetect --microcode /boot/*-ucode.img ==\u0026gt; Starting build: \u0026#39;6.5.2-arch1-1\u0026#39; -\u0026gt; Running build hook: [base] -\u0026gt; Running build hook: [udev] -\u0026gt; Running build hook: [modconf] -\u0026gt; Running build hook: [kms] ==\u0026gt; WARNING: Possibly missing firmware for module: \u0026#39;ast\u0026#39; -\u0026gt; Running build hook: [keyboard] ==\u0026gt; WARNING: Possibly missing firmware for module: \u0026#39;xhci_pci\u0026#39; -\u0026gt; Running build hook: [keymap] -\u0026gt; Running build hook: [consolefont] ==\u0026gt; WARNING: consolefont: no font found in configuration -\u0026gt; Running build hook: [block] ==\u0026gt; WARNING: Possibly missing firmware for module: \u0026#39;aic94xx\u0026#39; ==\u0026gt; WARNING: Possibly missing firmware for module: \u0026#39;bfa\u0026#39; ==\u0026gt; WARNING: Possibly missing firmware for module: \u0026#39;qed\u0026#39; ==\u0026gt; WARNING: Possibly missing firmware for module: \u0026#39;qla1280\u0026#39; ==\u0026gt; WARNING: Possibly missing firmware for module: \u0026#39;qla2xxx\u0026#39; ==\u0026gt; WARNING: Possibly missing firmware for module: \u0026#39;wd719x\u0026#39; -\u0026gt; Running build hook: [filesystems] -\u0026gt; Running build hook: [fsck] ==\u0026gt; Generating module dependencies ==\u0026gt; Creating zstd-compressed initcpio image: \u0026#39;/boot/initramfs-linux-fallback.img\u0026#39; ==\u0026gt; Image generation successful (7/7) Reloading system bus configuration... total 0h 5m 21s 参考资料 一个 UEFi 引导程序的实现 GRUB legacy document GRUB2 document Linux启动流程（二）：grub2 计算机是如何启动的？从未上电到操作系统启动 ","permalink":"https://vaaandark.top/posts/linux-startup/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u0026ldquo;pull oneself up by one\u0026rsquo;s bootstraps.\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e拽着鞋带把自己拉起来\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e大家在安装 Arch Linux 或者其他 Linux 发行版时，可能会看到很多有关启动或者引导的名词，例如 BIOS 、UEFI 、GRUB 、ESP 、GPT 、LBA 、MBR 等等。有些名词比较熟悉，有些就会一头雾水，今天就来讲讲这些名词。\u003c/p\u003e","title":"Linux ，启动！"},{"content":"8 月 13 日开始记账，开始时剩余 2392.87 元。截至 12.29 日，剩余 864.77 元。\n去除尚未到账的学院报销，2023 年秋季学期实际支出 801.10 元。\n备注 中操西操纯净水 1 元一瓶，整箱购买中操有优惠 22 元，西操没有优惠 24 元，直接购买超市矿泉水一件 48 元。 购买训练道具 728 元，学院尚未报销。 账单 日期 收入 / 支出 用途 剩余 备注 2023.08.29 -24.00 与新生训练赛买水 2368.87 无 2023.08.31 -36.00 与新生训练赛买水 2332.87 无 2023.09.01 -22.00 新生野球买水 2310.87 无 2023.09.02 -22.00 训练买水 2288.87 无 2023.09.09 -43.20 与网安院队友谊赛买水 2245.67 农夫山泉 1.8/瓶 2023.09.16 -43.20 新生队与集成新生队友谊赛买水 2202.47 农夫山泉 1.8/瓶 2023.09.16 -200.00 新生杯保证金 2002.47 之后会根据红黄牌情况退还 2023.09.17 -78.00 新生杯第一场保险 1924.47 无 2023.09.18 -33.00 新生杯第一场买水 1891.47 半箱冰露和四瓶佳得乐 2023.09.24 -22.00 与集成院队友谊赛买水 1869.47 无 2023.09.25 -48.00 新生杯第二场买水 1821.47 无 2023.10.07 -48.00 新生杯第三场保险 1773.47 无 2023.10.07 -45.00 新生杯第三场买水 1728.47 无 2023.10.15 -48.00 与软件院队友谊赛买水 1680.47 两箱矿泉水 2023.10.17 -24.00 训练买水 1656.47 无 2023.10.21 -22.00 与数学院队友谊赛买水 1634.47 无 2023.10.24 +170.00 新生杯保证金退还 1804.47 无 2023.10.24 -728.00 购买训练道具 1076.47 等待学院报销 2023.10.31 -22.00 训练买水 1054.47 无 2023.11.06 -22.00 训练买水 1032.47 无 2023.11.14 -2.00 冰袋 1030.47 无 2023.11.22 -12.00 训练买水 1018.47 半箱 2023.11.26 -48.00 与管理院队友谊赛买水 970.47 两箱 2023.11.28 -24.00 训练买水 946.47 无 2023.12.10 -37.70 与光电院队友谊赛买水和冰敷 898.77 无 2023.12.17 -22.00 与网安院队友谊赛买水 876.77 无 2023.12.26 -12.00 训练买水 864.77 半箱 2023.03.03 -22.00 训练买水 842.77 无 2023.03.05 -22.00 训练买水 820.77 无 2023.03.09 -24.00 训练买水 796.77 无 2023.03.10 -40.08 与软件院队友谊赛买水 756.69 无 2023.03.12 -24.00 训练买水 732.69 无 2023.03.20 -24.00 训练买水 708.69 无 2023.03.21 -48.00 华工杯(vs网安)买水 660.69 无 2023.03.24 -22.00 训练买水 638.69 无 2023.03.31 -47.00 华工杯(vs船海)买水 591.69 包含五瓶佳得乐 2023.04.06 -22.00 华工杯(vs生科)买水 569.69 无 2023.04.13 -22.00 华工杯(vs集成)买水 547.69 无 2023.04.17 -47.00 华工杯(vs建规)买水 500.69 包含五瓶佳得乐 2023.04.20 -22.00 华工杯(vs建规)买水 478.69 无 ","permalink":"https://vaaandark.top/posts/football-team-bill/","summary":"\u003cp\u003e8 月 13 日开始记账，开始时剩余 2392.87 元。截至 12.29 日，剩余 864.77 元。\u003c/p\u003e\n\u003cp\u003e去除尚未到账的学院报销，2023 年秋季学期实际支出 801.10 元。\u003c/p\u003e\n\u003ch2 id=\"备注\"\u003e备注\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e中操西操纯净水 1 元一瓶，整箱购买中操有优惠 22 元，西操没有优惠 24 元，直接购买超市矿泉水一件 48 元。\u003c/li\u003e\n\u003cli\u003e购买训练道具 728 元，学院尚未报销。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"账单\"\u003e账单\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e日期\u003c/th\u003e\n          \u003cth\u003e收入 / 支出\u003c/th\u003e\n          \u003cth\u003e用途\u003c/th\u003e\n          \u003cth\u003e剩余\u003c/th\u003e\n          \u003cth\u003e备注\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.08.29\u003c/td\u003e\n          \u003ctd\u003e-24.00\u003c/td\u003e\n          \u003ctd\u003e与新生训练赛买水\u003c/td\u003e\n          \u003ctd\u003e2368.87\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.08.31\u003c/td\u003e\n          \u003ctd\u003e-36.00\u003c/td\u003e\n          \u003ctd\u003e与新生训练赛买水\u003c/td\u003e\n          \u003ctd\u003e2332.87\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.09.01\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e新生野球买水\u003c/td\u003e\n          \u003ctd\u003e2310.87\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.09.02\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e2288.87\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.09.09\u003c/td\u003e\n          \u003ctd\u003e-43.20\u003c/td\u003e\n          \u003ctd\u003e与网安院队友谊赛买水\u003c/td\u003e\n          \u003ctd\u003e2245.67\u003c/td\u003e\n          \u003ctd\u003e农夫山泉 1.8/瓶\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.09.16\u003c/td\u003e\n          \u003ctd\u003e-43.20\u003c/td\u003e\n          \u003ctd\u003e新生队与集成新生队友谊赛买水\u003c/td\u003e\n          \u003ctd\u003e2202.47\u003c/td\u003e\n          \u003ctd\u003e农夫山泉 1.8/瓶\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.09.16\u003c/td\u003e\n          \u003ctd\u003e-200.00\u003c/td\u003e\n          \u003ctd\u003e新生杯保证金\u003c/td\u003e\n          \u003ctd\u003e2002.47\u003c/td\u003e\n          \u003ctd\u003e之后会根据红黄牌情况退还\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.09.17\u003c/td\u003e\n          \u003ctd\u003e-78.00\u003c/td\u003e\n          \u003ctd\u003e新生杯第一场保险\u003c/td\u003e\n          \u003ctd\u003e1924.47\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.09.18\u003c/td\u003e\n          \u003ctd\u003e-33.00\u003c/td\u003e\n          \u003ctd\u003e新生杯第一场买水\u003c/td\u003e\n          \u003ctd\u003e1891.47\u003c/td\u003e\n          \u003ctd\u003e半箱冰露和四瓶佳得乐\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.09.24\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e与集成院队友谊赛买水\u003c/td\u003e\n          \u003ctd\u003e1869.47\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.09.25\u003c/td\u003e\n          \u003ctd\u003e-48.00\u003c/td\u003e\n          \u003ctd\u003e新生杯第二场买水\u003c/td\u003e\n          \u003ctd\u003e1821.47\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.10.07\u003c/td\u003e\n          \u003ctd\u003e-48.00\u003c/td\u003e\n          \u003ctd\u003e新生杯第三场保险\u003c/td\u003e\n          \u003ctd\u003e1773.47\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.10.07\u003c/td\u003e\n          \u003ctd\u003e-45.00\u003c/td\u003e\n          \u003ctd\u003e新生杯第三场买水\u003c/td\u003e\n          \u003ctd\u003e1728.47\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.10.15\u003c/td\u003e\n          \u003ctd\u003e-48.00\u003c/td\u003e\n          \u003ctd\u003e与软件院队友谊赛买水\u003c/td\u003e\n          \u003ctd\u003e1680.47\u003c/td\u003e\n          \u003ctd\u003e两箱矿泉水\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.10.17\u003c/td\u003e\n          \u003ctd\u003e-24.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e1656.47\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.10.21\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e与数学院队友谊赛买水\u003c/td\u003e\n          \u003ctd\u003e1634.47\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.10.24\u003c/td\u003e\n          \u003ctd\u003e+170.00\u003c/td\u003e\n          \u003ctd\u003e新生杯保证金退还\u003c/td\u003e\n          \u003ctd\u003e1804.47\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.10.24\u003c/td\u003e\n          \u003ctd\u003e-728.00\u003c/td\u003e\n          \u003ctd\u003e购买训练道具\u003c/td\u003e\n          \u003ctd\u003e1076.47\u003c/td\u003e\n          \u003ctd\u003e等待学院报销\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.10.31\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e1054.47\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.11.06\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e1032.47\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.11.14\u003c/td\u003e\n          \u003ctd\u003e-2.00\u003c/td\u003e\n          \u003ctd\u003e冰袋\u003c/td\u003e\n          \u003ctd\u003e1030.47\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.11.22\u003c/td\u003e\n          \u003ctd\u003e-12.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e1018.47\u003c/td\u003e\n          \u003ctd\u003e半箱\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.11.26\u003c/td\u003e\n          \u003ctd\u003e-48.00\u003c/td\u003e\n          \u003ctd\u003e与管理院队友谊赛买水\u003c/td\u003e\n          \u003ctd\u003e970.47\u003c/td\u003e\n          \u003ctd\u003e两箱\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.11.28\u003c/td\u003e\n          \u003ctd\u003e-24.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e946.47\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.12.10\u003c/td\u003e\n          \u003ctd\u003e-37.70\u003c/td\u003e\n          \u003ctd\u003e与光电院队友谊赛买水和冰敷\u003c/td\u003e\n          \u003ctd\u003e898.77\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.12.17\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e与网安院队友谊赛买水\u003c/td\u003e\n          \u003ctd\u003e876.77\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.12.26\u003c/td\u003e\n          \u003ctd\u003e-12.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e864.77\u003c/td\u003e\n          \u003ctd\u003e半箱\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.03.03\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e842.77\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.03.05\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e820.77\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.03.09\u003c/td\u003e\n          \u003ctd\u003e-24.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e796.77\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.03.10\u003c/td\u003e\n          \u003ctd\u003e-40.08\u003c/td\u003e\n          \u003ctd\u003e与软件院队友谊赛买水\u003c/td\u003e\n          \u003ctd\u003e756.69\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.03.12\u003c/td\u003e\n          \u003ctd\u003e-24.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e732.69\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.03.20\u003c/td\u003e\n          \u003ctd\u003e-24.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e708.69\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.03.21\u003c/td\u003e\n          \u003ctd\u003e-48.00\u003c/td\u003e\n          \u003ctd\u003e华工杯(vs网安)买水\u003c/td\u003e\n          \u003ctd\u003e660.69\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.03.24\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e训练买水\u003c/td\u003e\n          \u003ctd\u003e638.69\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.03.31\u003c/td\u003e\n          \u003ctd\u003e-47.00\u003c/td\u003e\n          \u003ctd\u003e华工杯(vs船海)买水\u003c/td\u003e\n          \u003ctd\u003e591.69\u003c/td\u003e\n          \u003ctd\u003e包含五瓶佳得乐\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.04.06\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e华工杯(vs生科)买水\u003c/td\u003e\n          \u003ctd\u003e569.69\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.04.13\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e华工杯(vs集成)买水\u003c/td\u003e\n          \u003ctd\u003e547.69\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.04.17\u003c/td\u003e\n          \u003ctd\u003e-47.00\u003c/td\u003e\n          \u003ctd\u003e华工杯(vs建规)买水\u003c/td\u003e\n          \u003ctd\u003e500.69\u003c/td\u003e\n          \u003ctd\u003e包含五瓶佳得乐\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.04.20\u003c/td\u003e\n          \u003ctd\u003e-22.00\u003c/td\u003e\n          \u003ctd\u003e华工杯(vs建规)买水\u003c/td\u003e\n          \u003ctd\u003e478.69\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"足球队账单"},{"content":"7.6 举办了 PAC2023 的开幕赛，以轻松娱乐为主，我还没有体验过在短时间内完成优化工作（不过今天的工作量倒也不大）。这场娱乐赛给了我别样的体验，也让我发现了我有好的好多不足，以及一些以前没有注意到的坏习惯。\n赛题介绍 赛题是针对一个朴素实现的康威生命游戏的优化。由于代码写得很朴素，所以比较轻松地就可以达到比较好看的加速比。\n代码的核心部分如下：\nfor (int iter = 0; iter \u0026lt; max_iter; ++iter) { printf(\u0026#34;Iter %d...\\n\u0026#34;, iter); for (int i = 1; i \u0026lt; Ny - 1; ++i) { for (int j = 1; j \u0026lt; Nx - 1; ++j) { int cnt = 0; for (int k = 0; k \u0026lt; 8; ++k) { int ii = i + dy[k]; int jj = j + dx[k]; if (a[ii][jj] == 1) { cnt++; } } if (a[i][j] == 1) { if (cnt == 2 || cnt == 3) { tmp[i][j] = 1; } else { tmp[i][j] = 0; } } else { // a[i][j] == 0 if (cnt == 3) { tmp[i][j] = 1; } else { tmp[i][j] = 0; } } } } for (int i = 0; i \u0026lt; Ny; ++i) { for (int j = 0; j \u0026lt; Nx; ++j) { a[i][j] = tmp[i][j]; } } 代码分析 可以看到生命游戏一共要进行 1000 次迭代，每次都遍历一遍整个地图，对每个点都计算一下邻居的个数，再根据生命游戏的 B3/S23 规则决定下一次迭代时的状态。\nB3/S23 规则是对生命游戏规则的概括缩写\n这个朴素写法非常的暴力，不仅是直接访问每个点周围的八个点，而且还使用了 tmp 数组暂存元素，最后将 tmp 复制到地图数组 a 中，开销不可谓不大。\n在本地的 64 核心集群上运行 baseline ，运行时间为 741335.164000 ms\n在北京超级云计算中心上运行 baseline ，运行时间为 634306.056000 ms\n优化策略 算法微调 \u0026amp;\u0026amp; 访存优化 首先我想到的是对算法进行微调，将之前的对每个点求邻居个数改为，将每行与上下两行进行叠加，这样每个元素就是三个点和。这就把对一个「九宫格」的计算改成了两次对三个元素的加和。这样并不能减少计算量，但是能减少访存上的开销。\n这样做的目的还有简化代码逻辑，方便编译器生成 SIMD 指令\n在一番取舍之后没有使用前缀和算法来，这是因为担心在改变数据类型后，数据类型不够宽，无法存放前缀和。\n其实这是后话，后面把 int 改成了 uint8_t\n核心代码改成：\nfor (int iter = 0; iter \u0026lt; max_iter; ++iter) { printf(\u0026#34;Iter %d...\\n\u0026#34;, iter); memcpy(sum, a, Nx * Ny * sizeof(int)); for (int i = 1; i \u0026lt; Ny - 1; ++i) { for (int j = 0; j \u0026lt; Nx - 1; ++j) { sum[i][j] += a[i + 1][j]; } } for (int i = 1; i \u0026lt; Ny - 1; ++i) { for (int j = 0; j \u0026lt; Nx; ++j) { sum[i][j] += a[i - 1][j]; } } for (int i = 1; i \u0026lt; Ny - 1; ++i) { for (int j = 1; j \u0026lt; Nx - 1; ++j) { int neighbors = sum[i][j] + sum[i][j - 1] + sum[i][j + 1] - a[i][j]; if (neighbors == 3) { tmp[i][j] = 1; } else if (neighbors \u0026lt; 2 || neighbors \u0026gt; 3) { tmp[i][j] = 0; } else { tmp[i][j] = a[i][j]; } } } memcpy(a, tmp, Nx * Ny * sizeof(int)); 在本地的 64 核心集群上运行时间为 293731.276000 ms\n在北京超级云计算中心上运行时间为 260813.238000 ms ，加速比约为 2.4x 。\nopenmp \u0026amp;\u0026amp; 合并循环 之后就是最喜欢的「openmp，启动！」环节了。openmp 相对其他的并行框架来说非常好用，无脑推荐。\n在敲代码时又突然发现叠加的两个循环其实可以合并，这下傻逼了。\n所以核心代码变成了：\nprintf(\u0026#34;Iter %d...\\n\u0026#34;, iter); memcpy(sum, a, Nx * Ny * sizeof(int)); #pragma omp parallel for for (int i = 1; i \u0026lt; Ny - 1; ++i) { for (int j = 0; j \u0026lt; Nx - 1; ++j) { sum[i][j] += a[i + 1][j]; sum[i][j] += a[i - 1][j]; } } #pragma omp parallel for ... 在本地的 64 核心集群上运行时间为 18918.941000 ms\n在北京超级云计算中心上运行时间为 18864.766000 ms ，加速比约为 33x 。\nO3 \u0026amp;\u0026amp; SIMD 之前使用的编译参数都是 -O0 现在改成 -O3 ，大量的整数运算操作可以向量化。\n在本地的 64 核心集群上运行时间为 10292.194000 ms\n在北京超级云计算中心上运行时间为 15419.145000 ms ，加速比约为 41x 。\n这里就可以看到本地集群和云计算中心集群机器性能的差别，本地集群单核性能弱于计算中心（体现在 baseline 本地跑了更久），但是计算中心的核心少于本地，因此使用 openmp 的情况下本地加速更明显。\n改变数据类型 由于在九宫格中的计算结果在 0-9 之间，因此不需要很宽的数据类型来存储，而且也不需要考虑负数，因此我使用了 uint8_t 类型来替换 int ，这样操作之后加速比又提高了不少。\n在本地的 64 核心集群上运行时间为 3004.615000 ms\n在北京超级云计算中心上运行时间为 3858.775000 ms ，加速比约为 164x 。\n去掉不必要的拷贝 最后再看看自己的代码，发现很多细节还可以处理。例如数据的拷贝，为了计算与相邻两行的和，我新增了一个数组，由于这个数组可以存储中间过程，我可以去掉 tmp 数组，直接对 a 数组进行操作，这样减少了 memcpy 的开销。\n小插曲：baseline 对边缘的处理非常差，导致第一次迭代(iter=0)时需要将 a 数组的边缘全部置为 0\n还有就是在一开始将 a 数组拷贝到 sum 数组，这个其实也可以带到第一次的循环中进行，这对访存没有什么副作用，而且可以并行执行。\n最后的代码：\nfor (int iter = 0; iter \u0026lt; max_iter; ++iter) { #pragma omp parallel for proc_bind(spread) for (int i = 0; i \u0026lt; Ny - 1; ++i) { for (int j = 0; j \u0026lt; Nx - 1; ++j) { sum[i][j] = 0; sum[i][j] += a[i + 1][j]; sum[i][j] += a[i][j]; sum[i][j] += a[i - 1][j]; } } #pragma omp parallel for proc_bind(spread) for (int i = 1; i \u0026lt; Ny - 1; ++i) { for (int j = 1; j \u0026lt; Nx - 1; ++j) { int neighbors = sum[i][j] + sum[i][j - 1] + sum[i][j + 1] - a[i][j]; if (neighbors == 3) { a[i][j] = 1; } else if (neighbors \u0026lt; 2 || neighbors \u0026gt; 3) { a[i][j] = 0; } } } if (iter == 0) { memset(a[0], 0, sizeof(a[0])); memset(a[Ny - 1], 0, sizeof(a[Ny - 1])); for (int i = 0; i \u0026lt; Ny; ++i) { a[i][Nx - 1] = 0; a[i][0] = 0; } } 在本地的 64 核心集群上运行时间为 247.119000 ms\n本地由于单核弱而核数多，跑到 3000x 没什么鸟用，不具备参考价值😭\n在北京超级云计算中心上运行时间为 318.769000 ms ，加速比约为 1990x 。\n总结 之前打高性能比赛都是组队参加，总是需要大佬的指导和安排任务，这次个人赛暴露了很多不足，完全没有发挥出机器的全部性能。\n不过往好处想，整体的优化思路是短时间内就想出来了的，都怪愚蠢的 baseline ，我花了很多时间在解决正确性的问题。\n这次比赛没有机会尝试使用 MPI ，有时间的话用 MPI 继续做做这道题。\n","permalink":"https://vaaandark.top/posts/pac2023-game/","summary":"\u003cp\u003e7.6 举办了 PAC2023 的开幕赛，以轻松娱乐为主，我还没有体验过在短时间内完成优化工作（不过今天的工作量倒也不大）。这场娱乐赛给了我别样的体验，也让我发现了我有好的好多不足，以及一些以前没有注意到的坏习惯。\u003c/p\u003e","title":"PAC2023娱乐赛"},{"content":"关系代数 关系代数（数据库）\n计算机科学家 Codd 对关系代数的形成作出了很大的贡献，他的代数的六个原始运算是「选择」、「投影」、「笛卡尔积」、「并集」、「差集」、「重命名」。\nSelect 相当于 sql 中 where 的功能。\n一般形式：\n$$ \\sigma_{verb}(relationship) $$\n选择谓词一般是逻辑表达式，可以是连词连接（也可以没有连词）的多个比较语句。\nProjection 相当于 sql 中 select 的功能。\n一般形式：\n$$ \\Pi_{fields}(relationship) $$\n从关系中选出若干属性列组成新的关系，在这种选择过程中可能会减少一些列（没有被选中或者出现了重复）。\nJoin 连接可以分为自然连接、等值连接、外连接等。\n等值连接，从关系 R 和 S 的广义笛卡尔积中选取 A 、B 属性值相等的那些元组，一般形式：\n$$ R\\bowtie_{A=B}S $$\n自然连接， 连接时两个关系中比较的分量必须是同名的属性组，并在结果中把重复的属性列去掉。一般形式：\n$$ R\\bowtie{S} $$\n自然连接时会出现 R 中的某些元组在 S 中不存在公共属性上值相等的元组，所以出现了「悬浮元组」，如果保留它们，未知的属性填上 NULL ，这就是「外连接」。如果只保留左边关系中的悬浮元组就是「左外连接」，反之就是「右外连接」。\nDivsion 其结果由 R 中元组到唯一于 R 的属性名字（就是说只在 R 表头中而不在 S 表头中的属性）的限制构成，并且它们与 S 中的元组的所有组合都存在于 R 中。一般形式：\n$$ R\\div{S} $$\nRename 一般形式：\n$$ \\rho_{a/b}(R) $$\n把所有元组中的 b 字段改成 a 字段。相当于 sql 中的 as 。\nPS:\n关系的完整性：\n实体完整性（主码不能为空） 参照完整性（外码要么为空要么存在于参照关系中） 用户定义完整性（要遵照用户的定义，例如人数不能为小数等） ","permalink":"https://vaaandark.top/posts/review-for-database-on-relation-algebra/","summary":"\u003ch1 id=\"关系代数\"\u003e关系代数\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0_(%E6%95%B0%E6%8D%AE%E5%BA%93)\"\u003e关系代数（数据库）\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e计算机科学家 Codd 对关系代数的形成作出了很大的贡献，他的代数的六个原始运算是「选择」、「投影」、「笛卡尔积」、「并集」、「差集」、「重命名」。\u003c/p\u003e","title":"数据库复习之关系代数"},{"content":"流水线级 一条流水线的每个分步骤被称为流水线级。它们被流水线寄存器分开。下文中没有说明是流水线寄存器的都是普通 CPU 寄存器。\n现代计算机流水线级数已经达到了 10-20 级，在 2000-2010 年间，流水线级数的竞赛达到了最高峰，那时候的处理器甚至可以有高达 31 级的流水线。但是超深的流水线带来的是结构上的复杂和显著增大的动态调度模块设计难度，因此，从那以后就没有再出现过使用这么多级流水线的 CPU 了。\n我们只是稍微介绍（或者说是为已经知道的同学前情回顾）一下最基础的 CPU 流水线，它有助于我们理解更为复杂的流水线实现。同时，这个最基础的 CPU 流水线并不基于某一架构，因此并不会涉及操作数的数量、对立即数的操作等信息。\n取指(Instruction Fetch) 从内存中获取指令\n每个周期从指令缓存中取一条指令 将状态写入流水线寄存器 译码(Instruction Decode) 读取寄存器并解码指令\n解码操作数，为后续阶段设置不同标志 从寄存器文件中读取输入操作数，由所需操作数或指令指定（例如 push 隐含了对栈顶寄存器的操作） 将状态写入流水线寄存器（例如操作数、寄存器内容、立即数等） 执行(Execute) 执行指令\n执行 ALU 运算，计算指令结果 将状态写入流水线寄存器（例如 ALU 计算结果等） 访存(Memory Access) 访问内存\n执行数据缓存访问 将状态写入流水线寄存器（例如上一步得到的 ALU 计算结果和这一步获得的数据等） 写回(Write-Back) 将结果写入寄存器（如果该指令需要这么做的话）\n将加载的数据写入目标寄存器 将 ALU 计算结果写入目标寄存器 设计和实现的问题 冒险(Hazard) 在流水线中我们希望当前每个时钟周期都有一条指令进入流水线可以执行。但在某些情况下，下一条指令无法按照预期开始执行，这种情况就被称为冒险。\n数据冒险 一条指令需要某数据而该数据正在被之前的指令操作，这条指令就无法执行。\nmov eax, 1 add ebx, eax 假设 CPU 不管任何数据冒险。那么当指令 add ebx, eax 来到译码阶段时，它的上一条指令，mov eax, 1 ，还处在执行阶段中。此时 mov eax, 1 还没有将立即数写入 CPU 寄存器，因此 add ebx, eax 无法读取到正确的 eax 内容。这时就出现了数据冒险。\n控制冒险 当前应该执行的指令需要之前的指令运行结果来决定，这条指令就无法执行。\n例如，当需要当前指令进入流水线时，上一条指令 je l1 尚未通过译码阶段，尚未读取条件码寄存器，不能确定下一条执行的指令。\n结构冒险 一条指令需要的硬件部件还在为之前的指令工作，这条指令就无法执行。\n例如，如果指令和数据放在同一个存储器中，则不能同时读存储器（一条指令正在从内存中取指令，另一条正在访存）。实际上，虽然冯诺依曼结构不区分指令和数据，但是在现代 CPU 的一级高速缓存(L1 cache)上，其实区分了指令(icache)和数据(dcache)。\n又例如，读寄存器和写寄存器同时发生（一条指令正在写回，另一条正在译码）。可以通过前半个周期写，后半个周期读，并且设置独立的读写端口的方式来解决。\n解决 解决冒险问题，很多时候采取的是给 CPU 增加更多的支路将不同流水线阶段连接起来的方法，但是由于不能将未来的数据传递到过去，所以除了「转发」操作还不得不使用「暂停」操作。\n转发(Forwarding) 转发有时又叫旁路(Bypassing)\n将结果值直接从一个流水线阶段传到较早阶段的技术就是数据转发。数据转发需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑。\n如上图所示，数据依赖导致了数据冒险，箭头表示依赖关系，红色箭头表示所依赖的数据此时尚未写回，黑色数据表示所依赖数据此时已经写回。\n对于红色箭头，当 and 和 or 处于译码阶段，需要读取寄存器文件时，CPU 能发现在之前的 sub 指令中还有没有完成的寄存器写操作，然后通过数据转发直接获得 $2 的值。\n暂停(Stall \u0026amp; Bubble) 暂停时，处理器会停止流水线的一条或多条指令，直到冒险条件不再满足。\n如上图所示，lw $2 20($3) 将内存中的数据加载到寄存器 $2 中，下一条指令使用了 $2 的值，因此产生了数据冒险。值得注意的是，这里寄存器的值最早也要在访存阶段获得，因此 and 指令无法通过数据转发的方式获得 $2 的值。\n此时就不得不使用暂停的方法来处理冒险了。在这里处理器要暂停已经进入流水线的 lw 以后的所有指令。\n特别需要提醒的是，暂停虽然和指令 nop 有相同之处，但其本质是处理器内部处理数据冒险时自动添加的，而不是由编译器产生的。如果需要编译器产生 nop 指令来暂停，那代码将不能在相同平台的不同流水线级数的处理器上通用（比如有的需要 7 个 nop 指令能等待到冒险条件不满足，有的需要 9 个 nop 指令）。\n分支预测 为什么要预测分支？\n假设我们不预测分支，每当我们遇到控制冒险时都采用暂停的方法，我们需要等待一条指令完成执行阶段再对下一条取指。在前文的五段流水线 CPU 中，这会浪费两个周期。\n而当我们预测分支时，当我们进入了错误的分支时，我们需要抛弃已经运行的结果重新取指（一般叫 flush），这样也是浪费两个周期。但是只要我们预测正确一次，那就必然比暂停的方法快。\n目前所有的 CPU 都采用了分支预测的方法来处理控制冒险，现代 CPU 的分支预测准确率可以达到 90% 。\n","permalink":"https://vaaandark.top/posts/cpu-pipeline/","summary":"\u003ch1 id=\"流水线级\"\u003e流水线级\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e一条流水线的每个分步骤被称为流水线级。它们被流水线寄存器分开。下文中没有说明是流水线寄存器的都是普通 CPU 寄存器。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e现代计算机流水线级数已经达到了 10-20 级，在 2000-2010 年间，流水线级数的竞赛达到了最高峰，那时候的处理器甚至可以有高达 31 级的流水线。但是超深的流水线带来的是结构上的复杂和显著增大的动态调度模块设计难度，因此，从那以后就没有再出现过使用这么多级流水线的 CPU 了。\u003c/p\u003e","title":"CPU 流水线"},{"content":"最近在上大数据分析的课程，老师使用的是斯坦福大学的教材和 PPT ，感觉挺有趣的，记录一下其中的一些算法。\n背景 很多问题可以被归化为寻找相似集合的问题：\n论文差重 寻找购买相似商品的人群 寻找有相似特征的图片 不妨将这次的目的设置为：给定大量的文档，发现其中有抄袭嫌疑的\n但问题是，一个集合中的元素非常多，如果要直接比对，其复杂度可以达到 $O(N^2)$ ，这在大数据尺度明显是不能接受的。\n前置知识 数据之间的距离：\n也可以说是用数据之间的相似度，一般距离越远，相似度越低\n向量的思想：使用角度度量 集合的思想：使用雅卡尔距离度量 点的思想：使用欧氏距离度量 雅卡尔指数可以度量有限样本集合的相似度，定义为两个集合交集大小和并集大小之比：\n$$ J(A, B) = \\frac{\\lvert A \\cap B\\rvert}{\\lvert B \\cup A\\rvert} = \\frac{\\lvert A \\cap B\\rvert}{\\lvert A \\rvert + \\lvert B \\rvert - \\lvert A \\cap B \\rvert} $$\n雅卡尔距离用于度量样本集之间的不相似度，定义为 1 减去雅卡尔系数：\n$$ d_J(A, B) = 1 - J(A, B) = \\frac{\\lvert A \\cup B \\rvert - \\lvert A \\cap B \\rvert}{\\lvert A \\cup B \\rvert} $$\n也可以叫雅卡尔距离为两集合的对称差。\n哈希函数是一种从任何数据中创建小的数字「指纹」的方法。\n我们如果能够找到一种哈希函数，可以在压缩集合成为「指纹」的同时保留其特征，能够用于比较集合之间的相似度，就可以减小计算量了。这也就引出了 Min-Hash 这个算法。\nShingling 何为 Shingling 将文档转化为单词的集合。\n如何转化是个问题，可以有以下的方法：\n直接将文档拆分成很多个单个单词的集合 从文章中提取出关键单词 但以上两种方法都会损失掉单词的顺序信息。而这里要介绍的方法 Shingling 就可以避免。\n这里使用的单词 Shingling 意思为「叠瓦」，非常有意思。说起「叠瓦」，可能会让人想到「叠瓦盘」。\nSMR 叠瓦式磁盘是一种采用新型磁存储技术的高容量磁盘。SMR 盘将盘片上的数据磁道部分重叠，就像屋顶上的瓦片一样，这种技术被称为叠瓦式磁记录技术。该技术在制造工艺方面的变动非常微小，但却可以大幅提高磁盘存储密度。\n在这里的 Shingling 也是类似的，举个例子：\n文档 $D_1 = abcab$ ，使用 2-shingles 就可以获得 $S(D_1) = {ab, bc, ca}$\n如此一来就可以保留原来文档中单词的顺序信息。\n对 Shingle 压缩 由于两篇文档大部分的 Shingle 都会是不同的，因此可以使用 Hash 压缩 Shingle 到相同的宽度的数字类型。\n之后当我们需要比较两个 Shingle 集合的相似程度时，就可以使用之前的雅卡尔距离来估算。\n不过这样还是有很大的计算量，我们需要下文说的 Min-Hash 算法\n对于短篇，k 可以取 5 对于长篇，k 可以取 10 仅作参考，要依据具体情况取舍\nMin-Hash 算法 需求 使用雅卡尔算法比较 Shingle 的哈希依然是缓慢的。假设有 N 篇文档，则需要比较 $N(N-1)/2$ 次，当 $N = 1 million$ 时，需要比较 $5 * 10 ^11$ 次，以一天有 $10^5$ 秒，每秒可以比较 $10^6$ 估算，这将花费五天。如果 N 再大一个数量级，将会花费超过一年的时间。\nMin-Hash 的思想，将大的集合转换成小的「签名」，每个签名中都包含了可以计算相似程度的信息。\n首先需要将集合转换为位数组（0 和 1 组成），0 代表集合中没有这个元素，1 代表集合中有这个元素。\n如此一来，交集就是「按位与运算」，并集就是「按位或运算」。\n再将集合转换为矩阵，每一行表示某一元素（shingles）在不同集合（documents）中是否存在。换言之，每一列表示某一集合包含了哪些元素。\nD1 D2 \u0026hellip; Dn E1 0 0 \u0026hellip; 1 E2 1 1 \u0026hellip; 0 \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; En 0 1 \u0026hellip; 0 假设有一个哈希函数 h ，可以满足：\n$h(C)$ 足够小，可以将大量的 shingles 放入内存中 签名 $h(C_1)$ 与 $h(C_2)$ 的相似程度等同于 $sim(C_1, C_2)$ $sim(C_1, C_2)$ 表示 $C_1$ 和 $C_2$ 的雅卡尔系数 $\\frac{\\lvert A \\cap B\\rvert}{\\lvert B \\cup A\\rvert}$\n理想状态下，我们找到的函数 $h(\\cdot)$ 满足：\n当 $sim(C_1, C_2)$ 很高时，有很大概率 $h(C_1) = h(C_2)$ 当 $sim(C_1, C_2)$ 很低时，有很大概率 $h(C_1) \\neq h(C_2)$ 基本思路 选择一个可以将集合打乱的随机函数 $\\pi$ ，它做到 $Pr(h_{\\pi}(C_1) = h_{\\pi}(C_2)) = sim(C_1, C_2)$ ，满足了我们的需求。\n证明 证明一：\n集合 $X$ 是一个文档，$y \\in X$\n$Pr[\\pi(y) = min(\\pi(X))] = 1/\\lvert X \\rvert$\n这里的 $\\pi(y) = min(\\pi(X))$ 表示在使用 $\\pi$ 打乱 X 后，X 中的元素 y 排在第一位。由于每个元素在随机打乱后排在第一位的概率都是均等的，因此等式右边是 $1/\\lvert X \\rvert$ 。\n容易得到 $Pr(min({\\pi}(C_1)) = min({\\pi}(C_2))) = \\frac{\\lvert A \\cap B\\rvert}{\\lvert B \\cup A\\rvert} = sim(C_1, C_2)$\n证明二：\n可以将两个集合中是否有某种公共元素的情况分为四类\nD1 D2 A 1 1 B 1 0 C 0 1 D 0 0 假设 [a-d] 表示这四类情况的个数\n可以发现 $sim(C_1, C_2) = a/(a +b +c)$\n如果将两个集合以相同的方式打乱，再从上向下扫描，第一个碰到的含有 1 的行是 A 类，则说明 $h(D_1) = h(D_2)$ 。\n示例 如果我们取 100 个 $\\pi$ 函数用来打乱，可以为每个文档生成 100 个签名，那就可以把大量的数据压缩到可以接受的程度了。\n在书中有关于 Min-Hash 实现时需要注意的问题，可以以后再水一篇博客\nLocality Sensitive Hashing 基本思路 找到相似度至少为 $s$ 的文档。\n即使我们已经将所有的文档转换成了很小的签名，然而文档一一配对比较的数量还是太多了，我们依然需要「哈希」和「桶」这两位老朋友。\n可以使用一个函数 $f(\\cdot)$ ，$f(x, y)$ 可以分辨 x 和 y 是不是相似文档的候选者。\n使用哈希函数将矩阵的列分装到不同的「桶」中 所有装在相同的「桶」中的文档是候选者 我们可以把一列分成不同的条带（band），然后进行多次哈希操作。\n分成更小的条带作用是提高效率\n只要有一次被分配到相同的「桶」，就可以成为候选者\n「假阴性」和「假阳性」 「假阴性」：本应被选入而没有被选入\n「假阳性」：本不应被选入而被选入\n在一个条带中的 r 行都匹配的概率为 $s^r$ 在一个条带中至少有一行不匹配的概率为 $1 - s^r$ 在所有条带中都有至少一行不匹配的概率为 $(1 - s^r)^b$ 至少有一个条带的 r 行都匹配（成为候选者）的概率为 $1 - (1 - s^r)^b$ 以 s 为横坐标，成为候选者的概率为纵座标，b 和 r 为常量，可以获得一条 S 型曲线。\n当 b 取值为 1 时，S 型曲线将会退化成为过原点的直线\n取候选者概率为 0.5 ，即 $1 - (1 - s^r)^b = 1/2$\n计算得到 $s = (1 - (\\frac{1}{2})^{\\frac{1}{b}})^{\\frac{1}{r}}$\n由于 $(\\frac{1}{2})^{\\frac{1}{b}}$ 比较接近 0 ，可以利用等价无穷小来估算 $s \\sim (\\frac{1}{b})^{\\frac{1}{r}}$\n在我们的场景下（不可放过抄袭），好的条带划分应该减少假阴性并平衡假阳性的数量。\n假设划分成为 b 个条带，每个条带有 r 行，假设需要比较的两列相似度为 s 。\n参考资料 CS246 Jaccard index MinHash SMR Latex mathematical symbols ","permalink":"https://vaaandark.top/posts/cs246-finding-similar-itemslocality-sensitive-hashing/","summary":"\u003cp\u003e最近在上大数据分析的课程，老师使用的是斯坦福大学的教材和 PPT ，感觉挺有趣的，记录一下其中的一些算法。\u003c/p\u003e\n\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e很多问题可以被归化为寻找相似集合的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e论文差重\u003c/li\u003e\n\u003cli\u003e寻找购买相似商品的人群\u003c/li\u003e\n\u003cli\u003e寻找有相似特征的图片\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e不妨将这次的目的设置为：\u003cstrong\u003e给定大量的文档，发现其中有抄袭嫌疑的\u003c/strong\u003e\u003c/p\u003e","title":"CS246 Finding Similar Items: Locality Sensitive Hashing"},{"content":"这是 MIT6.S081 的第一个 Lab ，目的是为了让学生熟悉 Xv6 和 Unix 的一些实用程序，例如 sleep find xargs 等。\nsleep 这一关是实现 sleep 命令。由于在 user/user.h 目录中给出来了可以直接由 C 语言调用的函数 int sleep(int) ，这一关非常简单：\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { int sec; if (argc != 2) { fprintf(2, \u0026#34;Usage: sleep secends\\n\u0026#34;); exit(1); } sec = atoi(argv[1]); if (sec \u0026gt;= 0) { sleep(sec); } else { fprintf(2, \u0026#34;Usage: sleep secends\\n\u0026#34;); } exit(0); } pingpong 这一关是为了让我们熟悉管道的使用，文档中强调了 uses UNIX system calls to ''ping-pong'' a byte between two processes over a pair of pipes, one for each direction ，所以我们应该创建两个管道，将父子进程的读写交叉连接：\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { char buf[100]; // parent to child int p2c[2]; // child to parent int c2p[2]; pipe(p2c); pipe(c2p); if (fork()) { // parent close(p2c[0]); close(c2p[1]); write(p2c[1], \u0026#34;ping\u0026#34;, 4); read(c2p[0], buf, 4); printf(\u0026#34;%d: received pong\\n\u0026#34;, getpid()); close(p2c[1]); close(c2p[0]); } else { // child close(p2c[1]); close(c2p[0]); read(p2c[0], buf, 4); printf(\u0026#34;%d: received ping\\n\u0026#34;, getpid()); write(p2c[1], \u0026#34;pong\u0026#34;, 4); close(p2c[0]); close(c2p[1]); } exit(0); } primes 这一关是使用多进程来实现筛法。本来一开始没懂他是什么意思，结果看到了文档中的一幅图就懂了。\n写了个递归调用的函数，但是又不想再包装一层，所以当传入的文件描述符为 -1 时表示初始化：\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #define UPPER_BOUND 35 void send_and_close(int fd, int *num, int count) { write(fd, num, sizeof(int) * count); close(fd); } int receive_and_close(int fd, int *num) { int res = read(fd, num, sizeof(int) * UPPER_BOUND); close(fd); return res / sizeof(int); } void sieve(int fd) { int num[UPPER_BOUND]; int rec_count = 0; // if fd \u0026lt; 0, init by building the array first if (fd \u0026lt; 0) { for (int i = 2; i \u0026lt;= UPPER_BOUND; ++i) { num[rec_count++] = i; } } else { rec_count = receive_and_close(fd, num); } if (rec_count \u0026lt;= 0) { return; } int p[2]; pipe(p); if (fork() \u0026gt; 0) { // parent: send numbers close(p[0]); int filter_num = num[0]; printf(\u0026#34;prime %d\\n\u0026#34;, filter_num); int send_count = 0; for (int i = 0; i \u0026lt; rec_count; ++i) { if (num[i] % filter_num != 0) { num[send_count++] = num[i]; } } send_and_close(p[1], num, send_count); wait(0); } else { // child: receive numbers close(p[1]); sieve(p[0]); } } int main(int argc, char *argv[]) { sieve(-1); exit(0); } find 文档中提示了可以参考 user/ls.c ，所以完全可以照着它抄抄改改，连函数 fmtname 都可以改写成 filename 复用。而且由于是改写的 ls 命令，所以错误处理就不用自己动手了。值得注意的是，在递归调用中要忽略掉 . 和 .. 目录，不然会有无限递归的情况。\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; char *filename(char *path) { static char buf[DIRSIZ + 1]; char *p; for (p = path + strlen(path); p \u0026gt;= path \u0026amp;\u0026amp; *p != \u0026#39;/\u0026#39;; --p) ; p++; if (strlen(p) \u0026gt;= DIRSIZ) { return p; } memmove(buf, p, strlen(p)); buf[strlen(p)] = 0; return buf; } void find(char *path, char *pattern) { int fd; if ((fd = open(path, 0)) \u0026lt; 0) { fprintf(2, \u0026#34;find: cannot open %s\\n\u0026#34;, path); return; } if (strcmp(filename(path), pattern) == 0) { printf(\u0026#34;%s\\n\u0026#34;, path); } struct stat st; if (fstat(fd, \u0026amp;st) \u0026lt; 0) { fprintf(2, \u0026#34;find: cannot stat %s\\n\u0026#34;, path); return; } char buf[512]; struct dirent de; if (st.type == T_DIR) { if(strlen(path) + 1 + DIRSIZ + 1 \u0026gt; sizeof buf){ printf(\u0026#34;ls: path too long\\n\u0026#34;); } else { strcpy(buf, path); char *p = buf + strlen(buf); *p++ = \u0026#39;/\u0026#39;; while (read(fd, \u0026amp;de, sizeof(de)) == sizeof(de)) { if (de.inum == 0) { continue; } if (strcmp(de.name, \u0026#34;.\u0026#34;) == 0 || strcmp(de.name, \u0026#34;..\u0026#34;) == 0) { continue; } memmove(p, de.name, strlen(de.name)); p[strlen(de.name)] = 0; find(buf, pattern); } } } close(fd); } int main(int argc, char *argv[]) { if (argc != 3) { printf(\u0026#34;find: wrong argumens\\n\u0026#34;); } find(argv[1], argv[2]); exit(0); } 当我删掉对 . 和 .. 目录的判断时，发现 Xv6 可以在崩溃后报错这是个无限递归，有时间可以研究一下是怎么实现的。我猜测是对栈和 call 指令进行了统计。\nxargs 这一关是完成命令 xargs ，文档对这个实现的要求很低，不要求实现 -n 选项。所以可以直接将所有的 ' ' 和 '\\t' 换成 '\\0' ，这样一来就可以复用缓冲区，直接将 cmd 数组的每个元素指向 buf 的某个位置即可。\n#include \u0026#34;kernel/param.h\u0026#34; #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { char *cmd[MAXARG]; char buf[1024]; int cmd_cnt = 0; for (int i = 1; i \u0026lt; argc; ++i) { cmd[cmd_cnt++] = argv[i]; } int len = read(0, buf, sizeof buf); buf[len] = \u0026#39;\\0\u0026#39;; if (len \u0026lt; 0) { fprintf(2, \u0026#34;xargs: input error\\n\u0026#34;); exit(1); } char *start = buf; for (char *p = buf; *p != \u0026#39;\\0\u0026#39;; ++p) { if (*p == \u0026#39; \u0026#39; || *p == \u0026#39;\\t\u0026#39;) { *p++ = \u0026#39;\\0\u0026#39;; cmd[cmd_cnt++] = start; start = p; } else if (*p == \u0026#39;\\n\u0026#39;) { *p++ = \u0026#39;\\0\u0026#39;; cmd[cmd_cnt++] = start; cmd[cmd_cnt] = 0; start = p; cmd_cnt = argc - 1; if (fork() == 0) { exec(cmd[0], cmd); } else { wait(0); } } } exit(0); } ","permalink":"https://vaaandark.top/posts/mit6.s081-labxv6-and-unix-utilities/","summary":"\u003cp\u003e这是 MIT6.S081 的第一个 Lab ，目的是为了让学生熟悉 Xv6 和 Unix 的一些实用程序，例如 \u003ccode\u003esleep\u003c/code\u003e \u003ccode\u003efind\u003c/code\u003e \u003ccode\u003exargs\u003c/code\u003e 等。\u003c/p\u003e\n\u003ch2 id=\"sleep\"\u003esleep\u003c/h2\u003e\n\u003cp\u003e这一关是实现 \u003ccode\u003esleep\u003c/code\u003e 命令。由于在 \u003ccode\u003euser/user.h\u003c/code\u003e 目录中给出来了可以直接由 C 语言调用的函数 \u003ccode\u003eint sleep(int)\u003c/code\u003e ，这一关非常简单：\u003c/p\u003e","title":"MIT6.S081 Lab: Xv6 and Unix Utilities"},{"content":"由于 i3wm 支持的功能有限，定制性并没有那么强大，最近换成使用 Awesome WM 了，它使用 Lua 作为配置语言，所以可配置性极强。举个例子，i3wm 配置无法像真正的编程语言一样使用 if ... else 语句等，但 Awesome WM 可以，对于同一个快捷键就可以在不同时候有不同的功能。\nAwesome WM 对多显示器支持很好，在官网上还有一个便捷切换显示器的脚本。这个脚本写得非常地巧妙，可以绑定到一个快捷键，每次按都能弹出通知，显示即将使用的显示器布局，当切换到想要的布局后停止按键就可以应用这一布局了。这利用的是 Notification 弹窗如果没有被响应时调用回调函数的特性。\nAwesome WM 的通知使用的是 naughty 模块，它包装了一系列很有用的功能，在 Awesome WM 的 API 文档中介绍了 naughty.notify 的用法，如下是传入参数的一些字段：\nreplaces_id: (int) Replace the notification with the given ID. (optional) destroy: (func) Function to run when notification is destroyed. (optional) replaces_id 可以用于替代上一个 Notification ，这样就有一种轮换的效果了；destroy 是当这个通知消失时的动作，它有一个传入的参数 reason 表示它消失的原因，可以通过这个来过滤非超时消失的情况：\nlocal function naughty_destroy_callback(reason) if reason == naughty.notificationClosedReason.expired then ... end end 可以照猫画虎，实现一个 exit.lua ，在模块内部实现一个类似迭代的效果，每次调用 exit 函数都会改变模组内部变量的状态：\nlocal spawn = require(\u0026#34;awful.spawn\u0026#34;) local naughty = require(\u0026#34;naughty\u0026#34;) local icon_path = os.getenv(\u0026#34;HOME\u0026#34;) .. \u0026#34;/.config/awesome/images/power.png\u0026#34; local state = { cid = nil } local lock_command = \u0026#39;$HOME/.local/bin/fancy-lock \u0026amp;\u0026amp; sleep 1 \u0026amp;\u0026amp; \u0026#39; local lock = { \u0026#34;Lock\u0026#34;, lock_command } local shutdown = { \u0026#34;Shut down\u0026#34;, \u0026#34;shutdown now\u0026#34; } local reboot = { \u0026#34;Reboot\u0026#34;, \u0026#34;systemctl reboot\u0026#34; } local suspend = { \u0026#34;Suspend\u0026#34;, lock_command .. \u0026#34;systemctl suspend\u0026#34; } local hibernate = { \u0026#34;Hibernate\u0026#34;, lock_command .. \u0026#34;systemctl hibernate\u0026#34; } local function menu() return { lock, shutdown, reboot, suspend } end local function naughty_destroy_callback(reason) if reason == naughty.notificationClosedReason.expired then local action = state.index and state.menu[state.index - 1][2] if action then spawn(string.format(\u0026#34;sh -c \\\u0026#39;%s\\\u0026#39;\u0026#34;, action), false) state.index = nil end end end local function exit() if not state.index then state.menu = menu() state.index = 1 end local label, action local next = state.menu[state.index] state.index = state.index + 1 if not next then label = \u0026#39;Do nothing\u0026#39; state.index = nil else label, action = next[1], next[2] end state.cid = naughty.notify({ title = \u0026#34;Awesome WM Exit\u0026#34;, text = string.format(\u0026#34; \u0026lt;span color=\u0026#39;yellow\u0026#39; weight=\u0026#39;bold\u0026#39;\u0026gt;%-10s ?\u0026lt;/span\u0026gt;\u0026#34;, label), icon = icon_path, timeout = 3, screen = mouse.screen, replaces_id = state.cid, destroy = naughty_destroy_callback }).id end return { exit = exit, commands = { lock = lock, shutdown = shutdown, reboot = reboot, suspend = suspend, hibernate = hibernate } } ","permalink":"https://vaaandark.top/posts/awesomewm-widget-with-iterator/","summary":"\u003cp\u003e由于 i3wm 支持的功能有限，定制性并没有那么强大，最近换成使用 Awesome WM 了，它使用 Lua 作为配置语言，所以可配置性极强。举个例子，i3wm 配置无法像真正的编程语言一样使用 \u003ccode\u003eif ... else\u003c/code\u003e 语句等，但 Awesome WM 可以，对于同一个快捷键就可以在不同时候有不同的功能。\u003c/p\u003e","title":"Awesome WM 基于迭代器的小组件"},{"content":"最近发现 Windows 这几个月开机不超过 10 次，寻思着将 Windows 中的空间挪一点到 Linux 中来。说干就干，在 Windows 里面划出来了 80 GB 的空间。\n遗憾地，这 80 GB 空间物理上在我需要扩容的空间的前面，由于开头的扇区存放有很多元数据，因此是不能简单扩容的，只能寻求其他的方法。\n多亏了我使用的文件系统是 Btrfs ，直接一条命令就可以了 btrfs device add /dev/nvme0n1p9 /home ，根本不需要修改 /etc/fstab 。\nBtrfs 的其他特性，就留到以后探索吧！\n","permalink":"https://vaaandark.top/posts/why-btrfs-is-awesome/","summary":"\u003cp\u003e最近发现 Windows 这几个月开机不超过 10 次，寻思着将 Windows 中的空间挪一点到 Linux 中来。说干就干，在 Windows 里面划出来了 80 GB 的空间。\u003c/p\u003e\n\u003cp\u003e遗憾地，这 80 GB 空间物理上在我需要扩容的空间的前面，由于开头的扇区存放有很多元数据，因此是不能简单扩容的，只能寻求其他的方法。\u003c/p\u003e","title":"Btrfs 为什么是神？"},{"content":"今天和朋友交流的时候遇到了自引用问题，之前就在看 Rust Bible 的时候看到过，但是一直没用 Rust 写过什么数据结构，所以没有使用这个的机会，所以今天就来尝试一下。\n首先需要实现的结构体如下：\nstruct Person { name: String, first_name: \u0026amp;str, last_name: \u0026amp;str, } 这里的 first_name 和 last_name 的生命周期应该短于 name 和整个结构体的生命周期。这里使用不同的生命周期标注其实意义不大，它怎么也不能在一个函数中成功创建并返回。因为想要生成一个 slice 必须借用一个 String ，但当这个 String 被 move 进入 Person 结构体时，与之相关的 slice 全部失效了。\n所以软的不行只能来硬的，直接使用 unsafe ：\n#[derive(Debug)] #[allow(unused)] struct Person\u0026lt;\u0026#39;a\u0026gt; { name: String, first_name: \u0026amp;\u0026#39;a str, last_name: \u0026amp;\u0026#39;a str, } impl\u0026lt;\u0026#39;a\u0026gt; Person\u0026lt;\u0026#39;a\u0026gt; { fn new(s: String) -\u0026gt; Person\u0026lt;\u0026#39;a\u0026gt; { let (first, last) = match s.find(\u0026#39; \u0026#39;) { Some(pos) =\u0026gt; { s.split_at(pos) } None =\u0026gt; { (s.as_str(), s.as_str()) } }; let first = first as *const str; let last = last as *const str; unsafe { Person { name: s, first_name: \u0026amp;*first, last_name: \u0026amp;*last } } } } fn main() { let p = Person::new(\u0026#34;Linus Torvalds\u0026#34;.to_string()); println!(\u0026#34;{:?}\u0026#34;, p); } 先将引用转成 raw point ，这就避免了它在 ponitee 被移动后失效。之后直接使用 unsafe ，再将指针转成引用即可。\n虽然很蛋疼，但这就是 Rust ，Love it or leave it!\n","permalink":"https://vaaandark.top/posts/rust-self-referencing-structure/","summary":"\u003cp\u003e今天和朋友交流的时候遇到了自引用问题，之前就在看 \u003cem\u003eRust Bible\u003c/em\u003e 的时候看到过，但是一直没用 Rust 写过什么数据结构，所以没有使用这个的机会，所以今天就来尝试一下。\u003c/p\u003e","title":"Rust 自引用结构"},{"content":"最近开始学习操作系统的相关知识，选择学 MIT6.S081 的课程。\n首先在 课程官方网站 上拉取仓库配置环境。\n$ git clone git://g.csail.mit.edu/xv6-labs-2020 $ cd xv6-labs-2020 $ git checkout util $ make qemu make 时发现有报错：\nuser/sh.c: In function ‘runcmd’: user/sh.c:58:1: error: infinite recursion detected [-Werror=infinite-recursion] 58 | runcmd(struct cmd *cmd) | ^~~~~~ 打开该文件发现：\n// Execute cmd. Never returns. void runcmd(struct cmd *cmd) 这里已经注释说明了这个函数不返回，但是并没有告诉编译器，因此应该加上注解：\n// Execute cmd. Never returns. __attribute__ ((noreturn)) void runcmd(struct cmd *cmd) 现在就可以 make 成功了。\n但是又有了新的问题， qemu 无法加载系统，发现该项目最好在 Ubuntu20.04 上运行，我查看了一下 Ubuntu20.04 的 qemu 版本，是 4.2.1 ，比 Fedora 36 的低很多，我干脆直接编译安装得了。\n在 qemu 官网 安装 4.2.1 ，并安装：\n$ ./configure --prefix=/home/vandark/.local $ make -j8 \u0026amp;\u0026amp; make install 报错没有选项 -nopie 很明显是 GCC 的版本高了，现在的选项是 --no-pie ，在 config-host.mak 修改就可以编译成功了。\n最后就可以进入了：\n$ make qemu xv6 kernel is booting hart 1 starting hart 2 starting init: starting sh $ ","permalink":"https://vaaandark.top/posts/mit6.s081-setup-environment/","summary":"\u003cp\u003e最近开始学习操作系统的相关知识，选择学 MIT6.S081 的课程。\u003c/p\u003e\n\u003cp\u003e首先在 \u003ca href=\"https://pdos.csail.mit.edu/6.S081/2020/labs/util.html\"\u003e课程官方网站\u003c/a\u003e 上拉取仓库配置环境。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-console\" data-lang=\"console\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ git clone git://g.csail.mit.edu/xv6-labs-2020\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ \u003cspan style=\"color:#fff;font-weight:bold\"\u003ecd\u003c/span\u003e xv6-labs-2020\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ git checkout util\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ make qemu\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003emake\u003c/code\u003e 时发现有报错：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-console\" data-lang=\"console\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003euser/sh.c: In function ‘runcmd’:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003euser/sh.c:58:1: error: infinite recursion detected [-Werror=infinite-recursion]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   58 | runcmd(struct cmd *cmd)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      | ^~~~~~\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e打开该文件发现：\u003c/p\u003e","title":"MIT6.S081 实验环境配置"},{"content":"之前在 Lua 代码的编写中写过一些打印表的函数用于调试，这次在看 z.lua 的实现中看到了非常完美的打印表的方法，于是在将代码改得更规范后记录一下：\n使用 luacheck 检查 Lua 代码中的错误和不规范之处\nlocal function print_table(table, level) local key = \u0026#34;\u0026#34; local func func = function(t, l) l = l or 1 local indent = \u0026#34;\u0026#34; for _ = 1, l do indent = indent .. \u0026#34; \u0026#34; end if key ~= \u0026#34;\u0026#34; then print(indent .. key .. \u0026#34; \u0026#34; .. \u0026#34;=\u0026#34; .. \u0026#34; \u0026#34; .. \u0026#34;{\u0026#34;) else print(indent .. \u0026#34;{\u0026#34;) end key = \u0026#34;\u0026#34; for k, v in pairs(t) do if type(v) == \u0026#34;table\u0026#34; then key = k func(v, l + 1) else local content = string.format(\u0026#34;%s%s = %s\u0026#34;, indent .. \u0026#34; \u0026#34;, tostring(k), tostring(v)) print(content) end end print(indent .. \u0026#34;}\u0026#34;) end func(table, level) end print_table({{1, 2, 3}, 4, 5}) 结果输出：\n{ 1 = { 1 = 1 2 = 2 3 = 3 } 2 = 4 3 = 5 } ","permalink":"https://vaaandark.top/posts/lua-print-table/","summary":"\u003cp\u003e之前在 Lua 代码的编写中写过一些打印表的函数用于调试，这次在看 z.lua 的实现中看到了非常完美的打印表的方法，于是在将代码改得更规范后记录一下：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e使用 \u003ccode\u003eluacheck\u003c/code\u003e 检查 Lua 代码中的错误和不规范之处\u003c/p\u003e","title":"Lua 打印 Table"},{"content":"在看 skywind3000 大神写的 z.lua 时发现了神秘写法：\nos.argv = arg ~= nil and arg or {} os.path.sep = windows and \u0026#39;\\\\\u0026#39; or \u0026#39;/\u0026#39; 不需要怎么思考就能知道这个是三目运算。但是在我认知中，Lua 是不支持三目运算符的，定睛一看才发现这个是通过 Lua 布尔运算中的短路特性模拟的三目运算。\nLua 中的短路特性 短路运算的意思是只有在需要的情况下才去检查条件，例如 a and b 当 a = false 时就不需要检查 b 了，或者是 a or b 当 a = true 时也不用检查 b 了。\nLua 中的短路特性与 C 不同点在于，Lua 的布尔操作结果并不只是「真」和「假」。\n例如在 C 中：\nint a = 4 || 2 // a 的值是 1 而在 Lua 中：\nlocal a = 4 or 2 -- a 的值是 4 local b = 4 and 2 -- a 的值是 2 Lua 将 nil 和 false 当作「假」，其余值都视作「真」（包括 0 ）。\n然而，Lua 的布尔运算返回的是原值，而不是 true 或 false 。我推测这与 Lua 将 nil 和 false 都当作「假」有关，如果布尔运算返回了 false ，那 nil 的语意就变化了。\nnil 是 Lua 特殊的类型，它可能的值只有 nil ，它不在本文讨论范围之中\nLua 三目运算的原理 下面可以通过例子来说明 a and b or c ：\n当 a = true 时，这时 a and b 的值为 a ，由于后续是 or ，所以可以直接是 c 当 a = false 时，这时 a and b 的值为 b ，由于后续是 or ，所以可以直接是 b ，注意这里有个坑等下说 Lua 三目运算的陷阱 在前文中提到，当 a = true 时有坑。当 b 为 false 时，后续是 or 所以最后的值是 c 。这就是 Lua 的三目运算模拟方法失效的场景。\n由于 Lua 是一门与 table 结合非常深的语言，我们可以想到利用 table 来解决这一问题，因为 table 在布尔运算中只可能是 nil 和 非nil （表是否为空），只要创造出一个不为空的表，就可以避免之前的 b = false 的情况出现了。\n所以最后的解决办法就是：\n(a and {b} or {c})[1] 由于表 {b} 和 {c} 不可能是空表，所以就不会「掉坑」。\n最后说一句，Lua 真是太奇妙了！\n","permalink":"https://vaaandark.top/posts/lua-ternary-arithmetic/","summary":"\u003cp\u003e在看 \u003ca href=\"https://github.com/skywind3000\"\u003eskywind3000\u003c/a\u003e 大神写的 z.lua 时发现了神秘写法：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-lua\" data-lang=\"lua\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eos.argv = arg ~= \u003cspan style=\"color:#fff;font-weight:bold\"\u003enil\u003c/span\u003e and arg or {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eos.path.sep = windows and \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\\\\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e or \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;/\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e不需要怎么思考就能知道这个是三目运算。但是在我认知中，Lua 是不支持三目运算符的，定睛一看才发现这个是通过 Lua 布尔运算中的短路特性模拟的三目运算。\u003c/p\u003e","title":"Lua 中的三目运算"},{"content":"我经常有在终端查单词的需求，之前使用的是自己写的网络爬虫，原理是构造网址 \u0026ldquo;https://www.youdao.com/result?word={}\u0026amp;lang=en\u0026quot; 并访问，再通过解析 Html 文件获得单词解释。一个朋友说他用的是 sdcv ，星际译王的终端版本，可以支持离线词典。我也时常脱机工作，对离线词典的需求也不小，所以打算自己写一个支持 StarDict 格式离线词典的软件。\n代码仓库：https://github.com/vaaandark/rmall\nStarDict 格式 以朗道英汉字典为例，在解压下载得到的压缩包之后可以看到其目录结构为：\nlangdao-ec-gb ├── langdao-ec-gb.dict.dz ├── langdao-ec-gb.idx └── langdao-ec-gb.ifo 1 directory, 3 files 其中有三种文件：.dict.dz 是压缩后的字典文件，.idx 是索引文件，.ifo 保存了该字典的信息。\n.ifo 文件 首先可以看一下 langdao-ec-gb.ifo 文件：\nStarDict\u0026#39;s dict ifo file version=2.4.2 wordcount=435468 idxfilesize=10651674 bookname=朗道英汉字典5.0 author=上海朗道电脑科技发展有限公司 description=罗小辉破解文件格式，胡正制作转换程序。 date=2003.08.26 sametypesequence=m 在查找相关资料后可以看到这些字段的填写要求：\nbookname= // required wordcount= // required synwordcount= // required if \u0026#34;.syn\u0026#34; file exists. idxfilesize= // required idxoffsetbits= // New in 3.0.0 author= email= website= description= // You can use \u0026lt;br\u0026gt; for new line. date= sametypesequence= // very important. dicttype= 最为重要的是 version 字段，因为如今只支持 2.4.2 和 3.0.0 两个版本，而这两个版本索引文件格式又略有不同。\n.idx 文件 再看看 .idx 的索引文件，StarDict 的文档说它是由很多条目(entries)组成，每个条目由一个不定长的单词字符串加两个数字组成。其中字符串以 \\0 结尾，两个数字分别为该单词在字典文件中的偏移(offset)和大小(size)。\n上文提到了不同版本的索引文件略有不同，在 2.4.2 中数字是 32 位的无符号整型，在 3.0.0 中数字是 64 位的无符号整型。\n所以我可以先用 Lua 脚本大致看一下它的结构：\n#!/usr/bin/env lua -- Usage: ./idx.lua path/to/idx -- or version 3.0.0 -- ./idx.lua path/to/idx -3 local f = arg[1] local pattern = arg[2] == \u0026#39;-3\u0026#39; and \u0026#34;\u0026gt;zI8I8\u0026#34; or \u0026#34;\u0026gt;zI4I4\u0026#34; f = assert(io.open(f, \u0026#34;rb\u0026#34;)) local contents = f:read(\u0026#34;a\u0026#34;) local now local word, offset, size while not now or now \u0026lt; #contents do word, offset, size, now = string.unpack(pattern, contents, now) print(string.format(\u0026#34;%-50s | %8d | %4d\u0026#34;, word, offset, size)) end f:close() 运行这个小工具可以看到：\n$ ./idx.lua ~/.config/rmall/00-langdao-ec-gb/langdao-ec-gb.idx | head a | 0 | 132 A and B agglutinogens | 132 | 24 A AND NOT B gate | 156 | 19 A as well as B | 175 | 28 A B. S. pill | 203 | 45 a back number | 248 | 29 a bad actor | 277 | 20 a bad egg | 297 | 6 a bad hat | 303 | 6 a bad job | 309 | 15 .dict.dz 文件 这个文件本质是由 gzip 压缩后的文件，所以只需使用 gzip -d 解压之后就可以看到它其实是一个文本文件。\n当我们需要查词时，根据上文提到的索引文件中的 offset 和 size 就直接知道了单词释义的位置。\n小插曲 使用 Rust 读取 .idx 使用 Rust 读取二进制文件并不是件很难的事情，但是由于有两种版本的 StarDict 文件，如果使用两个函数分别解析就很麻烦，所以需要使用 Rust 的泛型特性。\n首先弄明白需求，需求就是该函数同时支持读取 4 个字节和 8 个字节的数字，同时要满足读取不定长的字符串。\n由于使用了函数 from_be_bytes 来通过大端序读入，它是 u32 和 u64 等数字类型的方法。\nu32::from_be_bytes 的函数签名是：\npub const fn from_be_bytes(bytes: [u8; 4]) -\u0026gt; u32 u64::from_be_bytes 的函数签名是：\npub const fn from_be_bytes(bytes: [u8; 8]) -\u0026gt; u64 遗憾地，由于这个函数签名的原因，我没有想到只使用一个泛型参数的方法，只能使用两个，一个是类型 T ，一个是表示数组长度的常量 N 。\n更加遗憾地，标准库中的 from_be_bytes 不属于任何一个 trait ，想要将 u32 和 u64 这样能从字节读入的数据抽象到一起还并不简单。好在经过 Google 找到了一个叫做 eio 的 crate ，它有着 trait FromBytes ：\npub trait FromBytes\u0026lt;const N: usize\u0026gt; { fn from_be_bytes(bytes: [u8; N]) -\u0026gt; Self; fn from_le_bytes(bytes: [u8; N]) -\u0026gt; Self; } 所以我的 read_bytes 函数终于成型了：\nfn read_bytes\u0026lt;\u0026#39;a, const N: usize, T\u0026gt;(path: PathBuf) -\u0026gt; Result\u0026lt;Vec\u0026lt;(String, usize, usize)\u0026gt;\u0026gt; where T: FromBytes\u0026lt;N\u0026gt; + TryInto\u0026lt;usize\u0026gt;, \u0026lt;T as TryInto\u0026lt;usize\u0026gt;\u0026gt;::Error: Debug, { let f = File::open(path).map_err(|_| Error::CannotOpenIdxFile)?; let mut f = BufReader::new(f); let mut items: Vec\u0026lt;_\u0026gt; = Vec::new(); let mut buf: Vec\u0026lt;u8\u0026gt; = Vec::new(); while let Ok(n) = f.read_until(0, \u0026amp;mut buf) { if n == 0 { break; } buf.pop(); let mut word = String::new(); buf.iter().for_each(|x| word.push(*x as char)); buf.clear(); let mut b = [0; N]; f.read(\u0026amp;mut b).map_err(|_| Error::IdxFileParsingError)?; let offset = T::from_be_bytes(b).try_into().unwrap(); let mut b = [0; N]; f.read(\u0026amp;mut b).map_err(|_| Error::IdxFileParsingError)?; let size = T::from_be_bytes(b).try_into().unwrap(); items.push((word, offset, size)) } Ok(items) } 在这里将 u32 和 u64 类型 try_into 成 usize ，使用了 unwrap() ，因此需要 \u0026lt;T as TryInto\u0026lt;usize\u0026gt;\u0026gt;::Error: Debug ，而实际上这里的转换是并不会 panic 的。\n关于「字典序」的乌龙 字典序是指按照单词出现在字典的顺序进行排序的方法。\n学过离散数学的都知道字典序是一种全序，学过任何一种编程语言的也知道，在编程语言中比较两个字符串的大小一般都是利用字典序。\n在 C 语言中，strcmp() 函数就是对每个字符的大小进行比较，如果当前字符相同就比较下一个，直到比较出来大小。\n这样的严格按 ASCII 表的字典序其实不是现实世界中字典的样子。举个例子，单词 China 和 china 这两个单词如果按照编程语言的字典序来排绝不会在相邻的地方。因为 C 是 103 而 c 是 143 ，对以 c(C) 开头的单词排序，一定是所有以大写 C 开头的单词排列完成后再是以小写 c 开头的单词，这和我们经常看到的英文词典实际情况不同。\n因此现实世界中的「字典序」应该是先忽略大小写进行排序，相同单词再考虑大小写，这样能保证只是大小写不同的单词会在一起。\n在一开始写查找单词的时候，我直接使用 binary_search_by_key 来查找：\nfn lookup(\u0026amp;\u0026#39;a self, word: \u0026amp;str) -\u0026gt; \u0026amp;\u0026#39;a str { if let Ok(pos) = self.idx.items.binary_search_by_key(\u0026amp;word, |x| \u0026amp;x.0) { let (_, offset, size) = self.idx.items[pos]; self.dict.get(offset, size) } else { panic!(); } } 这样做的后果就是查不到大部分的单词，我还以为是 .idx 文件不规范，但我仔细思考后发现了「字典序」的乌龙后就改变了写法：\npub fn lookup(\u0026amp;\u0026#39;a self, word: \u0026amp;str) -\u0026gt; Result\u0026lt;\u0026amp;\u0026#39;a str\u0026gt; { if let Ok(pos) = self.idx.items.binary_search_by(|probe| { probe .0 .to_lowercase() .cmp(\u0026amp;word.to_lowercase()) .then(probe.0.as_str().cmp(\u0026amp;word)) }) { let (_, offset, size) = self.idx.items[pos]; Ok(self.dict.get(offset, size)) } else { Err(Error::WordNotFound(self.ifo.bookname.to_string())) } } 多字典支持 之前暂时没有在程序中集成多字典，但是可以通过 Shell 脚本实现类似的效果：\n#!/bin/bash word=\u0026#34;$1\u0026#34; for i in langdao-ec-gb oxford-gb cdict-gb kdic-computer-gb; do if rmall lookup -l \u0026#34;$HOME/.config/rmall/$i\u0026#34; \u0026#34;$word\u0026#34;; then exit 0 fi done rmall lookup \u0026#34;$word\u0026#34; 查词时就会按照相应的离线词典优先级查找，如果都没找到则使用电子词典。\n现在集成了多字典功能，可以将词典目录分别命名为 00-XXX, 01-YYY, \u0026hellip;, 99-ZZZ 这样的格式来实现优先级。\n$ rmall -L terraria Error: WordNotFound(\u0026#34;朗道英汉字典5.0\u0026#34;) Error: WordNotFound(\u0026#34;牛津现代英汉双解词典\u0026#34;) Error: WordNotFound(\u0026#34;CDICT5英汉辞典\u0026#34;) Error: WordNotFound(\u0026#34;计算机词汇\u0026#34;) terraria 英 / tɛˈrɛːrɪə / 美 / tɛˈrɛːrɪə / 泰拉瑞亚（游戏名） Xbox Live ArcadeMarch 27, 2013PlayStation VitaLate Fall 2013iOSAugust 29, 2013http://www.terrariaonline. 参考资料 StarDict 字典格式\n","permalink":"https://vaaandark.top/posts/rewrite-stardict-in-rust/","summary":"\u003cp\u003e我经常有在终端查单词的需求，之前使用的是自己写的网络爬虫，原理是构造网址 \u0026ldquo;\u003ca href=\"https://www.youdao.com/result?word=%7B%7D\u0026amp;lang=en%22\"\u003ehttps://www.youdao.com/result?word={}\u0026amp;lang=en\u0026quot;\u003c/a\u003e 并访问，再通过解析 Html 文件获得单词解释。一个朋友说他用的是 sdcv ，星际译王的终端版本，可以支持离线词典。我也时常脱机工作，对离线词典的需求也不小，所以打算自己写一个支持 StarDict 格式离线词典的软件。\u003c/p\u003e","title":"用 Rust 重写星际译王"},{"content":"按照 Mailx 自己的介绍，它是一个增强了的 Mail 命令，提供了更多的功能。\n常规用法是： mailx -s \u0026quot;{{subject}}\u0026quot; {{to_addr}}，通过配置之后可以使用邮箱运营商的服务器发送邮件。\n以使用 QQ 邮箱为例，可以编辑 /etc/mail.rc 的全局配置文件，也可以编辑 ~/.mailrc 的本地配置文件。\n如果使用本地的配置文件，首先要将全局配置文件复制到本地：\n$ cp /etc/mail.rc .mailrc 然后编辑 .mailrc 文件：\n# ~/.mailrc set from={{your_email_address}} set smtp=smtps://smtp.qq.com:465 set smtp-auth=login set smtp-auth-user={{your_email_address}} set smtp-auth-password={{authorization_code}} set ssl-verify=ignore 这里的授权码是 QQ 邮箱用于登录第三方客户端的，并不是 QQ 邮箱密码：\n最后可以发个邮件测试一下：\n$ mailx -s \u0026#39;Mailx Test\u0026#39; {{to_addr}} \u0026lt;\u0026lt;\u0026lt; \u0026#39;This is a test to check if mailx works well.\u0026#39; 在朋友的推荐下，我知道了有另一个功能强大而且 standalone 的包 swaks ，它只依赖于 perl 解释器：\n和 mailx 的配置类似，它需要修改 .swaksrc 文件：\n--from {{your_email_address}} --server smtp.qq.com --auth-user {{your_qq}} --auth-password {{authorization_code}} 同样可以发个邮件测试一下：\nswaks --to {{to_addr}} --h-Subject \u0026#39;Swaks Test\u0026#39; --body \u0026#39;This is a test for swaks\u0026#39; ","permalink":"https://vaaandark.top/posts/mailx-and-swaks/","summary":"\u003cp\u003e按照 Mailx 自己的介绍，它是一个增强了的 Mail 命令，提供了更多的功能。\u003c/p\u003e\n\u003cp\u003e常规用法是： \u003ccode\u003emailx -s \u0026quot;{{subject}}\u0026quot; {{to_addr}}\u003c/code\u003e，通过配置之后可以使用邮箱运营商的服务器发送邮件。\u003c/p\u003e","title":"Mailx 和 Swaks 的使用"},{"content":"最近想写一个小工具，需要用到 SQLite 。之前只会一点点的 INSERT 和 DELETE ，现在想正式入门。\n点命令 点命令不以 ; 结束，它们一般并不直接操作数据库。\n可以使用 .help 来看可以使用的点命令。\n菜鸟教程 SQLite 点命令\nSQLite 语句 这些与数据库直接进行交互的命令包括 CREATE, SELECT, INSERT, UPDATE, DELETE, 和 DROP ，可以根据操作性质分为三种：\nDDL - 数据定义语言 DML - 数据操作语言 DQL - 数据查询语言 所有的 SQLite 语言可以以任何关键字开始，以 ; 结束。\n参考资料 菜鸟教程 SQLite\nSQLite 官方文档\nSQLite Tutorial\n","permalink":"https://vaaandark.top/posts/sqlite-introduction/","summary":"\u003cp\u003e最近想写一个小工具，需要用到 SQLite 。之前只会一点点的 \u003ccode\u003eINSERT\u003c/code\u003e 和 \u003ccode\u003eDELETE\u003c/code\u003e ，现在想正式入门。\u003c/p\u003e\n\u003ch2 id=\"点命令\"\u003e点命令\u003c/h2\u003e\n\u003cp\u003e点命令不以 \u003ccode\u003e;\u003c/code\u003e 结束，它们一般并不直接操作数据库。\u003c/p\u003e\n\u003cp\u003e可以使用 \u003ccode\u003e.help\u003c/code\u003e 来看可以使用的点命令。\u003c/p\u003e","title":"SQLite 入门（持续更新）"},{"content":"高中第一次看到在 C 语言中嵌入汇编语言时，我就觉得它非常好玩，到大学刚开学的时候，我甚至有使用它的需求，可惜直到现在我才抽出时间开始学习它。\n分类 在 GNU 的 GCC 中，内联汇编被分为两类：Basic asm 和 Extended asm 。\nGCC 的官方文档中写到，在函数中混合使用 C 语言和汇编语言时，最好使用扩展形式；但是要在顶层(top level)包含汇编语言，则必须使用基本形式。\n这里的 top level 一词非常诡异，让我摸不着头脑，之后我在官方文档的后文发现了蛛丝马迹：\n两种必须使用 Basic asm 的情形：\nExtended asm 声明必须在 C 函数内，所以如果在文件作用域(top-level)，在函数之外使用汇编，必须使用 Basic asm 。你可以使用此技术发出汇编程序指令，定义可在文件的其他位置调用的汇编语言宏，或用汇编语言编写整个函数。 函数的属性(attribute)被声明为 naked 时必须使用 Basic asm 。 naked attribute 在此不做展开。\n谜底揭开了，原来 top level 指的就是文件这一层。\nBasic asm 可以使用关键字 asm 来声明一段内联汇编，不过这是 GNU 的拓展，如果在编译条件中使用了 -std 或者 -ansi 时，必须使用 __asm__ 。\n修饰 可以使用 volatile 和 inline 来修饰，不过 volatile 没有作用，所有的内联汇编代码段都是默认 volatile 的。如果使用 inline ，那么为了内联的目的，内联汇编语句的大小被当作是可能的最小大小。\n这里涉及到了内联汇编的大小估计，这是因为内联汇编生成的最终代码只由汇编器(Assembler)知晓，所以编译器需要自己估算，通过查找 '\\n\\t', ';' 等符号来估计指令数（行数），再乘以可能的最长指令长度来获得估算大小。所以如果在 inline 的 Basic asm 中使用了伪指令等能生成汇编语句的成分，汇编器可能会报错 unreachable 。\n是否需要估计内联汇编的大小，这个与平台有关。\n参数 又被称为 AssemblerTemplate ，由字符串字面值组成，该字符串由汇编语句组成，可以包括伪指令，GCC 的编译器并不检查它们的有效性，指令会被直接传递到汇编器中。\n在一段内联汇编中使用多条汇编语句时要注意自己使用的是什么汇编器（以及它们使用的是何种汇编方言），一般都可以用 '\\n\\t' 来分隔，有些汇编器可以使用 ';' ，但要注意在这种汇编方言中分号是不是注释开始的符号。\n注意 由于调用函数以及访问 C 数据可能很复杂，在这种情况下使用 Extended asm 是更好的选择。\n在编译器优化后连续的 asm 声明可能不再连续，所以如要需要连续语句，请写在同一个 asm 语句中。尤其是两个 asm 声明中包含了跳转时，如果被编译器调整顺序则会产生意想不到的后果。如果要跳转到 C 标签，还是使用 Extended asm 更好。\n如果在汇编语句中定义了符号或者标签，可能会导致重复符号的错误。\nExtended asm 拓展内联汇编有两种模板：\nasm asm-qualifiers ( AssemblerTemplate : OutputOperands [ : InputOperands [ : Clobbers ] ]) asm asm-qualifiers ( AssemblerTemplate : OutputOperands : InputOperands : Clobbers : GotoLabels) 同样地，在不使用 GNU 拓展时要用 __asm__ 代替 asm。\n修饰 除了 volatile 和 inline 外，还有 goto ，表示这段内联汇编代码可能会跳转到 GotoLabels 中的某一个标签上。\n参数 input, output, goto 的操作数加起来不能超过 30 个。\nAssemblerTemplate 同样是由字符串字面值组成，但是里面包含了一些标识符，它们指向了 output, input, goto 中的操作数。\nOutputOperands 不能将其单纯理解为输出，而是理解为会被修改的变量。\n由 AssemblerTemplate 中的指令修改的 C 变量列表，由逗号分隔，可以为空。\n结构一般为：\n[ [asmSymbolicName] ] constraint (cvariablename) asmSymbolicName 可以理解为在这段拓展内联汇编中的符号别名，它可以和上下文中的 C 语言符号重复，也可以和其他内联汇编代码中的符号名重复。在 AssemblerTemplate 中的使用方法为 %[Value]。\n如果不使用符号别名，则必须使用位置编号来指示符号，例如 OutputOperands 中有三项，则用 %0, %1 和 %2 表示。\nconstraint Output 的约束修饰符必须是以 '=' 开始（表示将会覆写这个变量），如果这个变量既被读也被写就需要 '+' 。当使用 '=' 时不要假定可以读取到将被覆写的变量的当前值，除非这个变量也在 Input 列表中。\n使用了 '+' 的操作数视作两个（在计算总个数及位置时）。\n还需要对值所在的位置进行约束，例如 'r' 表示寄存器，'m' 表示在内存。如果使用了一个以上的位置约束修饰符，编译器会选择它认为最好的方式进行优化。\n也可以使用数字进行约束，例如：\nasm (\u0026#34;incl %0\u0026#34; :\u0026#34;=a\u0026#34;(var):\u0026#34;0\u0026#34;(var)); 表示输入中的 var 使用的是和输出中的 var 相同的约束，这里的 0 表示为编号为 0 的操作数。\n常用的约束：\n符号 含义 I a constant a use eax b use ebx c use ecx d use edx S use esi D use edi r use one of eax, ebx, ecx or edx q use one of eax, ebx, ecx, edx, esi or edi 其余见 GCC 文档。\ncvariablename 一个 C 左值表达式，一般为变量。\nInputOperands 不能将其单纯理解为输入，而是理解为会被读取的变量。\n由 AssemblerTemplate 中的指令读取的 C 表达式列表，由逗号分隔，可以为空。\n结构也为：\n[ [asmSymbolicName] ] constraint (cvariablename) asmSymbolicName 如果有两个输入操作数，三个输出操作数，则第一个输入操作数为 %2 ，第二个为 %3 ，第三个为 %4 。\n一个例子：\nasm (\u0026#34;cmoveq %1, %2, %[result]\u0026#34; : [result] \u0026#34;=r\u0026#34;(result) : \u0026#34;r\u0026#34; (test), \u0026#34;r\u0026#34; (new), \u0026#34;[result]\u0026#34; (old)); Clobbers In software engineering and computer science, clobbering a file, processor register or a region of computer memory is the process of overwriting its contents completely, whether intentionally or unintentionally, or to indicate that such an action will likely occur.\n以逗号分隔的寄存器列表，一般为 AssemblerTemplate 更改的其他值（没有被列入 OutputOperands 的部分）。例如一些汇编指令（例如 cld ）有副作用，会使用到额外的寄存器。\n有两个特殊的 clobber ：\ncc - 表示将会修改 flag 寄存器。\nmemory - 这个 clobber 可以告诉编译器，这段内联汇编代码将对输入和输出操作数之外的项执行内存读取或写入操作（例如，输入操作数是一个指针，需要访问它指向的内存）。\n使用 memory 时，为了确保内存中包含正确的值，GCC 可能需要在执行这段内联汇编之前，将特定的寄存器值刷新到内存中。\n此外，在执行一个提前读取操作之前，编译器不会假定从内存中读取的值在执行该提前读取操作之后保持不变，而是会根据需要重新加载这些值。\nmemory 这个 clobber 有效地为编译器形成了读/写内存障碍。但这并不能阻止处理器在内联汇编语句之后执行推测性读操作。这种情况下还是需要 fence 指令。\nGotoLabels 此部分包含 C 标签的列表，当使用 goto 形式时，AssemblerTemplate 中的代码可以跳转到这些标签。\n要引用汇编程序模板中的标签，需要在它前面加上 'l' ，后面加上它在 GotoLabels 中的位置与输入和输出操作数的数目之和。带约束修饰符 '+' 的输出操作数被视为两个操作数。例如，如果有三个输入操作数，一个输出操作数带有约束修饰符 '+'，一个输出操作数带有约束修饰符 '=' ，那么 GotoLabels 的第一个标签称为 %l6 ，第二个称为 %l7 。\n也可以使用实际的 C 标签名，例如如果要引用 GotoLabels 中的 carry 标签，可以使用 %l[carry] ，这也是推荐的方法，避免了对编号的计算。\n实例 两数之和：\nint main(void) { int foo = 10, bar = 15; __asm__ __volatile__(\u0026#34;addl %%ebx,%%eax\u0026#34; :\u0026#34;=a\u0026#34;(foo) :\u0026#34;a\u0026#34;(foo), \u0026#34;b\u0026#34;(bar) ); printf(\u0026#34;foo+bar=%d\\n\u0026#34;, foo); return 0; } 或者：\n__asm__ __volatile__( \u0026#34; lock ;\\n\u0026#34; \u0026#34; addl %1,%0 ;\\n\u0026#34; : \u0026#34;=m\u0026#34; (my_var) : \u0026#34;ir\u0026#34; (my_int), \u0026#34;m\u0026#34; (my_var) : /* no clobber-list */ ); lock 表示这是个原子操作。\n字符串复制：\nstatic inline char * strcpy(char * dest,const char *src) { int d0, d1, d2; __asm__ __volatile__( \u0026#34;1:\\tlodsb\\n\\t\u0026#34; \u0026#34;stosb\\n\\t\u0026#34; \u0026#34;testb %%al,%%al\\n\\t\u0026#34; \u0026#34;jne 1b\u0026#34; : \u0026#34;=\u0026amp;S\u0026#34; (d0), \u0026#34;=\u0026amp;D\u0026#34; (d1), \u0026#34;=\u0026amp;a\u0026#34; (d2) : \u0026#34;0\u0026#34; (src),\u0026#34;1\u0026#34; (dest) : \u0026#34;memory\u0026#34;); return dest; } #define mov_blk(src, dest, numwords) \\ __asm__ __volatile__ ( \\ \u0026#34;cld\\n\\t\u0026#34; \\ \u0026#34;rep\\n\\t\u0026#34; \\ \u0026#34;movsl\u0026#34; \\ : \\ : \u0026#34;S\u0026#34; (src), \u0026#34;D\u0026#34; (dest), \u0026#34;c\u0026#34; (numwords) \\ : \u0026#34;%ecx\u0026#34;, \u0026#34;%esi\u0026#34;, \u0026#34;%edi\u0026#34; \\ ) Linux 系统调用：\n#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \\ type name(type1 arg1,type2 arg2,type3 arg3) \\ { \\ long __res; \\ __asm__ volatile ( \u0026#34;int $0x80\u0026#34; \\ : \u0026#34;=a\u0026#34; (__res) \\ : \u0026#34;0\u0026#34; (__NR_##name),\u0026#34;b\u0026#34; ((long)(arg1)),\u0026#34;c\u0026#34; ((long)(arg2)), \\ \u0026#34;d\u0026#34; ((long)(arg3))); \\ __syscall_return(type,__res); \\ } Linux 退出：\n{ asm(\u0026#34;movl $1,%%eax; /* SYS_exit is 1 */ xorl %%ebx,%%ebx; /* Argument is in ebx, it is 0 */ int $0x80\u0026#34; /* Enter kernel mode */ ); } 参考资料 内联汇编深入起来非常繁杂，有些功能需要使用的时候可以直接查看 GNU 的文档。\nGCC Inline Assembly HOWTO\nGCC doc in web archive\nHow to Use Inline Assembly Language in C Code\nBasic Asm\nExtended Asm\nHow to Use Inline Assembly Language in C Code\nDeclaring Attributes of Functions\nLocal Register Variables\n","permalink":"https://vaaandark.top/posts/inline-assembly/","summary":"\u003cp\u003e高中第一次看到在 C 语言中嵌入汇编语言时，我就觉得它非常好玩，到大学刚开学的时候，我甚至有使用它的需求，可惜直到现在我才抽出时间开始学习它。\u003c/p\u003e\n\u003ch2 id=\"分类\"\u003e分类\u003c/h2\u003e\n\u003cp\u003e在 GNU 的 GCC 中，内联汇编被分为两类：\u003cstrong\u003eBasic asm\u003c/strong\u003e 和 \u003cstrong\u003eExtended asm\u003c/strong\u003e 。\u003c/p\u003e","title":"内联汇编"},{"content":"看这年终总结，发现几个问题：\n是我借别人号的原因还是我真的严重手机上瘾了，怎么看了这么多视频，一天的持续上线时间这么长？不过当我看到我看了 153 部电影，26 部电视剧，21 部动画，21 部纪录片，就可以确定了应该是借号的原因，我除了吃饭睡觉外都没有这么多时间来看。 是不是什么视频都要弄个知识的标签？回顾一年搞得像我是来b站上课了，知识区我看得最多的一个 UP 竟然是「君在西安」，他是一位美食 UP 。 成分有没有必要这么明显？看得最多标签是「皇马」、「C罗」、「足球」、「历史」、「战争」，投币最多的 UP 是「皇马Nino」和「比不中说篮球」，感觉自己的罗迷、詹黑成分非常明显。 确实熬夜太多了，最近几天有把b站当作抖音刷的趋势，狂看小视频。 看了挺多电影赏析（不是那种“注意看，这个男人叫小美”的剧情介绍），但是实际看的完整电影并不多，而且类型很狭隘。不过好在我算是系统性地过完了黑帮片和西部片，以及一些经典科幻片。 ","permalink":"https://vaaandark.top/posts/2022-bilibili-report/","summary":"\u003cp\u003e看这年终总结，发现几个问题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e是我借别人号的原因还是我真的严重手机上瘾了，怎么看了这么多视频，一天的持续上线时间这么长？不过当我看到我看了 153 部电影，26 部电视剧，21 部动画，21 部纪录片，就可以确定了应该是借号的原因，我除了吃饭睡觉外都没有这么多时间来看。\u003c/li\u003e\n\u003cli\u003e是不是什么视频都要弄个知识的标签？回顾一年搞得像我是来b站上课了，知识区我看得最多的一个 UP 竟然是「君在西安」，他是一位美食 UP 。\u003c/li\u003e\n\u003cli\u003e成分有没有必要这么明显？看得最多标签是「皇马」、「C罗」、「足球」、「历史」、「战争」，投币最多的 UP 是「皇马Nino」和「比不中说篮球」，感觉自己的罗迷、詹黑成分非常明显。\u003c/li\u003e\n\u003cli\u003e确实熬夜太多了，最近几天有把b站当作抖音刷的趋势，狂看小视频。\u003c/li\u003e\n\u003cli\u003e看了挺多电影赏析（不是那种“注意看，这个男人叫小美”的剧情介绍），但是实际看的完整电影并不多，而且类型很狭隘。不过好在我算是系统性地过完了黑帮片和西部片，以及一些经典科幻片。\u003c/li\u003e\n\u003c/ol\u003e","title":"2022 Bilibili 年度报告"},{"content":"自己的 Wi-Fi6 漏油器用着还行，校园网带宽可以跑满，但是我的这个型号并不能刷 openwrt ，所以不能 ssh 连接，更不能在上面跑同学们写的那些自动认证脚本。\n去年折腾 Arduino 和 nodemcu 时想到可以利用 esp8266 的联网功能让它来代替进行认证工作。\n说干就干，其实并不是，我今天凌晨看葡萄牙比赛的时候才开始写代码。\n认证的流程大概是这样的，首先访问一个可以被跳转到认证页面的网站，我选择的是百度。在返回的字段中找到以\u0026quot;wlanuerip\u0026quot;开头，直到（但不包括）'\u0026lt;/scripts\u0026gt;的部分，然后根据某种方式（详见代码）和帐号密码等参数组合在一起，发给192.168.50.3的8080端口就可以完成认证了。\n代码见 GitHub 仓库 vaaandark/hust-network-login-esp ，里面也含有使用 arduino-cli 的编译烧录脚本。\n","permalink":"https://vaaandark.top/posts/hust-network-login/","summary":"\u003cp\u003e自己的 Wi-Fi6 漏油器用着还行，校园网带宽可以跑满，但是我的这个型号并不能刷 openwrt ，所以不能 ssh 连接，更不能在上面跑同学们写的那些自动认证脚本。\u003c/p\u003e\n\u003cp\u003e去年折腾 Arduino 和 nodemcu 时想到可以利用 esp8266 的联网功能让它来代替进行认证工作。\u003c/p\u003e","title":"校园网自动认证"},{"content":"Representation of Data Qubits A bit of data is represented by a single atom that is in one of two states denoted by $\\ket0$ and $\\ket1$. A single bit of this form is known as a qubit\n在量子计算机中，一个原子可以通过 $\\ket0$ 和 $\\ket1$ 其中之一的状态来表示一个比特位的数据。一个形如这样的比特位被称为量子位。\nA physical implementation of a qubit could use the two energy levels of an atom. An excited state representing $\\ket1$ and a ground state representing $\\ket0$.\n量子位的物理实现可以通过一个原子的两个能级来表示。激发态表示 $\\ket1$ 而基态表示 $\\ket0$ 。\nSuperposition A single qubit can be forced into a superposition of the two states denoted by the addition of the state vectors:\n我们用一组向量表示两个状态的叠加，从而可以强制通过量子叠加表示单个量子位。\n$$\\ket\\psi=\\alpha_1\\ket0+\\alpha_2\\ket1$$\nWhere $\\alpha_1$ and $\\alpha_2$ are complex numbers and $|\\alpha_1|^2+|\\alpha_2|^2 = 1$\n这里的 $\\alpha_1$ 和 $\\alpha_2$ 是复数，而且满足 $|\\alpha_1|^2+|\\alpha_2|^2 = 1$\nA qubit in superposition is in both of the states $\\ket1$ and $\\ket0$ at the same time\n一个量子叠加的量子位同时处于 $\\ket1$ 和 $\\ket0$ 的状态\nConsider a 3 bit qubit register. An equally weighted superposition of all possible states would be denoted by:\n考虑一个 3-bit 大小的寄存器，量子叠加所有状态的一个等价表示如下：\n$$\\ket\\psi = 1/\\sqrt8\\ket{000}+1/\\sqrt8\\ket{001}+\u0026hellip;+1/\\sqrt8\\ket{111}$$\nData Retrieval In general, an n qubit register can represent the numbers $0$ through $2^n-1$ simultaneously.\n总而言之，一个 n-bit 的寄存器的寄存器可以同时表示 $0$ 到 $2^n-1$ 。\nSound too good to be true?…It is!\n听起来是不是过于美妙了？但是这就是事实。\nIf we attempt to retrieve the values represented within a superposition, the superposition randomly collapses to represent just one of the original values.\n如果我们尝试去查看处于叠加状态的值，叠加状态会随机地坍缩，仅仅会表示原值中的一个。\nIn our equation: $\\ket\\psi=\\alpha_1\\ket0+\\alpha_2\\ket1$ , $\\alpha_1$ represents the probability of the superposition collapsing to $\\ket0$. The $\\alpha_n$\u0026rsquo;s are called probability amplitudes. In a balanced superposition, $\\alpha_n=1/\\sqrt2$ where n is the number of qubits.\n在我们的方程中：$\\ket\\psi=\\alpha_1\\ket0+\\alpha_2\\ket1$ ，$\\alpha_1$ 表示坍缩到 $\\ket0$ 的概率。$\\alpha_n$ 被称为概率幅。在平衡叠加状态，满足 $\\alpha_n=1/\\sqrt2$ ，n 是量子位的数量。\nEntanglement Entanglement is the ability of quantum systems to exhibit correlations between states within a superposition.\n纠缠是量子系统在叠加态之间展现相互关系的能力。\nImagine two qubits, each in the state $\\ket0$ + $\\ket1$ (a superposition of the 0 and 1.) We can entangle the two qubits such that the measurement of one qubit is always correlated to the measurement of the other qubit.\n想象两个比特，每一个都在 0 和 1 的量子叠加状态，我们可以将两个量子位纠缠在一起，使得一个量子位的测量总是与另一个量子位的测量相关联。\nOperations on Qubits Reversible Logic Due to the nature of quantum physics, the destruction of information in a gate will cause heat to be evolved which can destroy the superposition of qubits.\n由于量子物理学的性质，门中信息的破坏将导致放出热量，从而破坏量子比特的叠加。\nThis type of gate cannot be used. We must use Quantum Gates.\n因此不能使用这种类型的门，我们必须使用量子门。\nQuantum Gates Quantum Gates are similar to classical gates, but do not have a degenerate output. i.e. their original input state can be derived from their output state, uniquely. They must be reversible.\n量子门类似于经典门，但没有退化输出。 也就是说，它们的原始输入状态可以唯一地从它们的输出状态中导出。 它们必须是可逆的。\nThis means that a deterministic computation can be performed on a quantum computer only if it is reversible. Luckily, it has been shown that any deterministic computation can be made reversible.(Charles Bennet, 1973)\n这意味着只有在可逆的情况下，才能在量子计算机上执行确定性计算。 幸运的是，已经证明任何确定性计算都可以实现可逆。（Charles Bennet，1973）\nHadamard Simplest gate involves one qubit and is called a Hadamard Gate (also known as a square-root of NOT gate.) Used to put qubits into superposition.\n最简单的门涉及一个量子位，称为 Hadamard 门（也称为 NOT 门的平方根），用于将量子位叠加。\nNote: Two Hadamard gates used in succession can be used as a NOT gate\n注意：连续使用的两个 Hadamard 门可以作为一个非门\nControlled NOT A gate which operates on two qubits is called a Controlled-NOT (CN) Gate. If the bit on the control line is 1, invert the bit on the target line.\n在两个量子位上运行的门称为受控非 (CN) 门。 如果控制线上的位为 1，则将目标线上的位反转。\nNote: The CN gate has a similar behavior to the XOR gate with some extra information to make it reversible.\n注意：CN 门与 XOR 门具有相似的行为，但有一些额外的信息使其可逆。\nMultiplication By 2 We can build a reversible logic circuit to calculate multiplication by 2 using CN gates arranged in the following manner:\n我们可以构建一个可逆逻辑电路，使用按以下方式排列的 CN 门来计算 2 的乘法：\nControlled Controlled NOT (CCN) A gate which operates on three qubits is called a Controlled Controlled NOT (CCN) Gate. Iff the bits on both of the control lines is 1,then the target bit is inverted.\n在三个量子位上运行的门称为受控受控非 (CCN) 门。 如果两条控制线上的位都是 1，则目标位被反转。\nA Universal Quantum Computer The CCN gate has been shown to be a universal reversible logic gate as it can be used as a NAND gate.\nCCN 门已被证明是一种通用的可逆逻辑门，因为它可以用作与非门。\nWhen our target input is 1, our target output is a result of a NAND of B and C.\n当我们的目标 A 输入为 1 时，我们的目标输出 A 是 B 和 C 的 NAND 的结果。\nReference Joseph Stelmach, Quantum Computer https://www.eecis.udel.edu/~saunders/courses/879-03s/quantumComputers.ppt\nwikipedia, probability amplitudes https://en.wikipedia.org/wiki/Probability_amplitude\nwikipedia, Quantum superposition https://en.wikipedia.org/wiki/Quantum_superposition\nPS 感谢 https://note.qidong.name/2018/03/hugo-mathjax/ 这篇博客，我终于找到了在 hugo 中使用公式的完美方案。\n","permalink":"https://vaaandark.top/posts/quantum-computer/","summary":"\u003ch2 id=\"representation-of-data\"\u003eRepresentation of Data\u003c/h2\u003e\n\u003ch3 id=\"qubits\"\u003eQubits\u003c/h3\u003e\n\u003cp\u003eA bit of data is represented by a single atom that is in one of two states denoted by $\\ket0$ and $\\ket1$.  A single bit of this form is known as a \u003cstrong\u003equbit\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在量子计算机中，一个原子可以通过 $\\ket0$ 和 $\\ket1$ 其中之一的状态来表示一个比特位的数据。一个形如这样的比特位被称为\u003cstrong\u003e量子位\u003c/strong\u003e。\u003c/p\u003e","title":"量子计算机"},{"content":"上次物理实验做的是双偏振，实验资料中推荐使用 origin 画图，我既不想使用 Windows 也不想多下载一个软件，因此我打算用 matplotlib 画图。\n代码 第一个实验画图是很简单的线性回归计算：\nimport numpy as np import matplotlib.pyplot as plt import math plt.rcParams[\u0026#39;font.sans-serif\u0026#39;]=[\u0026#39;SimHei\u0026#39;] angles = [90, 80, 70, 60, 50, 40, 30, 20, 10, 0] x = [] for a in angles: x.append(math.cos(a / 180 * math.pi) ** 2) y1 = [0.6, 6.8, 21.0, 41.8, 68.9, 94.1, 118.2, 136.1, 149.7, 152.8] y2 = [0.6, 6.8, 15.7, 39.6, 68.4, 92.2, 119.2, 130.8, 142.9, 147.7] x = np.array(x) y1 = np.array(y1) y2 = np.array(y2) plt.scatter(x, y1, 50, \u0026#34;black\u0026#34;, marker = \u0026#34;o\u0026#34;) plt.scatter(x, y2, 50, \u0026#34;black\u0026#34;, marker = \u0026#34;v\u0026#34;) a1, b1 = np.polyfit(x, y1, 1) a2, b2 = np.polyfit(x, y2, 1) plt.plot(x, a1 * x + b1, \u0026#34;blue\u0026#34;) plt.plot(x, a2 * x + b2, \u0026#34;red\u0026#34;) plt.title(\u0026#34;光强 I 与透光轴夹角 θ 的关系\u0026#34;, fontsize = 13) plt.xlabel(\u0026#39;$cos^2θ$\u0026#39;, fontsize = 12) plt.ylabel(\u0026#39;$I/*10^{-7}$\u0026#39;, fontsize = 12) plt.tick_params(labelsize = 11) plt.grid(True, linestyle = \u0026#34;--\u0026#34;, color = \u0026#34;g\u0026#34;, linewidth = \u0026#34;0.5\u0026#34;) plt.savefig(\u0026#34;lab1.png\u0026#34;) plt.show() 第三个实验画图使用了极座标系和极座标系上的拟合，需要查看 matplotlib 的 API ：\nimport matplotlib.pyplot as plt from scipy.optimize import curve_fit import numpy as np plt.rcParams[\u0026#39;font.sans-serif\u0026#39;]=[\u0026#39;SimHei\u0026#39;] def form(x, A): res = A * A * 2 * (np.cos(x) * np.cos(x) * 0.75 + np.sin(x) * np.sin(x) * 0.25) return res theta = [] for i in range(0, 360, 10): theta.append(i / 180 * np.pi) I = [ 93.9, 90.7, 84.4, 75.6, 65.0, 54.9, 45.7, 38.5, 34.6, 33.8, 37.0, 43.2, 51.0, 61.1, 71.0, 80.4, 87.1, 91.3, 92.2, 88.9, 82.6, 75.8, 67.2, 56.8, 47.2, 39.9, 36.0, 35.2, 38.1, 44.5, 53.4, 63.8, 72.2, 80.4, 88.2, 91.9 ] # 为了最后封口 theta.append(theta[0]) I.append(I[0]) fig, ax = plt.subplots(subplot_kw={\u0026#39;projection\u0026#39;: \u0026#39;polar\u0026#39;}) plt.scatter(theta, I, 50, marker = \u0026#34;o\u0026#34;) plt.xlabel(\u0026#39;$I/*10^{-7}$\u0026#39;, fontsize = 12) ax.set_title(\u0026#34;椭圆偏振光光强测量数据\u0026#34;, va = \u0026#34;bottom\u0026#34;) param, covariance = curve_fit(form, theta, I, method=\u0026#34;trf\u0026#34;) plt.plot(theta, form(theta, *param), \u0026#34;blue\u0026#34;) plt.savefig(\u0026#34;lab3.png\u0026#34;) plt.show() 在编写代码过程中发现，在form这个函数里只能使用 numpy 中的函数，而不能使用 math 中的函数，因为这个函数用于拟合，处理的是一堆数据组成的向量，必须要支持向量运算。\n效果 参考 matplotlib API Reference https://matplotlib.org/stable/api/index.html\nhttps://matplotlib.org/stable/gallery/pie_and_polar_charts/polar_demo.html\nhttps://matplotlib.org/stable/gallery/lines_bars_and_markers/scatter_custom_symbol.html\n","permalink":"https://vaaandark.top/posts/dual-polarization-experiment-drawing/","summary":"\u003cp\u003e上次物理实验做的是双偏振，实验资料中推荐使用 origin 画图，我既不想使用 Windows 也不想多下载一个软件，因此我打算用 matplotlib 画图。\u003c/p\u003e\n\u003ch2 id=\"代码\"\u003e代码\u003c/h2\u003e\n\u003cp\u003e第一个实验画图是很简单的线性回归计算：\u003c/p\u003e","title":"物理双偏振实验画图"},{"content":"今天初步认识了 ARM 汇编。\nCPU 内寄存器 aarch64 有 31 个 64 位通用寄存器，它们的名字是为 xn（n 为 0-30 的整数），不像 80X86 一样暗示了它们的用途。\n类似 rax 和 eax 的关系，它们对应的 32 位寄存器叫做 wn（n 为 0-30 的整数）。\n还有几个特殊寄存器和 80X86 类似，不过多出来了链接寄存器。\n段的定义方法 段的定义方法与 80X86 有很大区别，但是和 nasm 语法基本一致。\n指令语句及其格式 目前学到的一些区别：\n格式上更类似于 Intel 的语法，第一个操作数是目的寄存器（目的存储器）。 ARM 的很多指令都是三操作数的，这给编码带来了更多的灵活性。 ARM 指令是定长的，每一条指令都是固定的 4 字节长度。 立即数表示不一样，使用了#作为前缀。 寄存器基址变址寻址不需要加号，使用[R1, #8]这样的格式。 LDR.W R0, [R1,#20]!相当于 x86 汇编的mov eax [ebx, 20] mov eax [eax]两句。 寄存器列表{}语法。 4005f4: a9be7bfd stp x29, x30, [sp, #-32]! 4005f8: 910003fd mov x29, sp 可以看到机器指令a9be7bfd和910003fd是定长的\n一些特殊的指令 LDR 字数据加载指令 LDRB 字节数据加载指令 LDRH 半字数据加载指令 STR 字数据存储指令 TRB 字节数据存储指令 STRH 半字数据存储指令 子程序调用 ARM 使用 bl 跳转进入子程序，并不像 80X86 一样使用 call 。\n参数传递 提供了 8 个通用寄存器（r0-r7）用于传递函数参数，一次对应arg1到arg8，超过 8 个的参数会存放在堆栈中。\nGCC 生成的汇编依然是 Caller Save 。\n使用 GCC 编译时，发现虽然传递到寄存器的顺序不会对函数调用有影响，但是 GCC 还是逆序传入寄存器，可能是为了结构化生成代码。\n返回值 如果返回值是整型，则是 x0 。\n与 C 语言混合编程 将.s和.c文件分开编程与 80X86 没有区别，内联汇编也没有区别，区别主要在于 ARM 汇编的语法。\n","permalink":"https://vaaandark.top/posts/differences-between-arm-and-80x86/","summary":"\u003cp\u003e今天初步认识了 ARM 汇编。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"cpu-内寄存器\"\u003eCPU 内寄存器\u003c/h2\u003e\n\u003cp\u003eaarch64 有 31 个 64 位通用寄存器，它们的名字是为 xn（n 为 0-30 的整数），不像 80X86 一样暗示了它们的用途。\u003c/p\u003e\n\u003cp\u003e类似 rax 和 eax 的关系，它们对应的 32 位寄存器叫做 wn（n 为 0-30 的整数）。\u003c/p\u003e","title":"ARM与80X86的异同"},{"content":"还是计算机系统基础，即将对 arm 架构展开学习，使用的是华为的打开欧拉(openEuler)操作发行版。\n进入镜像 首先下载虚拟机镜像，老师发的我安装不了，就在清华的镜像站下载了。 $ aria2c -x 15 -s 2 \u0026#34;https://mirrors.tuna.tsinghua.edu.cn/openeuler/openEuler-20.03-LTS/virtual_machine_img/aarch64/openEuler-20.03-LTS.aarch64.qcow2.xz\u0026#34; 先调整一下镜像的磁盘大小。 $ qemu-img resize openEuler-20.03-LTS.aarch64.qcow2 +20G 启动镜像，注意需要使用引导文件。 qemu-system-aarch64 -m 4096 \\ -cpu cortex-a57 \\ -smp 4 \\ -M virt \\ -bios edk2-aarch64-code.fd \\ -hda openEuler-20.03-LTS.aarch64.qcow2 \\ -nographic \\ 配置网络 配置网络这部分，尤其是网卡那部分我不是很懂，基本上是照着教程来做。\n虽然 QEMU 的字符界面用起来很顺手，几乎和使用了 ssh 连接一样，但是在一些 curses 库的 TUI 界面中显示不佳，我还是准备使用 ssh 。\n总所周知，虚拟机有多种连接网络的方式，这次配置我使用的是“用户网络”的方式，然后将端口 22 和主机端口 10021 绑定。\n#!/bin/bash qemu-system-aarch64 -m 4096 \\ -cpu cortex-a57 \\ -smp 4 \\ -M virt \\ -bios edk2-aarch64-code.fd \\ -net nic,model=e1000 \\ -net user,hostfwd=tcp::10021-:22 \\ -hda openEuler-20.03-LTS.aarch64.qcow2 \\ -nographic 使用脚本进入后发现没有 ip ，说明网卡配置还不正确。\n创建并编辑/etc/sysconfig/newwork-scipts/ifcfg-eth0文件。使用nmcli c查看 UUID ，使用ifconfig查看 MAC 地址。\nDEVICE=eth0 HWADDR=52:54:00:12:34:56 UUID=e449c48a-45a7-3db7-8cf3-349bd209b064 NM_CONTROLLED=yes ONBOOT=yes BOOTPROTO=dhcp type=Ethernet IPV6INIT=no USERCTL=no 重启 NetworkManager 和使 ssh 自启动。\n$ systemctl restart NetworkManager $ systemctl enable sshd 打开网卡并测试。\n$ ifup eth0 $ ping baidu.com 使用 ssh 连接。\n$ ssh -p 10021 root@localhost 配置软件 创建并编辑/etc/yum.repos.d/openEuler.repo。\n[OS] name=openEuler-$releasever - OS baseurl=https://repo.openeuler.org/openEuler-20.03-LTS/OS/$basearch/ enabled=1 gpgcheck=1 gpgkey=https://repo.openeuler.org/openEuler-20.03-LTS/OS/$basearch/RPM-GPG-KEY-openEuler [update] name=openEuler-$releasever - Update baseurl=http://repo.openeuler.org/openEuler-20.03-LTS/update/$basearch/ enabled=1 gpgcheck=1 gpgkey=http://repo.openeuler.org/openEuler-20.03-LTS/update/$basearch/RPM-GPG-KEY-openEuler [extras] name=openEuler-$releasever - Extras baseurl=http://repo.openeuler.org/openEuler-20.03-LTS/extras/$basearch/ enabled=0 gpgcheck=1 gpgkey=http://repo.openeuler.org/openEuler-20.03-LTS/extras/$basearch/RPM-GPG-KEY-openEuler 安装常用软件。\n$ dnf install gcc gcc-c++ libstdc++-devel gdb nasm 新建用户，配置管理员权限之类的都是常规操作了，就不用赘述了。\n","permalink":"https://vaaandark.top/posts/setup-qemu-for-openeuler-aarch64/","summary":"\u003cp\u003e还是计算机系统基础，即将对 arm 架构展开学习，使用的是华为的打开欧拉(openEuler)操作发行版。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"进入镜像\"\u003e进入镜像\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e首先下载虚拟机镜像，老师发的我安装不了，就在清华的镜像站下载了。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-console\" data-lang=\"console\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ aria2c -x \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e15\u003c/span\u003e -s \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/openeuler/openEuler-20.03-LTS/virtual_machine_img/aarch64/openEuler-20.03-LTS.aarch64.qcow2.xz\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e先调整一下镜像的磁盘大小。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-console\" data-lang=\"console\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ qemu-img resize openEuler-20.03-LTS.aarch64.qcow2 +20G\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e启动镜像，注意需要使用引导文件。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-console\" data-lang=\"console\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eqemu-system-aarch64 -m 4096 \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        -cpu cortex-a57 \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        -smp 4 \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        -M virt \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        -bios edk2-aarch64-code.fd \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        -hda openEuler-20.03-LTS.aarch64.qcow2 \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        -nographic \\\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"配置网络\"\u003e配置网络\u003c/h2\u003e\n\u003cp\u003e配置网络这部分，尤其是网卡那部分我不是很懂，基本上是照着教程来做。\u003c/p\u003e","title":"QEMU配置openEuler的aarch64开发环境"},{"content":"腾哈格今天不知道在干嘛，没有了大B哥就完全不会踢球了。虽然之前总是批评大B哥传球毛躁冒险，但是他还是有后插上和威胁球的能力的。今天的范德贝克完全隐身，活该坐板凳；而爱神就像是野球场上的老大爷，看似技术高一档，实际上已经被对面年轻人强傻了冲烂了，他今天上场主要是给客场球迷展示自己的斜长传水平的。胖虎今天略有不在状态，又成了背锅侠，中场失控他也分身乏术。\n后场更是重量级，利马今天乍一看像个野兽，非常具有侵略性。但是也就只有侵略性了，两次失球与他有关，下半场甚至两连肘击对面球员。我每次看到他都是怒气冲冲地上去，奔着打架去对抗。不过这安东尼泰勒果然是盲侠。\n前场众前锋拿不到球，边路的组合完全没有配合，加纳乔有小技术但是没有配合，爆发力也很欠缺。C罗还是在打中锋位置，看得他急我也急。\n简而言之，今天的曼联很像当时范大厨的“大圈战术”，中场没人或者只有一个人，然而边路的推进十分便秘，每次都只能再斜长传打到弱侧，弱侧球员也没有维尼修斯一样的爆边能力。\n这支曼联还有救吗？\n","permalink":"https://vaaandark.top/posts/2022.11.6-man-utd-vs-aston-villa/","summary":"\u003cp\u003e腾哈格今天不知道在干嘛，没有了大B哥就完全不会踢球了。虽然之前总是批评大B哥传球毛躁冒险，但是他还是有后插上和威胁球的能力的。今天的范德贝克完全隐身，活该坐板凳；而爱神就像是野球场上的老大爷，看似技术高一档，实际上已经被对面年轻人强傻了冲烂了，他今天上场主要是给客场球迷展示自己的斜长传水平的。胖虎今天略有不在状态，又成了背锅侠，中场失控他也分身乏术。\u003c/p\u003e","title":"2022.11.6 维拉 3 : 1 曼联"},{"content":"之前的 Bomb Lab 没有做，现在刚好在上计算机系统基础这门课，学校使用了 CSAPP 的 Bomb Lab ，可以补交一下 CSAPP 的作业，也可以学习一下 GDB 的使用。\n实验简述 遗憾地，CSAPP 的 Bomb Lab 早已提供的是 Linux 的 64 位可执行程序，而我校的 Lab 还是 32 位的 Windows PE32 。不过我还是找老师要到了它的 Linux 版本，不过也是 ELF32 ，可执行文件的名字叫bomb_32。\n该 Lab 是 CSAPP Bomb Lab 的老版 32 位程序，所以之后我还是看一下新版的 Bomb Lab 较好，不能完全不了解 64 位汇编嘛 :(\n实验环境 GNU gdb (GDB) Fedora 12.1-2.fc36 GNU objdump version 2.37-36.fc36 实验过程 首先反汇编生成汇编代码：\n$ objdump -S -C bomb_32 \u0026gt; bomb.disas 由于我不是很会看 AT\u0026amp;T 的汇编代码，所以我的 objdump 是 aliased 的，默认使用 Intel 的语法。\n$ which objdump objdump=\u0026#39;objdump --disassembler-options=intel\u0026#39; /usr/bin/objdump gdb 也默认使用 Intel 的语法：\n$ cat ~/.gdbinit set disassembly-flavor intel 再使用 gdb 开始调试程序：\n$ gdb --args ./bomb_32 input phase_1 由于老师给了这个程序运行的流程图，我也看过 Bomb Lab 中提供的 .c 文件，所以我知道每个字符串都在phase_n的函数中输入或者检验。\n可以直接查看phase_1函数的反汇编代码，并注意到这个函数中的一个函数调用：\n(gdb) disas phase_1 Dump of assembler code for function phase_1: ...... 0x08048b2c \u0026lt;+12\u0026gt;:\tpush 0x80497c0 0x08048b31 \u0026lt;+17\u0026gt;:\tpush eax 0x08048b32 \u0026lt;+18\u0026gt;:\tcall 0x8049030 \u0026lt;strings_not_equal\u0026gt; ...... 可以看到它在压入两个参数之后调用了一个函数strings_not_equal，我们直接查看0x80497c0里面是什么内容，我首先猜测它是一个字符串：\n(gdb) p (char *)0x80497c0 $1 = 0x80497c0 \u0026#34;Public speaking is very easy.\u0026#34; 在之后的测试中，这个字符串也让我过了第一关。\nphase_2 直接查看phase_2的汇编代码：\n; phase_2 的参数为字符串 input ，在 [ebp+0x8] 08048b48 \u0026lt;phase_2\u0026gt;: 8048b48:\t55 push ebp 8048b49:\t89 e5 mov ebp,esp ; 为局部变量腾出空间 8048b4b:\t83 ec 20 sub esp,0x20 ; 可能是内部调用的函数需要使用这两个寄存器 ; 所以根据 caller save 在这里保存 8048b4e:\t56 push esi 8048b4f:\t53 push ebx ; 将 input 放入 edx 中 8048b50:\t8b 55 08 mov edx,DWORD PTR [ebp+0x8] ; 等于 sub esp, 0x8 8048b53:\t83 c4 f8 add esp,0xfffffff8 ; 将局部变量的地址 [ebp-0x18] 放入 eax 中 ; 不妨给它起名为变量 A ; 由于给局部变量预留的位置很大，猜测 A 是一个数组 8048b56:\t8d 45 e8 lea eax,[ebp-0x18] ; 压栈传参，传入的是 input, A 8048b59:\t50 push eax 8048b5a:\t52 push edx ; 调用函数 read_six_numbers 根据名字合理怀疑这里是读入六个数字，A 可能有 6 个元素 8048b5b:\te8 78 04 00 00 call 8048fd8 \u0026lt;read_six_numbers\u0026gt; ; 这里 esp 加了 0x10 相当于把之前的参数退栈了，还把之前 add esp,0xfffffff8 的加回去了。我猜测之前的 add 可能和内存对齐有关 8048b60:\t83 c4 10 add esp,0x10 ; 将 A[0] 与 1 比较 ; 由于之前传递的是地址，这个变量应该在 read_six_numbers 中被修改了 8048b63:\t83 7d e8 01 cmp DWORD PTR [ebp-0x18],0x1 ; 如果是 1 则成功，不是 1 则引爆炸弹 8048b67:\t74 05 je 8048b6e \u0026lt;phase_2+0x26\u0026gt; 8048b69:\te8 8e 09 00 00 call 80494fc \u0026lt;explode_bomb\u0026gt; ; ebx \u0026lt;- 0x1 8048b6e:\tbb 01 00 00 00 mov ebx,0x1 ; 将 A 放入 esi 中 8048b73:\t8d 75 e8 lea esi,[ebp-0x18] ; eax \u0026lt;- 0x2 8048b76:\t8d 43 01 lea eax,[ebx+0x1] ; 这步骤操作之后 eax 的值为 (ebx + 1) * A[ebx - 1] ; ebx 初始为 1 8048b79:\t0f af 44 9e fc imul eax,DWORD PTR [esi+ebx*4-0x4] ; 相当于判断 A[ebx] 是不是 A[ebx - 1] 两倍 8048b7e:\t39 04 9e cmp DWORD PTR [esi+ebx*4],eax 8048b81:\t74 05 je 8048b88 \u0026lt;phase_2+0x40\u0026gt; 8048b83:\te8 74 09 00 00 call 80494fc \u0026lt;explode_bomb\u0026gt; 8048b88:\t43 inc ebx 8048b89:\t83 fb 05 cmp ebx,0x5 ; 我读到这里才发现是一个循环，终止条件为 ebx \u0026gt; 5 8048b8c:\t7e e8 jle 8048b76 \u0026lt;phase_2+0x2e\u0026gt; ; 所以根据递推公式可知字符串为 1 2 6 24 120 720 8048b8e:\t8d 65 d8 lea esp,[ebp-0x28] 8048b91:\t5b pop ebx 8048b92:\t5e pop esi 8048b93:\t89 ec mov esp,ebp 8048b95:\t5d pop ebp 8048b96:\tc3 ret 8048b97:\t90 nop 它调用了函数read_six_numbers，所以我们也分析一下它：\n; 参数为字符串 input 和数组 A 08048fd8 \u0026lt;read_six_numbers\u0026gt;: 8048fd8:\t55 push ebp 8048fd9:\t89 e5 mov ebp,esp 8048fdb:\t83 ec 08 sub esp,0x8 ; 传入的输入字符串 8048fde:\t8b 4d 08 mov ecx,DWORD PTR [ebp+0x8] ; 传入的数组 A 8048fe1:\t8b 55 0c mov edx,DWORD PTR [ebp+0xc] ; A[5] 8048fe4:\t8d 42 14 lea eax,[edx+0x14] 8048fe7:\t50 push eax ; A[4] 8048fe8:\t8d 42 10 lea eax,[edx+0x10] 8048feb:\t50 push eax ; A[3] 8048fec:\t8d 42 0c lea eax,[edx+0xc] 8048fef:\t50 push eax ; A[2] 8048ff0:\t8d 42 08 lea eax,[edx+0x8] 8048ff3:\t50 push eax ; A[1] 8048ff4:\t8d 42 04 lea eax,[edx+0x4] 8048ff7:\t50 push eax ; A[0] 8048ff8:\t52 push edx ; format 字符串 \u0026#34;%d %d %d %d %d %d\u0026#34; 8048ff9:\t68 1b 9b 04 08 push 0x8049b1b ; input 输入字符串 8048ffe:\t51 push ecx 8048fff:\te8 5c f8 ff ff call 8048860 \u0026lt;sscanf@plt\u0026gt; 8049004:\t83 c4 20 add esp,0x20 8049007:\t83 f8 05 cmp eax,0x5 804900a:\t7f 05 jg 8049011 \u0026lt;read_six_numbers+0x39\u0026gt; 804900c:\te8 eb 04 00 00 call 80494fc \u0026lt;explode_bomb\u0026gt; 8049011:\t89 ec mov esp,ebp 8049013:\t5d pop ebp 8049014:\tc3 ret 8049015:\t8d 76 00 lea esi,[esi+0x0] 使用字符串1 2 6 24 120 720成功通过第二关。\nphase_3 ; phase_3 的参数为字符串 input ，在 [ebp+0x8] 08048b98 \u0026lt;phase_3\u0026gt;: 8048b98:\t55 push ebp 8048b99:\t89 e5 mov ebp,esp ; 预留 20 个字节 8048b9b:\t83 ec 14 sub esp,0x14 8048b9e:\t53 push ebx ; 将 input 放入 edx 8048b9f:\t8b 55 08 mov edx,DWORD PTR [ebp+0x8] ; sub esp, 0x4 8048ba2:\t83 c4 f4 add esp,0xfffffff4 ; ; int_b 8048ba5:\t8d 45 fc lea eax,[ebp-0x4] 8048ba8:\t50 push eax ; char_c 8048ba9:\t8d 45 fb lea eax,[ebp-0x5] 8048bac:\t50 push eax ; int_a 8048bad:\t8d 45 f4 lea eax,[ebp-0xc] 8048bb0:\t50 push eax ; 通过 GBD 调试可以知道这个地址内容为 \u0026#34;%d %c %d\u0026#34; 8048bb1:\t68 de 97 04 08 push 0x80497de ; input 8048bb6:\t52 push edx 8048bb7:\te8 a4 fc ff ff call 8048860 \u0026lt;sscanf@plt\u0026gt; 8048bbc:\t83 c4 20 add esp,0x20 ; 如果 sscanf 匹配并赋值的个数不多于 2 ，则爆炸 8048bbf:\t83 f8 02 cmp eax,0x2 8048bc2:\t7f 05 jg 8048bc9 \u0026lt;phase_3+0x31\u0026gt; 8048bc4:\te8 33 09 00 00 call 80494fc \u0026lt;explode_bomb\u0026gt; ; 将 int_a 与 0x7 比较 ; 怀疑是一个防止数组越界的操作 8048bc9:\t83 7d f4 07 cmp DWORD PTR [ebp-0xc],0x7 ; 如果大于则爆炸 8048bcd:\t0f 87 b5 00 00 00 ja 8048c88 \u0026lt;phase_3+0xf0\u0026gt; ; 将 int_a 赋值给 eax 8048bd3:\t8b 45 f4 mov eax,DWORD PTR [ebp-0xc] ; 这里存在一个跳转表，对应到 C 语言中应该是一个 switch-case 结构 ; 可以在 gdb 里面查看一下对应的表 `(gdb) p/x *(int *)0x80497e8` ; [0x80497e8] 对应 8048be0 ; [0x80497e8+1*4] 对应 8048c00 ; [0x80497e8+2*4] 对应 8048c16 ; [0x80497e8+3*4] 对应 8048c28 ; [0x80497e8+4*4] 对应 8048c40 ; [0x80497e8+5*4] 对应 8048c52 ; [0x80497e8+6*4] 对应 8048c64 ; [0x80497e8+7*4] 对应 8048c76 ; switch-case(int_a) 8048bd6:\tff 24 85 e8 97 04 08 jmp DWORD PTR [eax*4+0x80497e8] 8048bdd:\t8d 76 00 lea esi,[esi+0x0] ; case 0: ; bl \u0026lt;- 0x71 8048be0:\tb3 71 mov bl,0x71 ; 将 int_b 与 0x309 比较 8048be2:\t81 7d fc 09 03 00 00 cmp DWORD PTR [ebp-0x4],0x309 ; 如果等于就 break 8048be9:\t0f 84 a0 00 00 00 je 8048c8f \u0026lt;phase_3+0xf7\u0026gt; 8048bef:\te8 08 09 00 00 call 80494fc \u0026lt;explode_bomb\u0026gt; 8048bf4:\te9 96 00 00 00 jmp 8048c8f \u0026lt;phase_3+0xf7\u0026gt; ; eiz 是一个伪寄存器，它始终为 0 8048bf9:\t8d b4 26 00 00 00 00 lea esi,[esi+eiz*1+0x0] ; 后面几个 case 都是相同的道理 ...... ; bl 与 char_c 比较 8048c8f:\t3a 5d fb cmp bl,BYTE PTR [ebp-0x5] ; 所以基本流程就是根据 int_a 的值确定进去哪一个 case ， ; 然后在该分支中将 int_b 和某一值比较，并确定 char_c 应该等于的值 ; 所以答案应该不唯一，通过 int_a 的值确定后面两个答案 ...... 我使用0 q 777通过了这一关。\nphase_4 这一关包含了递归函数，但是挑战性不是很大。\n; phase_4 的参数为字符串 input ，在 [ebp+0x8] 08048ce0 \u0026lt;phase_4\u0026gt;: 8048ce0:\t55 push ebp 8048ce1:\t89 e5 mov ebp,esp 8048ce3:\t83 ec 18 sub esp,0x18 ; input -\u0026gt; edx 8048ce6:\t8b 55 08 mov edx,DWORD PTR [ebp+0x8] ; sub esp, 0xc 8048ce9:\t83 c4 fc add esp,0xfffffffc ; 不妨令该局部变量为 A 8048cec:\t8d 45 fc lea eax,[ebp-0x4] 8048cef:\t50 push eax ; 根据 GDB `p (char *)0x8049808` 可得该字符串为 `%d` 8048cf0:\t68 08 98 04 08 push 0x8049808 8048cf5:\t52 push edx 8048cf6:\te8 65 fb ff ff call 8048860 \u0026lt;sscanf@plt\u0026gt; 8048cfb:\t83 c4 10 add esp,0x10 ; 判断 sscanf 是否成功 8048cfe:\t83 f8 01 cmp eax,0x1 8048d01:\t75 06 jne 8048d09 \u0026lt;phase_4+0x29\u0026gt; ; 判断 A 和 0x0 ，如果不大于 0 则爆炸 8048d03:\t83 7d fc 00 cmp DWORD PTR [ebp-0x4],0x0 8048d07:\t7f 05 jg 8048d0e \u0026lt;phase_4+0x2e\u0026gt; 8048d09:\te8 ee 07 00 00 call 80494fc \u0026lt;explode_bomb\u0026gt; ; sub esp, 0x4 8048d0e:\t83 c4 f4 add esp,0xfffffff4 ; A -\u0026gt; eax 8048d11:\t8b 45 fc mov eax,DWORD PTR [ebp-0x4] ; 参数入栈并调用 func4 8048d14:\t50 push eax 8048d15:\te8 86 ff ff ff call 8048ca0 \u0026lt;func4\u0026gt; 8048d1a:\t83 c4 10 add esp,0x10 ; 返回值如果不是 55 则爆炸 8048d1d:\t83 f8 37 cmp eax,0x37 8048d20:\t74 05 je 8048d27 \u0026lt;phase_4+0x47\u0026gt; 8048d22:\te8 d5 07 00 00 call 80494fc \u0026lt;explode_bomb\u0026gt; 8048d27:\t89 ec mov esp,ebp 8048d29:\t5d pop ebp 8048d2a:\tc3 ret 8048d2b:\t90 nop 现在我们来看看func4\n; phase_4 的参数为整型 A ，在 [ebp+0x8] 08048ca0 \u0026lt;func4\u0026gt;: 8048ca0:\t55 push ebp 8048ca1:\t89 e5 mov ebp,esp 8048ca3:\t83 ec 10 sub esp,0x10 8048ca6:\t56 push esi 8048ca7:\t53 push ebx ; ebx \u0026lt;- A 8048ca8:\t8b 5d 08 mov ebx,DWORD PTR [ebp+0x8] ; 如果 A 不大于 1 则跳转到 退出，这里应该是递归出口，返回值为 1 8048cab:\t83 fb 01 cmp ebx,0x1 8048cae:\t7e 20 jle 8048cd0 \u0026lt;func4+0x30\u0026gt; 8048cb0:\t83 c4 f4 add esp,0xfffffff4 8048cb3:\t8d 43 ff lea eax,[ebx-0x1] 8048cb6:\t50 push eax ; func(A - 1) 8048cb7:\te8 e4 ff ff ff call 8048ca0 \u0026lt;func4\u0026gt; 8048cbc:\t89 c6 mov esi,eax 8048cbe:\t83 c4 f4 add esp,0xfffffff4 8048cc1:\t8d 43 fe lea eax,[ebx-0x2] 8048cc4:\t50 push eax ; func(A - 2) ; 写到这里可以猜到这是斐波那契数列， ; 之前要求返回值是 55 ，所以输入应该是 9 8048cc5:\te8 d6 ff ff ff call 8048ca0 \u0026lt;func4\u0026gt; 8048cca:\t01 f0 add eax,esi 8048ccc:\teb 07 jmp 8048cd5 \u0026lt;func4+0x35\u0026gt; 8048cce:\t89 f6 mov esi,esi 8048cd0:\tb8 01 00 00 00 mov eax,0x1 8048cd5:\t8d 65 e8 lea esp,[ebp-0x18] 8048cd8:\t5b pop ebx 8048cd9:\t5e pop esi 8048cda:\t89 ec mov esp,ebp 8048cdc:\t5d pop ebp 8048cdd:\tc3 ret 8048cde:\t89 f6 mov esi,esi 输入9成功通过了这一关。\nphase_5 ; phase_5 的参数为字符串 input ，在 [ebp+0x8] 08048d2c \u0026lt;phase_5\u0026gt;: 8048d2c:\t55 push ebp 8048d2d:\t89 e5 mov ebp,esp 8048d2f:\t83 ec 10 sub esp,0x10 8048d32:\t56 push esi 8048d33:\t53 push ebx ; input -\u0026gt; ebx 8048d34:\t8b 5d 08 mov ebx,DWORD PTR [ebp+0x8] 8048d37:\t83 c4 f4 add esp,0xfffffff4 8048d3a:\t53 push ebx ; 计算 input 字符串长度，如果长度不为 6 则爆炸 8048d3b:\te8 d8 02 00 00 call 8049018 \u0026lt;string_length\u0026gt; 8048d40:\t83 c4 10 add esp,0x10 8048d43:\t83 f8 06 cmp eax,0x6 8048d46:\t74 05 je 8048d4d \u0026lt;phase_5+0x21\u0026gt; 8048d48:\te8 af 07 00 00 call 80494fc \u0026lt;explode_bomb\u0026gt; ; 小知识：由于两数相同，所以使用 xor 来清零快一些 8048d4d:\t31 d2 xor edx,edx ; 不妨令这个变量为 str_a 8048d4f:\t8d 4d f8 lea ecx,[ebp-0x8] ; 地址 0x804b220 \u0026#34;isrveawhobpnutfg\\260\\001\u0026#34; ; 怀疑是通过一些操作从上述字符串中取出字符重新拼接 ; 不妨令这个字符串为 dict 8048d52:\tbe 20 b2 04 08 mov esi,0x804b220 ; 从这里开始是循环六次，后面的字符串常量长度也刚好为 6 ; al \u0026lt;- input[edx] 8048d57:\t8a 04 1a mov al,BYTE PTR [edx+ebx*1] ; 取 al 低四位 8048d5a:\t24 0f and al,0xf ; 拓展长度到 32 位 8048d5c:\t0f be c0 movsx eax,al ; al \u0026lt;- dict[eax] 8048d5f:\t8a 04 30 mov al,BYTE PTR [eax+esi*1] ; str_a[edx] \u0026lt;- al 8048d62:\t88 04 0a mov BYTE PTR [edx+ecx*1],al 8048d65:\t42 inc edx 8048d66:\t83 fa 05 cmp edx,0x5 8048d69:\t7e ec jle 8048d57 \u0026lt;phase_5+0x2b\u0026gt; ; 循环结束 ; 给字符串 str_a 结尾补上 \u0026#39;\\0\u0026#39; 8048d6b:\tc6 45 fe 00 mov BYTE PTR [ebp-0x2],0x0 8048d6f:\t83 c4 f8 add esp,0xfffffff8 ; 地址 0x804980b \u0026#34;giants\u0026#34; 8048d72:\t68 0b 98 04 08 push 0x804980b 8048d77:\t8d 45 f8 lea eax,[ebp-0x8] 8048d7a:\t50 push eax ; 比较 str_a 和 \u0026#34;giants\u0026#34; ; 所以输入字符串只看最低四位应该是 15 0 5 11 13 1 ，十六进制是 f 0 5 b d 1 ; 查看 ASCII 表，找到方便输入的内容，a-z 及其附近的字符很符合要求 ; 所以使用 o`ekma 8048d7b:\te8 b0 02 00 00 call 8049030 \u0026lt;strings_not_equal\u0026gt; ...... 输入o`ekma成功通过了这一关。\nphase_6 这一关比较长，我将它分为几个部分。\n一开始就能看到局部变量被赋值到一个神秘的地址，这应该解这题的关键。之后使用了read_six_numbers这个函数读入六个数字。\n; phase_6 的参数为字符串 input ，在 [ebp+0x8] 08048d98 \u0026lt;phase_6\u0026gt;: ...... ; input \u0026lt;- edx 8048da1:\t8b 55 08 mov edx,DWORD PTR [ebp+0x8] ; *(int *)0x804b26c 153 ; 不妨令该局部变量为指针 C ; C \u0026lt;- 0x804b26c ; 它直接指向了一个神秘的结构 8048da4:\tc7 45 cc 6c b2 04 08 mov DWORD PTR [ebp-0x34],0x804b26c 8048dab:\t83 c4 f8 add esp,0xfffffff8 ; 不妨令该局部变量为数组 A 8048dae:\t8d 45 e8 lea eax,[ebp-0x18] 8048db1:\t50 push eax 8048db2:\t52 push edx 8048db3:\te8 20 02 00 00 call 8048fd8 \u0026lt;read_six_numbers\u0026gt; 碰到的第一个循环：\n; for (int i = 0; i \u0026lt;= 5; ++i) { ; if (A[i] \u0026gt; 6) ; explode_bomb(); ; for (int j = i + 1; j \u0026lt;= 5; ++j) { ; if (A[i] == A[j]) ; explode_bomb(); ; } ; } ; edi \u0026lt;- 0 不妨令其为 i 8048db8:\t31 ff xor edi,edi 8048dba:\t83 c4 10 add esp,0x10 8048dbd:\t8d 76 00 lea esi,[esi+0x0] ; eax \u0026lt;- A ; 循环 6 次 8048dc0:\t8d 45 e8 lea eax,[ebp-0x18] ; eax \u0026lt;- A[i] 8048dc3:\t8b 04 b8 mov eax,DWORD PTR [eax+edi*4] ; eax \u0026lt;- A[i] - 1 8048dc6:\t48 dec eax ; 如果 eax 大于 5 就爆炸，不能大于 6 8048dc7:\t83 f8 05 cmp eax,0x5 8048dca:\t76 05 jbe 8048dd1 \u0026lt;phase_6+0x39\u0026gt; 8048dcc:\te8 2b 07 00 00 call 80494fc \u0026lt;explode_bomb\u0026gt; ; ebx \u0026lt;- i + 1 不妨令其为 j 8048dd1:\t8d 5f 01 lea ebx,[edi+0x1] ; if (j \u0026lt;= 5) 8048dd4:\t83 fb 05 cmp ebx,0x5 8048dd7:\t7f 23 jg 8048dfc \u0026lt;phase_6+0x64\u0026gt; ; eax \u0026lt;- 4 * edi 8048dd9:\t8d 04 bd 00 00 00 00 lea eax,[edi*4+0x0] ; 不妨令这个局部变量为 B ; B \u0026lt;- 4 * edi 8048de0:\t89 45 c8 mov DWORD PTR [ebp-0x38],eax ; esi \u0026lt;- A 8048de3:\t8d 75 e8 lea esi,[ebp-0x18] ; 内层循环 8048de6:\t8b 55 c8 mov edx,DWORD PTR [ebp-0x38] ; eax \u0026lt;- A[i] 8048de9:\t8b 04 32 mov eax,DWORD PTR [edx+esi*1] ; 比较 A[i] 和 A[j] 8048dec:\t3b 04 9e cmp eax,DWORD PTR [esi+ebx*4] ; 如果相等则引爆炸弹 8048def:\t75 05 jne 8048df6 \u0026lt;phase_6+0x5e\u0026gt; 8048df1:\te8 06 07 00 00 call 80494fc \u0026lt;explode_bomb\u0026gt; 8048df6:\t43 inc ebx 8048df7:\t83 fb 05 cmp ebx,0x5 8048dfa:\t7e ea jle 8048de6 \u0026lt;phase_6+0x4e\u0026gt; ; 结束内层循环 8048dfc:\t47 inc edi 8048dfd:\t83 ff 05 cmp edi,0x5 8048e00:\t7e be jle 8048dc0 \u0026lt;phase_6+0x28\u0026gt; ; 结束循环 至此可以得出初步结论，第一个数字一定不大于 6 ，而且任意两个数字不相等\n碰到第二个循环：\n; E = D; ; for (int i = 0, p = C; i \u0026lt;= 5; ++i) { ; j = 1; ; while (j \u0026lt; A[i]) { ; p = p-\u0026gt;next; ; j++; ; } ; E[i] = p; ; } ; edi \u0026lt;- 0 不妨令其为 i 8048e02:\t31 ff xor edi,edi ; ecx \u0026lt;- A 8048e04:\t8d 4d e8 lea ecx,[ebp-0x18] ; 不妨令该局部变量为数组 D 8048e07:\t8d 45 d0 lea eax,[ebp-0x30] ; 不妨令该局部变量为指针 E ; E \u0026lt;- D 8048e0a:\t89 45 c4 mov DWORD PTR [ebp-0x3c],eax 8048e0d:\t8d 76 00 lea esi,[esi+0x0] ; 循环 6 次 ; esi \u0026lt;- C 不妨令其为指针 p ; C 初值为 0x804b26c 8048e10:\t8b 75 cc mov esi,DWORD PTR [ebp-0x34] ; ebx \u0026lt;- 1 不妨令其为 j 8048e13:\tbb 01 00 00 00 mov ebx,0x1 8048e18:\t8d 04 bd 00 00 00 00 lea eax,[edi*4+0x0] 8048e1f:\t89 c2 mov edx,eax ; 将 j 与 A[i] 比较 8048e21:\t3b 1c 08 cmp ebx,DWORD PTR [eax+ecx*1] 8048e24:\t7d 12 jge 8048e38 \u0026lt;phase_6+0xa0\u0026gt; ; 如果小于则执行下面这段 ; eax \u0026lt;- A[i] 8048e26:\t8b 04 0a mov eax,DWORD PTR [edx+ecx*1] 8048e29:\t8d b4 26 00 00 00 00 lea esi,[esi+eiz*1+0x0] ; 内层循环 ; 感觉是一个链表结构 ; 猜测偏移为 0x8 的位置是 next 字段 ; p \u0026lt;- p-\u0026gt;next 8048e30:\t8b 76 08 mov esi,DWORD PTR [esi+0x8] ; j++ 8048e33:\t43 inc ebx ; while (j \u0026lt; A[i]) 8048e34:\t39 c3 cmp ebx,eax 8048e36:\t7c f8 jl 8048e30 \u0026lt;phase_6+0x98\u0026gt; ; 结束内层循环 ; edx \u0026lt;- E 8048e38:\t8b 55 c4 mov edx,DWORD PTR [ebp-0x3c] ; E[i] \u0026lt;- p 8048e3b:\t89 34 ba mov DWORD PTR [edx+edi*4],esi ; i++ 8048e3e:\t47 inc edi ; while (i \u0026lt;= 5) 8048e3f:\t83 ff 05 cmp edi,0x5 8048e42:\t7e cc jle 8048e10 \u0026lt;phase_6+0x78\u0026gt; ; 结束循环 使用 GDB 查看一下那个神秘地址果然有了收获：\n(gdb) x/3x 0x804b26c 0x804b26c \u0026lt;node1\u0026gt;:\t0x000000fd\t0x00000001\t0x0804b260 (gdb) x/3x 0x804b260 0x804b260 \u0026lt;node2\u0026gt;:\t0x000002d5\t0x00000002\t0x0804b254 (gdb) x/3x 0x804b254 0x804b254 \u0026lt;node3\u0026gt;:\t0x0000012d\t0x00000003\t0x0804b248 (gdb) x/3x 0x804b248 0x804b248 \u0026lt;node4\u0026gt;:\t0x000003e5\t0x00000004\t0x0804b23c (gdb) x/3x 0x804b23c 0x804b23c \u0026lt;node5\u0026gt;:\t0x000000d4\t0x00000005\t0x0804b230 (gdb) x/3x 0x804b230 0x804b230 \u0026lt;node6\u0026gt;:\t0x000001b0\t0x00000006\t0x00000000 一共有六个节点 猜测三个字段分别为：value, id, next\n碰到第三个循环：\n; p = D; ; C = D; ; for (int i = 1; i \u0026lt;= 5; ++i) { ; p-\u0026gt;next = D[i]; ; p = p-\u0026gt;next; ; } ; esi \u0026lt;- D 不妨令其为指针 p 8048e44:\t8b 75 d0 mov esi,DWORD PTR [ebp-0x30] ; C \u0026lt;- D 8048e47:\t89 75 cc mov DWORD PTR [ebp-0x34],esi ; edi \u0026lt;- 1 令其为 i 8048e4a:\tbf 01 00 00 00 mov edi,0x1 ; edx \u0026lt;- D 8048e4f:\t8d 55 d0 lea edx,[ebp-0x30] ; 循环 6 次 ; eax \u0026lt;- D[i] 8048e52:\t8b 04 ba mov eax,DWORD PTR [edx+edi*4] ; p-\u0026gt;next \u0026lt;- D[i] 8048e55:\t89 46 08 mov DWORD PTR [esi+0x8],eax ; p \u0026lt;- p-\u0026gt;next 8048e58:\t89 c6 mov esi,eax ; i++ 8048e5a:\t47 inc edi ; while (i \u0026lt;= 5) 8048e5b:\t83 ff 05 cmp edi,0x5 8048e5e:\t7e f2 jle 8048e52 \u0026lt;phase_6+0xba\u0026gt; ; 结束循环 ; p-\u0026gt;next = NULL; 8048e60:\tc7 46 08 00 00 00 00 mov DWORD PTR [esi+0x8],0x0 上面这部分代码相当于把数组D串起来变为一个链表。\n碰到第四个循环：\n; p = C; ; for (int i = 0; i \u0026lt;= 4; ++i) { ; if (p-\u0026gt;value \u0026lt; p-\u0026gt;next-\u0026gt;value) ; explode_bomb(); ; p = p-\u0026gt;next; ; i++; ; } ; 数组 D 组成的数列应该递减 ; 所以我们可以将 6 个 node 排序 ; 从大到小：node4 node2 node 6 node3 node1 node5 8048e67:\t8b 75 cc mov esi,DWORD PTR [ebp-0x34] 8048e6a:\t31 ff xor edi,edi 8048e6c:\t8d 74 26 00 lea esi,[esi+eiz*1+0x0] ; 循环 5 次 ; edx \u0026lt;- p-\u0026gt;next 8048e70:\t8b 56 08 mov edx,DWORD PTR [esi+0x8] ; eax \u0026lt;- p-\u0026gt;value 8048e73:\t8b 06 mov eax,DWORD PTR [esi] ; 将 p-\u0026gt;value 和 p-\u0026gt;next-\u0026gt;value 比较 ; 即如果小于，则爆炸 8048e75:\t3b 02 cmp eax,DWORD PTR [edx] 8048e77:\t7d 05 jge 8048e7e \u0026lt;phase_6+0xe6\u0026gt; 8048e79:\te8 7e 06 00 00 call 80494fc \u0026lt;explode_bomb\u0026gt; ; p \u0026lt;- p-\u0026gt;next 8048e7e:\t8b 76 08 mov esi,DWORD PTR [esi+0x8] ; i++ 8048e81:\t47 inc edi ; while (i \u0026lt;= 4) 8048e82:\t83 ff 04 cmp edi,0x4 8048e85:\t7e e9 jle 8048e70 \u0026lt;phase_6+0xd8\u0026gt; ; 结束循环 由于从大到小是node4, node2, node6, node3, node1, node5。\n输入字符串4 2 6 3 1 5便能通过这关。\nsecret_phase 其实在 6 关之后还有一个隐藏关卡，需要一定的条件触发。\n可以直接在bomb.disas里面查找函数secret_phase，然后可以发现它在函数phase_defused中被调用。\n首先在phase_6打上断点，发现在phase_defused中发现有怪异之处：\n8049543:\t50 push eax ; 格式化字符串 ; (gdb) x/s 0x8049d03 ; 0x8049d03:\t\u0026#34;%d %s\u0026#34; 8049544:\t68 03 9d 04 08 push 0x8049d03 ; 没有解锁隐藏关卡时，输入字符串只有一个 9 ，这与两个占位符的不相符 ; 所以我们应该在 9 后面补上一个字符串 ; 在 phase_6 打上断点 ; (gdb) break phase_6 ; (gdb) run ; (gdb) x/s 0x804b770 ; 0x804b770 \u0026lt;input_strings+240\u0026gt;:\t\u0026#34;9\u0026#34; 8049549:\t68 70 b7 04 08 push 0x804b770 804954e:\te8 0d f3 ff ff call 8048860 \u0026lt;sscanf@plt\u0026gt; 8049553:\t83 c4 10 add esp,0x10 发现这里有个用于调试的标签input_strings，我们可以看看input_strings +0 +80 +160 都是什么：\n(gdb) x/s 0x804b770-240 0x804b680 \u0026lt;input_strings\u0026gt;:\t\u0026#34;Public speaking is very easy.\u0026#34; (gdb) x/s 0x804b770-240+80 0x804b6d0 \u0026lt;input_strings+80\u0026gt;:\t\u0026#34;1 2 6 24 120 720\u0026#34; (gdb) x/s 0x804b770-240+160 0x804b720 \u0026lt;input_strings+160\u0026gt;:\t\u0026#34;0 q 777\u0026#34; 发现是前三关输入的字符，所以\u0026quot;9\u0026quot;对应的是我们第四关的输入\n; 如果成功给两个参数赋值 8049556:\t83 f8 02 cmp eax,0x2 8049559:\t75 37 jne 8049592 \u0026lt;phase_defused+0x66\u0026gt; 804955b:\t83 c4 f8 add esp,0xfffffff8 ; 字符串比对 ; (gdb) x/s 0x8049d09 ; 0x8049d09:\t\u0026#34;austinpowers\u0026#34; ; 可以得知第四关时后面应该添加一个\u0026#34;austinpowers\u0026#34; ; 由此可以进入隐藏关卡 ...... 804958d:\te8 56 f9 ff ff call 8048ee8 \u0026lt;secret_phase\u0026gt; 现在我们开始看函数secret_phase：\n08048ee8 \u0026lt;secret_phase\u0026gt;: 8048ee8:\t55 push ebp 8048ee9:\t89 e5 mov ebp,esp 8048eeb:\t83 ec 14 sub esp,0x14 8048eee:\t53 push ebx ; 将输入的字符串转换为数字 ; 返回值在 eax 8048eef:\te8 08 03 00 00 call 80491fc \u0026lt;read_line\u0026gt; 8048ef4:\t6a 00 push 0x0 8048ef6:\t6a 0a push 0xa 8048ef8:\t6a 00 push 0x0 8048efa:\t50 push eax 8048efb:\te8 f0 f8 ff ff call 80487f0 \u0026lt;__strtol_internal@plt\u0026gt; 8048f00:\t83 c4 10 add esp,0x10 8048f03:\t89 c3 mov ebx,eax 8048f05:\t8d 43 ff lea eax,[ebx-0x1] ; 如果 input-1 大于 0x3e8 则爆炸 8048f08:\t3d e8 03 00 00 cmp eax,0x3e8 8048f0d:\t76 05 jbe 8048f14 \u0026lt;secret_phase+0x2c\u0026gt; 8048f0f:\te8 e8 05 00 00 call 80494fc \u0026lt;explode_bomb\u0026gt; 8048f14:\t83 c4 f8 add esp,0xfffffff8 8048f17:\t53 push ebx ; 该地址可能指向一个数组或者结构 8048f18:\t68 20 b3 04 08 push 0x804b320 8048f1d:\te8 72 ff ff ff call 8048e94 \u0026lt;fun7\u0026gt; 8048f22:\t83 c4 10 add esp,0x10 ; 如果返回值为 7 则成功 8048f25:\t83 f8 07 cmp eax,0x7 8048f28:\t74 05 je 8048f2f \u0026lt;secret_phase+0x47\u0026gt; ...... 由于调用了函数fun7，我们直接来看它。func7是一个比较简单的递归函数，主要是结构体较为复杂：\n08048e94 \u0026lt;fun7\u0026gt;: 8048e94:\t55 push ebp 8048e95:\t89 e5 mov ebp,esp 8048e97:\t83 ec 08 sub esp,0x8 8048e9a:\t8b 55 08 mov edx,DWORD PTR [ebp+0x8] 8048e9d:\t8b 45 0c mov eax,DWORD PTR [ebp+0xc] 8048ea0:\t85 d2 test edx,edx 8048ea2:\t75 0c jne 8048eb0 \u0026lt;fun7+0x1c\u0026gt; 8048ea4:\tb8 ff ff ff ff mov eax,0xffffffff 8048ea9:\teb 37 jmp 8048ee2 \u0026lt;fun7+0x4e\u0026gt; 8048eab:\t90 nop 8048eac:\t8d 74 26 00 lea esi,[esi+eiz*1+0x0] 8048eb0:\t3b 02 cmp eax,DWORD PTR [edx] 8048eb2:\t7d 11 jge 8048ec5 \u0026lt;fun7+0x31\u0026gt; 8048eb4:\t83 c4 f8 add esp,0xfffffff8 8048eb7:\t50 push eax ; 类似链表的结构 8048eb8:\t8b 42 04 mov eax,DWORD PTR [edx+0x4] 8048ebb:\t50 push eax 8048ebc:\te8 d3 ff ff ff call 8048e94 \u0026lt;fun7\u0026gt; 8048ec1:\t01 c0 add eax,eax 8048ec3:\teb 1d jmp 8048ee2 \u0026lt;fun7+0x4e\u0026gt; 8048ec5:\t3b 02 cmp eax,DWORD PTR [edx] 8048ec7:\t74 17 je 8048ee0 \u0026lt;fun7+0x4c\u0026gt; 8048ec9:\t83 c4 f8 add esp,0xfffffff8 8048ecc:\t50 push eax ; 类似链表的结构 8048ecd:\t8b 42 08 mov eax,DWORD PTR [edx+0x8] 8048ed0:\t50 push eax 8048ed1:\te8 be ff ff ff call 8048e94 \u0026lt;fun7\u0026gt; 8048ed6:\t01 c0 add eax,eax 8048ed8:\t40 inc eax 8048ed9:\teb 07 jmp 8048ee2 \u0026lt;fun7+0x4e\u0026gt; 8048edb:\t90 nop 8048edc:\t8d 74 26 00 lea esi,[esi+eiz*1+0x0] 8048ee0:\t31 c0 xor eax,eax 8048ee2:\t89 ec mov esp,ebp 8048ee4:\t5d pop ebp 8048ee5:\tc3 ret 8048ee6:\t89 f6 mov esi,esi 可以看到有类似链表的结构，但是它拥有两个指针域，我们可以把它想象为一棵树：\n// fun7 输入参数：指针 p 和 整型 n // p 可以理解为二叉树的节点 typedef struct TreeNode { int value; struct TreeNode *left; struct TreeNode *right; } TreeNode; 这样一来fun7马上可以写成 C 语言：\nint fun7(TreeNode *p, int n) { if (p == 0) { return -1; } else { if (n-\u0026gt;value \u0026lt; p[0]) { return 2 * fun7(p-\u0026gt;left, n); } else if (n == p[0]) { return 0; } else { return 2 * fun7(p-\u0026gt;right, n) + 1; } } } 由于需要递归函数返回 7 (参数(p, n))，所以内一层只能返回 3 (参数(p-\u0026gt;right, n))， 再内一层只能返回 1 (p-\u0026gt;right-\u0026gt;right, n)，最里面一层返回 0 (p-\u0026gt;right-\u0026gt;right-\u0026gt;right, n)。 所以第一次调用时p-\u0026gt;righ-\u0026gt;right-\u0026gt;right-\u0026gt;value应该与n相等\n可以通过 GDB 很快找到：\n# value left right (gdb) x/3x 0x804b320 0x804b320 \u0026lt;n1\u0026gt;: 0x00000024 0x0804b314 0x0804b308 (gdb) x/3x 0x0804b308 0x804b308 \u0026lt;n22\u0026gt;: 0x00000032 0x0804b2f0 0x0804b2d8 (gdb) x/3x 0x0804b2d8 0x804b2d8 \u0026lt;n34\u0026gt;: 0x0000006b 0x0804b2b4 0x0804b278 (gdb) x/3x 0x0804b278 0x804b278 \u0026lt;n48\u0026gt;: 0x000003e9 0x00000000 0x00000000 所以应该输入3e9也就是十进制1001。\n输入文件 如下是最后通过测试的输入文件：\n$ cat input Public speaking is very easy. 1 2 6 24 120 720 0 q 777 9 austinpowers o`ekma 4 2 6 3 1 5 1001 实验感受 这六关分别涉及了字符串常量、循环、switch-case（跳转表）、递归、数组、链表等知识，难度没有想象中那么大，耐心看汇编代码其实是很容易看懂的。而隐藏关卡需要细心或者运气发现，但是解决它并不是问题。\n做 Lab 时没有动态调试这个程序，感觉也没有动态调试的必要，只要看到了“魔法”地址就可以直接 GDB 查看它。\n","permalink":"https://vaaandark.top/posts/csapp-bomb-lab/","summary":"\u003cp\u003e之前的 Bomb Lab 没有做，现在刚好在上计算机系统基础这门课，学校使用了 CSAPP 的 Bomb Lab ，可以补交一下 CSAPP 的作业，也可以学习一下 GDB 的使用。\u003c/p\u003e\n\u003ch2 id=\"实验简述\"\u003e实验简述\u003c/h2\u003e\n\u003cp\u003e遗憾地，CSAPP 的 Bomb Lab 早已提供的是 Linux 的 64 位可执行程序，而我校的 Lab 还是 32 位的 Windows PE32 。不过我还是找老师要到了它的 Linux 版本，不过也是 ELF32 ，可执行文件的名字叫\u003ccode\u003ebomb_32\u003c/code\u003e。\u003c/p\u003e","title":"CSAPP Bomb Lab"},{"content":"最近在学习汇编语言，和朋友聊天时聊到了 C 语言中的变长数组，想知道在汇编后是什么样子的。\n变长数组(Variable-length array) 可变长数组是指在计算机程序设计中，数组对象的长度在运行时（而不是编译时）确定。\nC/C++的灵活数组类型（又称柔性数组成员）是另外一个语言特性。\n反汇编 VLA C 语言代码：\n#include \u0026lt;stdio.h\u0026gt; int main(void) { int n; int a[n]; return 0; } 反汇编代码：\n... mov eax,DWORD PTR [ebp-0x14] ; eax \u0026lt;- [n] lea edx,[eax-0x1] ; edx \u0026lt;- [n - 1] mov DWORD PTR [ebp-0xc],edx ; [n - 8] \u0026lt;- edx lea edx,[eax*4+0x0] ; edx \u0026lt;- [n * 4 + 0] VLA 的长度 mov eax,0x10 ; eax \u0026lt;- 16 sub eax,0x1 ; eax -= 1 =\u0026gt; eax = 15 add eax,edx ; eax += edx =\u0026gt; eax = 15 + nbytes mov ecx,0x10 ; ecx \u0026lt;- 16 mov edx,0x0 ; edx \u0026lt;- 0 div ecx ; eax /= 16 imul eax,eax,0x10 ; eax *= 16 ; (15 + nbytes) / 16 * 16 用于对齐 ; 因此上面几条指令没有抵消 sub esp,eax ; esp -= eax 在栈中为 VLA 预留空间 mov eax,esp ; eax \u0026lt;- esp VLA 的地址 add eax,0x3 ; eax += 3 =\u0026gt; eax = 18 + nbytes shr eax,0x2 ; eax \u0026gt;\u0026gt;= 2 shl eax,0x2 ; eax \u0026lt;\u0026lt;= 2 ; (eax + 3) / 2 * 2 用于对齐 ; 因此上面几条指令没有抵消 mov DWORD PTR [ebp-0x10],eax ; [n + 4] \u0026lt;- eax 给 a 赋上 VLA 的地址 ... 因此在创建 VLA 时先在栈上分配内存同时要注意对齐，再将分配好的内存地址赋值给数组。\n与直接创建在栈上的定长数组不同，变长数组访问元素时需要两次寻址。\n","permalink":"https://vaaandark.top/posts/dive-in-vla/","summary":"\u003cp\u003e最近在学习汇编语言，和朋友聊天时聊到了 C 语言中的变长数组，想知道在汇编后是什么样子的。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"变长数组variable-length-array\"\u003e变长数组(Variable-length array)\u003c/h2\u003e\n\u003cp\u003e可变长数组是指在计算机程序设计中，数组对象的长度在运行时（而不是编译时）确定。\u003c/p\u003e","title":"稍微深入VLA"},{"content":"汇编语言学习笔记\n预备知识 Intel 机器 微型计算机的构成 80X86 微处理器的基本结构 数据寄存器组\n段寄存器组\n80X86 的三种工作方式 实地址模式 保护模式 虚拟 8086 方式（V86方式） 数据在计算机内的表示形式 有符号数、无符号数、浮点数等相关知识见 CSAPP\nBCD 码 使用二进制数表示十进制数，即使用 4 位二进制数表示一位 10 进制数。\n在 8086 中有两种存放 BCD 码的方式，压缩和非压缩。\n标志寄存器 主要需要掌握 SF ZF OF CF AF PF\n寻址方式 寄存器寻址 使用格式：R\ninc bx 操作数地址为寄存器 BX 。\n寄存器间接寻址 使用格式：[R]\n寄存器 R 的内容为操作数的偏移地址。\n可以指明操作数所在的段，如ss:[R]。如果没有指定段，当 R 选用 BP, EBP, ESP ，则默认在堆栈段中，如果选用其他寄存器则默认在 DS 所指示的段中。\nmov ax, [si] 将数据段上偏移[si]的数据传送到 AX 中。\n变址寻址 使用格式：[R * F + V], [R * F] + V, V[R * F]\n功能：寄存器 R 的内容乘以指定的比例因子 F （可以为 1, 2, 4, 8）后加上给定的位移量 V 作为操作数的偏移地址。\n当 R 为 16 为寄存器或 ESP 时，F 只能为 1 并省略不写。\nmov al, [ebx * 2] + 5 由于使用的变址寄存器是 EBX ，故默认段寄存器 DS 。\n基址加变址寻址 使用格式：[BR + IR * F + V], V[BR][IR * F], V[BR + IR * F]\n功能：将变址寄存器 IR 的内容乘以比例因子 F ，与基址寄存器 BR 的内容和位移量 V 相加，作为操作数的偏移地址 EA 。\nmov ax, 8[bx][si]\n立即寻址 使用格式：n\n功能：指定指令最后一部分单元中的内容为操作数，即在当前执行到的机器代码部分找到操作数。\nmov word ptr [si], 12h WORD PTR 说明操作数的类型为字。\n直接寻址 使用格式：段寄存器名: [n], 变量, 变量 + 常量\n一些问题 有一些指令显式地指定操作数，另一些隐含地指定操作数。如CBW将 AL 寄存器中的符号位扩展到 AH 中，又如push bufa压入栈顶，隐含了目的操作数，是使用 SP/ESP 的寄存器间接寻址方式。\n双操作数指令的源操作数和目的操作数的寻址方式必须满足以下五种组合之一：\n寄存器对寄存器； 寄存器对存储器； 存储器对寄存器； 立即方式对寄存器，立即方式只能用于源操作数； 立即方式对存储器，立即方式只能用于源操作数； 源操作数和目的操作数不能同时用存储器方式表示。\n不含变量的存储器方式所表示的操作数类型是不明确的，立即数是没有类型的。如果指令语句中没有一个操作数的类型是明确的，则必须使用属性定义算符 PTR（字节类型 BYTE PTR ，字类型 WORD PTR ，双字类型 DWORD PTR）\n下面几种情况使用的缺省段不受段超越前缀影响：\n取指令（包括立即数）时只能使用 CS 段； 压栈时目的地址和出栈时源地址只能使用 SS 段； 串操作指令中的目的串只使用 ES 段； 宏汇编语言 ","permalink":"https://vaaandark.top/posts/80x86-learning/","summary":"\u003cp\u003e汇编语言学习笔记\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"预备知识\"\u003e预备知识\u003c/h2\u003e\n\u003ch3 id=\"intel-机器\"\u003eIntel 机器\u003c/h3\u003e\n\u003ch4 id=\"微型计算机的构成\"\u003e微型计算机的构成\u003c/h4\u003e\n\u003cp\u003e\u003cimg alt=\"微型计算机的构成\" loading=\"lazy\" src=\"/image/asm-intel-x86.png\"\u003e\u003c/p\u003e\n\u003ch4 id=\"80x86-微处理器的基本结构\"\u003e80X86 微处理器的基本结构\u003c/h4\u003e\n\u003cp\u003e\u003cimg alt=\"80X86微处理器的基本结构\" loading=\"lazy\" src=\"/image/asm-80x86.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e数据寄存器组\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"数据寄存器组\" loading=\"lazy\" src=\"/image/asm-data-registers.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e段寄存器组\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"段寄存器组\" loading=\"lazy\" src=\"/image/asm-seg-registers.png\"\u003e\u003c/p\u003e\n\u003ch4 id=\"80x86-的三种工作方式\"\u003e80X86 的三种工作方式\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e实地址模式\u003c/li\u003e\n\u003cli\u003e保护模式\u003c/li\u003e\n\u003cli\u003e虚拟 8086 方式（V86方式）\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"数据在计算机内的表示形式\"\u003e数据在计算机内的表示形式\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e有符号数、无符号数、浮点数等相关知识见 CSAPP\u003c/p\u003e","title":"80X86汇编语言学习"},{"content":"之前学习了 Lua 的 Table 和协程，对 Lua 中另一个重要模块 GC 还有很多疑问，这次就来学习一下。\nGC 简介与策略分类 在计算机科学中，垃圾收集(GC)是一种自动内存管理形式。垃圾收集器尝试回收程序分配但不再引用的内存；这样的内存被称为垃圾。\n追踪(Tracing) Tracing 的策略简单讲就是使用一些根对象来遍历所有的引用，可以访问到的就不是垃圾，不能访问到的就是需要回收的垃圾。虽然这个说起来和实现起来很简单，但是想要使其有较好的性能并不是一件很容易的事情。Tracing 有很多需要考虑的问题，例如收集的周期(步进 Pace)是什么，是按照时间片还是按照已经分配过的内存，是否会出现为了收集垃圾程序执行出现明显卡死现象等。\n之后用到的 Lisp 和 Lua 的例子都以 Tracing 策略为主。\n引用计数(Reference counting) 引用计数垃圾收集是每个对象都有一个对它的引用数的计数。垃圾通过引用计数为零来标识。对象的引用计数在创建对它的引用时增加，在引用被销毁时减少。当计数达到零时，对象的内存被回收。\n循环引用 如果有两个对象相互引用，就会导致它们的引用计数永远大于等于 1 ，它们永远不会被回收。对于这个问题，一般有两种解决方案。一种比较直观，直接检测是否出现循环，cpython 就使用的这种方法；另一种就是引入弱引用的概念。\n弱引用不会增加引用计数，而且指向的对象可能是已经被回收的，因此可以简单地检测出是否失效，而不是保持引用悬垂。\n额外空间开销 明显地，如果使用引用计数的策略就需要额外的空间来存储计数。有的是存在对象中，有的是存在一个表之中。在一些语言例如 objective-c 中，它们将引用计数存在指针地址未使用的位当中（我认为这对不同处理器间可移植性有影响）。\n额外时间开销 例如如果使用for item in something的方法遍历，在每个循环开始都有rc++每个结尾都有rc--，优秀的 GC 应该把这个消除掉。\n并行 如果需要编写并行代码则需让 rc 的操作具有原子性，最重要的一点是它们不可以是全局变量了。\n自动引用计数(Automatic Reference counting) 自动引用计数无需运行时，会在编译阶段处理引用计数并实现内存管理，但是难以处理循环引用的问题。神奇的 Rust 较好地解决了这个问题，方法还是使用弱引用，可以看 Arc 的实现：\nBreaking cycles with Weak\nThe downgrade method can be used to create a non-owning Weak pointer. A Weak pointer can be upgraded to an Arc, but this will return None if the value stored in the allocation has already been dropped. In other words, Weak pointers do not keep the value inside the allocation alive; however, they do keep the allocation (the backing store for the value) alive.\nA cycle between Arc pointers will never be deallocated. For this reason, Weak is used to break cycles. For example, a tree could have strong Arc pointers from parent nodes to children, and Weak pointers from children back to their parents.\n不过，无论是朴素的引用计数还是自动引用计数，一旦引入弱引用就可能增加代码编写者的心智负担和精神内耗，让垃圾回收没有那么省心省力。\n逃逸分析(Escape analysis) 这个比较好理解，它的原理就是将一些不必要的堆分配变成栈分配，例如在一个函数之中，如果一个对象不会被传递到外部，Escape analysis 就可以将它从堆分配变为栈分配从而减少所需要的垃圾收集量。\nulisp GC 这是一种很 naive 的 GC ，采用的是最为朴素的 mark-and-sweep 中的双色标记法。\n首先调用 markobject() 函数对所有还能够访问的对象进行标记\nulisp 是一种广泛用于嵌入式的 lisp 方言\nvoid markobject (object *obj) { MARK: if (obj == NULL) return; if (marked(obj)) return; object* arg = car(obj); unsigned int type = obj-\u0026gt;type; mark(obj); if (type \u0026gt;= PAIR || type == ZERO) { // cons markobject(arg); obj = cdr(obj); goto MARK; } } 这里的 cons 是一种广义表，由两个指针组成，car 提取第一个指针，cdr 提取第二个指针。上面这个函数用了一种不够美观的方式消除了部分递归。\n这里的 mark(x) 宏利用内存对齐使用了一个技巧：\n#define mark(x) (car(x) = (object *)(((unsigned int)(car(x))) | 0x0001)) 因为内存对齐到偶数位，所以最低位为 0 ，将 car(x) 的最低位置为 1 的标记操作是合理的，而且节约了内存。\nsweep() 函数则用于清理对象。\nvoid sweep () { Freelist = NULL; Freespace = 0; for (int i=WORKSPACESIZE-1; i\u0026gt;=0; i--) { object *obj = \u0026amp;Workspace[i]; if (!marked(obj)) myfree(obj); else unmark(obj); } } inline void myfree (object *obj) { car(obj) = NULL; cdr(obj) = Freelist; Freelist = obj; Freespace++; } 这里的清理没有使用 free 等库函数是因为 ulisp 一般用于嵌入式环境中，它的内存管理就是管理一个保存对象地址的静态大数组，全局变量 Freelist 指向数组第一个为空的地方，Freespace 表示还剩余多少空间。\nulisp 的 gc 周期设置也比较朴素，每次 eval 被调用时检测一下剩余内存空间，如果小于 20 个对象的大小就垃圾收集。\nif (Freespace \u0026lt; 20) gc(form, env); Lua GC Lua GC 也采用了 mark-and-sweep 的策略，但是它使用的不再是双色标记，而是更加优秀的三色标记法。\nLua 5.0 之前使用的是双色标记法，和 ulisp 大同小异。\nLua GC 规则 Lua 中所有对象需要垃圾回收，包括了 table 、函数、协程、模组。 只有通过根集(root set)可以访问到的对象才会被保存。 root set ::= registry + shared metatables registry ::= global table(_G) + main thread + package.loaded Lua 垃圾收集调用的是标准库内存分配函数（其实整个 Lua 都只用了标准库）。 所有的对象都被一个链表储存。 Lua GC Pace 如果 GC 从不运行就没有消耗额外的 CPU 周期，但是会浪费大量内存；如果 GC 一直运行就不会浪费额外的内存，但是会消耗大量 CPU 周期。因此我们需要找到一个合适的 GC 运行间隔。\nLua 5.0 采取的方法是当此次内存分配达到上次内存分配的两倍时调用 GC 。但这就造成了一个问题，虚拟机会停下来收集完垃圾再继续执行(stop the world)，这也就是 Lua 5.0 及之前都只能作为小小胶水语言使用的原因。\n增量收集 在 5.1 版本中，Lua 有了一个增量收集器，将收集器的执行与主程序交错执行。这也导致 GC 内保存的不再是一个可以直接分析的静态数据，必须引入三色标记。\n三色标记法 采用了一种三色标记的算法。每个对象都有三个状态：无法被访问到的对象是白色，可访问到，但没有递归扫描完全的对象是灰色，完全扫描过的对象是黑色。理想状况下，GC 只需要充分遍历灰色对象就可以完成收集。\nMutator 导致的问题 考虑一种情况，一个变量 x 已经被标记为黑色，但是解释执行x.a = {}，很明显{}是一个白色对象，这就形成了黑色对象指向白色对象的问题（导致这个问题的原因是对象的可变性）。此时我们不得不改变 x 的颜色，给死去的变量打复活赛。\n这时是将 {} 改变为灰色，还是把 x 变成灰色是个问题，刚好 Lua 提供了这两个接口：\nLUAI_FUNC void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v); LUAI_FUNC void luaC_barrierback_ (lua_State *L, GCObject *o); 何时使用何种方法其实是看设计者的经验。\n在刚刚说的这种情况中，Lua 采用的是将 x 变为灰色的方法，因为给一个 table 中的字段赋值说明这个 table 很有可能还要被复用；而在 metatable 中遇到这种情况就采取的是另一种方法。\n分代式 GC 想象一个场景，我们在代码的某处（甚至可以想象就是代码开头）使用了一个巨大的矩阵，之后再也没有比它更大的内存分配了，那么 Lua 5.1 的 GC 可能只会运行一次。\n因此基于假设大部分对象在创建出来后不久就被回收掉(most objects die young)的假设，Lua 5.2 设计了分代式 GC ，并在 5.4 中完善。\nOld and Young 所有的对象被划分为年轻的(young)和年老的(old)：对象刚被创建时是年轻的，当存活过两轮垃圾收集则变为年老的。在每次次级垃圾收集中，GC 只遍历并清除年轻的变量。\n注意在分代中的重要规则：老对象不能指向新对象。因此遇到这种情况时，如果我们将新对象变为老对象(forward)就可能出现大量的老对象，让分代式退化到原来的版本；如果我们将老对象变为新对象(backward)，就可能在别的地方破坏规则（例如这个老对象被别的对象引用）。\nThe Touched Objects 为了解决上述的问题，Lua 引入了被触碰过的对象这一概念，在刚刚的情景下，老对象会被标记为被触碰过的对象并被放入一个特殊的列表中。\n在每次次级垃圾收集中，被触碰过的变量会被遍历，但不会被收集（可能会收集它们指向的新对象）。\n在经历两次垃圾收集（非次级）后，被触碰过的变量指向的子对象都变成老对象了，因此他们也会恢复成为老对象。\nLua 5.2 分代的问题 在 Lua 5.3 的设计中，一个新对象经历一次收集而不被回收就会成为老对象。如果它刚好在一次回收前被创建而且本应该在那次回收之后不久被回收，本不应该成为老对象的它就会成为老对象。\n过多的老对象就导致 5.2 的性能堪忧。\nuserdata 导致的问题 由于 Lua 是一种可以与 C 互相嵌入的语言，因此不可避免地会使用到 C 中的数据结构(userdata)，但又由于 Lua 支持给 userdata 定义 __gc 方法，故要区分有无 __gc 方法的 userdata 。\n标记流程要分为两步，先是把包括 userdata 的死对象标记，再将 userdata 中有 __gc 方法的复活，让它们在下一轮被收集。\n参考资料 ulisp Rust Arc wikipedia 云风的BLOG Lua 之父的演讲ppt ","permalink":"https://vaaandark.top/posts/gc/","summary":"\u003cp\u003e之前学习了 Lua 的 Table 和协程，对 Lua 中另一个重要模块 GC 还有很多疑问，这次就来学习一下。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"gc-简介与策略分类\"\u003eGC 简介与策略分类\u003c/h2\u003e\n\u003cp\u003e在计算机科学中，垃圾收集(GC)是一种自动内存管理形式。垃圾收集器尝试回收程序分配但不再引用的内存；这样的内存被称为垃圾。\u003c/p\u003e","title":"垃圾回收"},{"content":"正在上计算机系统基础，目前主要是在讲汇编语言，使用的开发环境自然是又老又臭的 DOS 加上 MASM 。之前我看到过 FreeDOS 这个自由的 DOS 发行版，打算试吃一下，之后的汇编实验也将在这上面进行。\n安装与配置 首先在FreeDOS 官网上下载最新的系统镜像，我选择的是 FreeDOS 1.3 LiveCD 。下载之后将其解压到一个文件夹内，有三个文件。 % ls FD13BOOT.img FD13LIVE.iso readme.txt 再使用虚拟机安装 FreeDOS ， % qemu-img create freedos.img 500M # 创建 QEMU 的虚拟磁盘 % qemu-system-i386 -m 32M -drive file=freedos.img,media=disk,format=raw -drive file=FD13LIVE.iso,media=cdrom -boot order=d # 启动镜像 之后就是和安装 Linux 发行版大同小异的操作了。\n挂载虚拟磁盘到 Host 。 % sudo mkdir -p /mnt/freedos % sudo mount -t msdos -o uid=1000,loop,offset=32256 freedos.img /mnt/freedos 安装 MASM ，可以直接将文件放置到挂载的地方，重启 FreeDOS 后就可以使用了。使用时不再需要 LiveCD 的镜像： % qemu-system-i386 -m 32M -drive file=freedos.img,media=disk,format=raw -boot order=d 疑惑 可能是 FreeDOS 文件系统，也可能是 qemu 的缓存问题，我在 Host 对文件的操作只有在重启 FreeDOS 之后才会在 guest 中生效。\n在这个帖子中也有人遇到了这个问题：\nHowever, it\u0026rsquo;s limited to 512MB, and doesn\u0026rsquo;t reflect any changes made to the directory from the host system after QEMU starts.\n另一个帖子也有人提到：\nYou should never write to the FAT directory on the host system while accessing it with the guest system. If want to add new files to \u0026lsquo;share\u0026rsquo;, shutdown the virtual machine before.\n打算有时间看一下QEMU 的 FAT 文档\n","permalink":"https://vaaandark.top/posts/freedos-and-masm-environment/","summary":"\u003cp\u003e正在上计算机系统基础，目前主要是在讲汇编语言，使用的开发环境自然是又老又臭的 DOS 加上 MASM 。之前我看到过 FreeDOS 这个自由的 DOS 发行版，打算试吃一下，之后的汇编实验也将在这上面进行。\u003c/p\u003e","title":"FreeDOS和masm开发环境配置"},{"content":"之前学习了如何写 Lua 程序，又因为 NeoVim 的插件可以用 Lua 写，所以想学习一下插件开发。\n插件目录结构 我们的插件应当有至少两个目录：plugin用于放main代码文件，lua放其余的所有代码。当然，如果我们真的想把所有代码放在同一个文件里面，这也是可以的。但是请不要这样。因此，使用plugin/whid.vim和lua/whid.lua这两个文件就可以了。\n\u0026#34; plugin/whid.vim 文件 if exists(\u0026#39;g:loaded_whid\u0026#39;) | finish | endif \u0026#34; 防止插件加载两次 let s:save_cpo = \u0026amp;cpo \u0026#34; 保存用户自定义选项 set cpo\u0026amp;vim \u0026#34; 重置到默认选项 \u0026#34; 运行插件 command! Whid lua require\u0026#39;whid\u0026#39;.whid() let \u0026amp;cpo = s:save_cpo \u0026#34; 恢复用户自定义选项 unlet s:save_cpo let g:loaded_whid = 1 let s:save_cpo = \u0026amp;cpo是防止自定义选项干扰插件的常见做法。依据我们要编写的代码，缺少这一行可能不会有什么坏处，但是这是一种好的习惯（至少根据 Vim 帮助文件是这样）。command! Whid lua require 'whid'.whid()需要插件的 Lua 模块并调用它的主函数。\n浮动窗口 NeoVim 和如今的新版 Vim 都有浮动窗口的特性。\n-- lua/whid.lua 文件 local api = vim.api local buf, win local function open_window() buf = api.nvim_create_buf(false, true) -- 创建一个空缓冲区 api.nvim_buf_set_option(buf, \u0026#39;bufhidden\u0026#39;, \u0026#39;wipe\u0026#39;) -- 获取窗口的行和列 local width = api.nvim_get_option(\u0026#34;columns\u0026#34;) local height = api.nvim_get_option(\u0026#34;lines\u0026#34;) -- 计算出浮动窗口的行和列 local win_height = math.ceil(height * 0.8 - 4) local win_width = math.ceil(width * 0.8) -- 计算出浮动窗口的开始位置 local row = math.ceil((height - win_height) / 2 - 1) local col = math.ceil((width - win_width) / 2) -- 设置选项 local opts = { style = \u0026#34;minimal\u0026#34;, relative = \u0026#34;editor\u0026#34;, width = win_width, height = win_height, row = row, col = col } -- 最后在一个附加的缓冲区创建浮动窗口 win = api.nvim_open_win(buf, true, opts) end nvim_create_buf函数用于创建一个缓冲区，第一个参数是listed第二个参数是scratch，分别被设置成false和true，创建了一个未列出的缓冲区，并且是 throwaway 的（隐藏时将会被删除）。\n使用nvim_open_win可以创建一个新窗口同时也可以将之前创建的buf绑定其上，第二个bool类型参数表示这个窗口是否获得焦点。第三个参数opt是一个表，其中元素width和height的作用不言自明；row和col是窗口的开始位置（编辑器的左上角开始算）。relative=\u0026quot;editor\u0026quot;和style=\u0026quot;minimal\u0026quot;是配置窗口外观的选项，这样设置可以禁用一些不需要的选项，例如行号和拼写错误提示。\n现在我们创建了一个浮动窗口，但是我们可以把它变得更加好看。NeoVim 当前还不支持边框等小部件，但是我们可以自己做出来。这其实相当简单，我们可以弄一个新的窗口，比原来的窗口稍微大一圈，并放置在底部。\nlocal border_opts = { style = \u0026#34;minimal\u0026#34;, relative = \u0026#34;editor\u0026#34;, width = win_width + 2, height = win_height + 2, row = row - 1, col = col - 1 } 我们可以用边框字符让它看起来更好看。\nlocal border_buf = api.nvim_create_buf(false, true) local border_lines = { \u0026#39;╔\u0026#39; .. string.rep(\u0026#39;═\u0026#39;, win_width) .. \u0026#39;╗\u0026#39; } local middle_line = \u0026#39;║\u0026#39; .. string.rep(\u0026#39; \u0026#39;, win_width) .. \u0026#39;║\u0026#39; for i=1, win_height do table.insert(border_lines, middle_line) end table.insert(border_lines, \u0026#39;╚\u0026#39; .. string.rep(\u0026#39;═\u0026#39;, win_width) .. \u0026#39;╝\u0026#39;) api.nvim_buf_set_lines(border_buf, 0, -1, false, border_lines) -- 函数原型为 nvim_buf_set_lines({buffer}, {start}, {end}, {strict_indexing}, {replacement}) -- 设置缓冲区(border_buf)填充范围为第一行(0)到最后一行(-1) -- 忽略越界错误(false)并填充(border_lines) 显然我们必须按照正确的顺序打开窗口，并且一起关闭窗口。当前最好的解决办法是使用viml autocomand。\nlocal border_win = api.nvim_open_win(border_buf, true, border_opts) win = api.nvim_open_win(buf, true, opts) api.nvim_command(\u0026#39;au BufWipeout \u0026lt;buffer\u0026gt; exe \u0026#34;silent bwipeout! \u0026#34;\u0026#39;..border_buf) 获取数据 我们的插件用于展示我们处理过的最新文件。可以使用 git 命令达到这样的效果。\ngit diff-tree --no-commit-id -name-only -r HEAD 创建函数将数据插入到窗口之中。\n用户输入 公共函数 完整代码 参考 How to write neovim plugins in Lua GitHub rafcamlet/nvim-whid ","permalink":"https://vaaandark.top/posts/how-to-write-a-plugin-for-neovim-in-lua/","summary":"\u003cp\u003e之前学习了如何写 Lua 程序，又因为 NeoVim 的插件可以用 Lua 写，所以想学习一下插件开发。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"插件目录结构\"\u003e插件目录结构\u003c/h2\u003e\n\u003cp\u003e我们的插件应当有至少两个目录：\u003ccode\u003eplugin\u003c/code\u003e用于放\u003ccode\u003emain\u003c/code\u003e代码文件，\u003ccode\u003elua\u003c/code\u003e放其余的所有代码。当然，如果我们真的想把所有代码放在同一个文件里面，这也是可以的。但是请不要这样。因此，使用\u003ccode\u003eplugin/whid.vim\u003c/code\u003e和\u003ccode\u003elua/whid.lua\u003c/code\u003e这两个文件就可以了。\u003c/p\u003e","title":"如何使用Lua写一个NeoVim插件"},{"content":"最近何同学和稚晖君都发视频了，巧合的是他们做的项目都是关于键盘的魔改，不过人比人还是气死人嗷。\n何同学本质上走的还是网红甚至说是饭圈路线，并没有很硬的实力，也就导致了大部分理工科的“直男”都会看不起甚至讨厌他。\n而稚晖君就不一样了，他本身并不是一位专职 UP ，他有自己的本职工作，并不需要将流量变现，因此他没有大范围炒作过自己的项目，而且他的视频也不会为了更多的播放量去搞一些所谓的“人文”升华，他自有自己的目标观众。\n我并不知道对何同学冠以赛博丁真的绰号是否有点过了，但我可以确定的是，多一两个能力只够做开箱视频的网红对形成工程师文化是毫无作用的。对于未来真的在工程师岗位上的观众群体来说，何同学的作用最多只是让人批判性地观看。相反地，多几位善于表达、会做出优质视频的真正“天才少年”却是非常难得的事情。\n刚刚说到了工程师文化，可是我们总在说它，它究竟是什么呢？我在知乎上看到了一个很好的定义：一切以解决问题为导向的工作文化。很明显的是，这样的文化可以高质高量地解决问题，也可以提高一线人员的话语权和地位（并不要求一线人员是一位工程师）。一个优秀的一线问题解决者的工资就应该高于中层管理人员（类似于苏联早期公务员的工资不能超过熟练工人）。\n很明显，何同学身上不能体现工程师文化。我们并不要求工程师“讷于言”，他的确可以说得天花乱坠，但是“敏于行”却是必要的。而且，何同学对背后为他解决问题的团队所提甚少，从没有感谢他们的贡献。并且，他所做的东西根本没有解决问题，甚至是为了一个“伪需求”而制造问题。以这次的键盘为例，这么多电机的堆砌，最终的结果就是一个发热惊人的“电老虎”。如果他真的想解决问题，使用热插拔键盘就可以了。一定要做一个可变键程的键盘的话，那他就需要设计专门的控制、电源芯片等。另外说一句，我对键盘的集成度持怀疑态度，怀疑键盘的控制都在桌子下面。总而言之，何同学并不具有作为科技博主的解决问题能力，只有作为数码博主的测评能力。\n再说说我们国家总在说的“工匠精神”。工匠精神固然是好的，但是它的内涵也要跟随时代而变化。以央视纪录片《大国工匠》为例，它总是不自觉地给人一种观点，老师傅就是好的，手工制作就是好的。这种宣传导向真的好吗？我看不一定。能熟练运用机器达到要求的师傅是好师傅吗？年轻的师傅就不是好师傅吗？制造出能代替人工的优秀机器的是好发明家吗？\n很多官媒讲不好故事，这可能是宣传部门与工业界脱节造成的。但受人热捧的是“小丑”讲故事，这是否和整个社会的氛围有关呢？\n知乎问答：工程师文化\n","permalink":"https://vaaandark.top/posts/engineer-and-dingzhen/","summary":"\u003cp\u003e最近何同学和稚晖君都发视频了，巧合的是他们做的项目都是关于键盘的魔改，不过人比人还是气死人嗷。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003cp\u003e何同学本质上走的还是网红甚至说是饭圈路线，并没有很硬的实力，也就导致了大部分理工科的“直男”都会看不起甚至讨厌他。\u003c/p\u003e","title":"工程师文化、工匠精神和赛博丁真"},{"content":"最近看到了一些关于侵入式和非侵入式链表的讨论，决定研究一下它们两个。\n侵入式和非侵入式链表的区别 这里的侵入是相对于链表的指针域来说，所以最主要的区别就是非侵入式的链表容器中保存了一份用户传入的值。\nclass list_node { list_node *next, *previous; MyClass value; }; 可以看到非侵入式的链表在分配节点时要包含指针域和数据域。\n而侵入式链表就不需要保存传递对象的拷贝，而是保存对象本身。对象插入链表中的所需要的附加数据由对象本身提供。\n可以看 Linux 提供的listnode结构体：\nstruct listnode { struct listnode *next, *prev; }; 使用时，需要将一个listnode结构体放入到需要组成链表的结构体中：\nstruct data { int a; int b; char *c; struct listnode _list; }; 在使用的时候，可以用一些宏来方便代码书写，尤其是在通过listnode来寻找整个data结构体时，就需要利用偏移量（使用offsetof关键字）和指针的强制转换的宏。\n两种容器的优缺点 非侵入式 优点：\n简单易操作。 每个节点只需要分配一次。 每个节点是一个整体，所以生命周期和内存手动管理比较友好。 缺点：\n一个对象只能属于一个容器，如要共享于两个容器（例如同时放在双向链表和红黑树中），就只能拷贝这个对象或者使用指针间接访问。如果使用拷贝的方法就会降低性能。 无法保留原始类型的同时将派生对象存储在STL容器中。 侵入式 优点：\n不会调用内存分配，可以将动态分配的开销最小化，也在插入和擦除对象时有可预测性。 使用很小的代价就可以将同一个对象插入到多个容器之中。 迭代的速度很快，内存访问更少，从指针或元素引用到该元素的迭代器的计算是一个常数时间，（std::list\u0026lt;T*\u0026gt;是线性复杂度）。 缺点：\n更改对象时时刻要注意是否会带来副作用。 需要独立于容器管理对象的生命周期以及内存分配。 因为对象可以在从容器被删除之前释放，因此迭代器容易失效。 分析使用容器的程序的线程安全性更加困难，因为容器可能会在没有显式调用容器成员的情况下被间接修改。 来自 boost 的对比表格 参考资料 boost document\n","permalink":"https://vaaandark.top/posts/facts-about-linklist/","summary":"\u003cp\u003e最近看到了一些关于侵入式和非侵入式链表的讨论，决定研究一下它们两个。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"侵入式和非侵入式链表的区别\"\u003e侵入式和非侵入式链表的区别\u003c/h2\u003e\n\u003cp\u003e这里的侵入是相对于链表的指针域来说，所以最主要的区别就是非侵入式的链表容器中保存了一份用户传入的值。\u003c/p\u003e","title":"说说链表"},{"content":"继续学习 OpenMP 的使用，尤其是一些较新版本。\nOpenMP 4.0 Controlling OpenMP thread Affinity 因为很多硬件如今是 NUMA 结构，分配线程的位置可以很大程度上影响性能。\n与核绑定有关的 OpenMP 结构 proc_bind (master | close | spread)\nmaster 继承串行部分的核绑定，用运行之前串行线程的核来执行所有的线程。\nclose 优先分配与串行线程相临近的核。当并行线程数量大于核心数量时，分配方式与 spread 相近。\nspread 稀疏、均匀地进行绑定。如果有 M 个线程， N 个核心，那么从串行线程运行的那个核开始分布，每个核上运行 $M/N$ 个线程。\nTask constructor OpenMP 4.0 可以指定 task 之间的依赖关系。\ntaskwait int fib(int n) { int i, j; if (n \u0026lt; 2) return n; else { #pragma opm task shared(i) firstprivate(n) i = fib(n - 1); #pragma omp task shared(j) firstprivate(n) j = fib(n - 2); #pragma omp taskwait return i + j } } int main(void) { int n = 10; opm_set_num_threads(4); #pragma omp parallel shared(n) { #pragma omp single printf(\u0026#34;fib (%d) = %d\\n\u0026#34;, n, fib(n)); } return 0; } 上述代码中的 taskwait 指令可以保证在 return 之前要计算完成 i 和 j 。\n虽然只有一个线程会执行 fib 的调用，但是在 fib 函数之中的 task 执行是四个线程都参与的。\nTask dependencies 对同一父级任务的调度增加额外的约束。\n#pragma omp task depend(type: list)\ntype := in | out | inout\n类似于依赖图。\nFlow dependency: read - after - write(RAW) int x = 1; #pragma omp parallel { #pragma omp single { #pragma omp task shared (x) depend (out: x) x = 2; #pragma omp task shared (x) depend (in: x) printf(\u0026#34;x = %d\\n\u0026#34;, x); } } Anti dependency: write - after - read(WAR) int x = 1; #pragma omp parallel { #pragma omp single { #pragma omp task shared (x) depend (in: x) x = 2; #pragma omp task shared (x) depend (out: x) printf(\u0026#34;x = %d\\n\u0026#34;, x); } } Output dependency: write - after - write(WAW) int x = 1; #pragma omp parallel { #pragma omp single { #pragma omp task shared (x) depend (out: x) x = 2; #pragma omp task shared (x) depend (out: x) printf(\u0026#34;x = %d\\n\u0026#34;, x); } } 上述代码中的两个 task 可以以任意方式执行，因此可能会出现数据竞争的情况。\n在矩阵中使用，利用数组分片。\n以下例子展示了一个基于 task 的矩阵(N * N)分块，分成 BS * BS 的分块矩阵。\n// Assume BS divides N perfectly void matmul_depend(int N, int BS, float A[N][N], float B[N][N], float C[N][N)) { int i, j, k, ii, jj, kk; for(i = 0; i \u0026lt; N; i += BS) for(j = 0; j \u0026lt; N; j += BS) for(k = 0; k \u0026lt; N; k += BS) { #pragma omp task \\ depend (in: A[i:BS][k:BS], B[k:BS][j:BS]) \\ depend (inout: C[i:BS][j:BS]) for(ii = i; ii \u0026lt; i + BS; ii++) for(jj = j; jj \u0026lt; j + BS; jj++) for(kk = k; kk \u0026lt; k + BS; kk++) C[ii][jj] = C[ii][jj] + A[ii][kk] * B[kk][jj]; } } Taskyield construct 使当前的 task 让出，方便其他的 task 执行。一般和 while 语句搭配使用：\nfor (int i = 0; i \u0026lt; N; ++i) { #pragma omp task { something_useful(); while (!omp_test_lock(lock)) { #pragma omp taskyield } something_critical(); omp_unset_lock(lock); // 释放锁 } } Taskgroup Construct taskwait vs. taskgroup\ntaskwait 只 join 子任务 taskgroup join 所有子任务和子任务派生的任务 User define reductions #pragma omp declare reduction(reduction-identifier: typename-list: combiner) [initialize-clause] reduction-identifier: 可以是一个用户定义的操作，也可以是 +, -, *, \u0026amp;, |, ^, \u0026amp;\u0026amp;, || typename-list: 操作作用的变量 combiner: 指定如何结合这些变量的语句 #include \u0026lt;math.h\u0026gt; void reduction1(float *x, int *y, int n) { int i, b, c; float a, d; a = 0.0; b = 0; c = y[0]; d = x[0]; #pragma omp parallel for private(i) shared(x, y, n) \\ reduction(+:a) reduction(^:b) \\ reduction(min:c) reduction(max:d) for (i=0; i\u0026lt;n; i++) { a += x[i]; b ^= y[i]; if (c \u0026gt; y[i]) c = y[i]; d = fmaxf(d,x[i]); } } Construct cancellation #pragma omp cancel construct [if (expr)] constructor := parallel | sections | for | taskgroup\nint t = 1; #pragma omp parallel firstprivate(t) { #pragma omp for for (int i = 0; i \u0026lt; 100; ++i) { t = test(); #pragma omp cancel for if (t == 5) } #pragma omp cancel parallel if (t == 5) #pragma omp barrier printf(\u0026#34;Thread %d\\n\u0026#34;, omp_get_thread_num()); } cancel 功能默认是关闭的，如果需要则要把环境变量 OMP_CANCELLATION 设置为 true，$OMP_CANCELLATION=true ./test\nSIMD Constructs OpenMP 对并行和串行都有向量化支持。\n#pragma omp simd [clauses] 可以对循环使用，指示这个循环迭代可以 SIMD 分块执行\n#pragma omp declare simd [clauses] 标记这个函数可以被一个 SIMD 循环调用\n#pragma omp for simd [clauses] 表示循环可以分块后被线程组执行，每一块都可以 SIMD 向量化\n#pragma omp declare simd double inc(int i) { return i + 1; } int main(void) { int d1 = 0, N = 100; double a[N], b[N], d2 = 0.0f; #pragma omp simd reduction(+: d1) for (int i = 0; i \u0026lt; N; ++i) d1 += i * inc(i); #pragma omp parallel for simd reduction(+: d2) for (int i = 0; i \u0026lt; N; ++i) d2 += a[i] * b[i]; } Device Constructs OpenMP 4.0 开始支持异构计算，可以将计算部分放到其余的 target 上完成。\n在 map 语句中，有两种映射类型，分别是 to 和 from，定义了 original(host) 和 target(device) 之间的数据映射\nto: 在 device 上只读 from: 在 device 上只写 通过限制数据的权限，可以减少数据传输中的开销。\n#pragma omp target data 为后面的代码域创建一个 device 数据环境，它的作用只是将数据移动到 target 上。\nvoid vec_mult(float *p, float *v1, float *v2, int N) { int i; #pragma omp target data map(to: v1[0:N], v2[0:N]) map(from: p[0:N]) { #pragma omp target #pragma omp parallel for for (i = 0; i \u0026lt; N; ++i) p[i] = v1[i] * v2[i]; } output(p, N); } #pragma omp target 创建一个 device 数据环境，并在这个 target 上执行之后结构中的语句。\n#pragma omp target update 在 target 域中更新数据\n#pragma omp target update to(v1[:N], v2[:N]) // 将新值分配给 target 环境 #pragma omp declare target 指示变量或者函数被映射到了 device 上。\n#pragma omp declare target extern void fib(int N); #pragma omp end declare target #define THRESHOLD 1000000 void fib_wrapper(int n) { #pragma omp target if (n \u0026gt; THRESHOLD) { fib(n); } } OpenMP 4.5 Parallelism \u0026amp; Workshare for devices omp teams [clause[[,] clause], \u0026hellip;] newline structured-block omp distribute [clause[[,] clause], \u0026hellip;] newline for-loops OpenMP 5.0 ","permalink":"https://vaaandark.top/posts/openmp-advance/","summary":"\u003cp\u003e继续学习 OpenMP 的使用，尤其是一些较新版本。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"openmp-40\"\u003eOpenMP 4.0\u003c/h2\u003e\n\u003ch3 id=\"controlling-openmp-thread-affinity\"\u003eControlling OpenMP thread Affinity\u003c/h3\u003e\n\u003cp\u003e因为很多硬件如今是 NUMA 结构，分配线程的位置可以很大程度上影响性能。\u003c/p\u003e\n\u003cp\u003e与核绑定有关的 OpenMP 结构 proc_bind (master | close | spread)\u003c/p\u003e","title":"OpenMP进阶"},{"content":"写 OpenMP 的时候总是感觉怪怪的，不知道什么时候该用什么，所以最近系统化地看一遍 OpenMP 的使用，主体为 OpenMP 2.0 和 3.0。\nWhat is OpenMP? OpenMP Model 每个线程都有可以访问全局的共享内存。 数据可以是共享的也可以是私有的。 共享的数据可以被所有线程访问。 私有数据只能被拥有它的线程访问。 数据的传递对于编程者是透明的。 同步会发生，但是它大部分时候是隐式的。 Data-Sharing Attributes 在一个 OpenMP 程序中，数据需要被打上标签，有两种基本类型：\n共享的 只有一个数据的实例 所有的线程都可以同步地读或者写，除非有特定的 OpenMP 结构保护它 所有数据变化都对所有线程可见 但是除非强制，并不需要变化立即可见\n私有的 每一个线程持有一份数据的拷贝 其他线程无权访问该数据 数据变化只对拥有者线程可见 其余的一些类型也是基于以上变化而来\nThe OpenMP Execution Model OpenMP 程序执行模型被称为 Fork and Join Model，在不需要并行执行时只有一个主线程，在需要并行时 Fork 出多个 Worker 线程，在经历了同步之后 Join 到一个主线程。\nHow to use OpenMP? A first OpenMP example #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;omp.h\u0026gt; int main(void) { # pragma omp parallel for num_threads(4) for (int i = 0; i \u0026lt; 20; ++i) { printf(\u0026#34;Hello from thread %d of %d\\n\u0026#34;, \\ omp_get_thread_num(), \\ omp_get_num_threads()); } return 0; } gcc -o for for.c -fopenmp ./for 如果不指定线程数，就会默认使用 CPU 实际能同时运行的个数，在我的 8 核 16 线程的电脑上就是 16 个线程。\nMatrix example # pragma omp parallel for default(none) \\ private(i, j, sum) \\ shared(m, n, a, b, c) for (i = 0; i \u0026lt; m; ++i) { sum = 0.0f; for (j = 0; j \u0026lt; n; ++j) { sum += b[i][j] * c[j]; } a[i] = sum; } 以 #pragma 开头的语句要写在同一行（类似宏）\nA more elaborate example # pragma omp parallel if (n\u0026gt;limit) default(none) \\ shared(n, a, b, c, x, y, z) private(f, i, scale) // 使用 if 语句来避免因为矩阵过小导致的并行衰退 { f = 1.0f; # pragma omp for nowait // nowait 每个线程完成自己的工作后不等待其他线程 // 而是直接执行后面的代码 for (i = 0; i \u0026lt; n; ++i) z[i] = x[i] + y[i]; # pragma omp for nowait for (i = 0; i \u0026lt; n; ++i) a[i] = b[i] + c[i]; # pragma omp barrier // 在此处显示说明要同步 // ... scale = sum(a, 0, n) + sum(z, 0, 0) + f; // ... } OpenMp in Some More Detail Terminology and behavior OpenMP Team := Master + Worker 并行域(Parallel Region)是所有线程同步执行的代码块 主线程 ID 永远是 0 线程调整（如果有的话）都只会在进入并行域之后完成 并行域是可以嵌套的 if 语句可以用于并行域，如果为假则会串行执行 有一个 work-sharing 结构(例如 Single, Sections 等)在分配任务给 team 中的成员 The if / private / shared clauses if (scalar expression) private(list) firstprivate(list) 在第一个循环继承共享变量的值 lastprivate(list) 根据逻辑上的最后一个线程给共享变量赋值（不是实际运行完的最后一个线程，对于 for 循环就是最后一次迭代的值） shared(list) The nowait clause 为了最小化同步带来的损失，可以使用 nowait 。如果出现了 nowait ，线程将在特定代码块之后不同步或者等待。\nThe sections directive #pragma omp parallel default(none) \\ shared(n,a,b,c,d) private(i) { #pragma omp sections nowait // 下面两个 section 是并行的 { #pragma omp section for (i = 0; i \u0026lt; n - 1; ++i) b[i] = (a[i] + a[i + 1] / 2); #pragma omp section for (i = 0; i \u0026lt; n; ++i) d[i] = 1.0f / c[i]; } /*-- End of sections --*/ } /*-- End of parallel region --*/ Single processor region 这种结构作 I/O 或者初始化非常理想。\n例如在一个并行域中需要进行 IO 操作，这时可以在读取后放一个 barrier ，但是根据 Amdahl 定理，这会成为拓展这段代码时的瓶颈。\n此时可以使用 single 或者 master 将任务只分配给一个线程，其中 master 只会分配给 master 线程。如此一来，无论是在入口还是出口都没有使用 barrier 。\nCritical Region 在如下代码块中，如果 sum 是一个共享变量，那么就可能在并行中发生数据竞争的问题。\nfor (i = 0; i \u0026lt; N; ++i) { // ... sum += a[i]; // ... } 我们可以使用 critical region ，在同一时间段内只会有一个线程执行该语句。\n#pragma omp critical [(name)] 有的时候也可以使用 Atomic ，但是要注意 Atomic 只是原子地载入和存储，它们并不完全等效。\n能用 Atomic 时尽量使用 Atomic ，因为其更加轻量。\n#pragma omp atomic [(name)] OpenMP 3.0 supports for TASKS 在 3.0 版本中，OpenMP 增加了对 task 的支持，更多的东西可以并行化了。\nA Linked List Example while(my_pointer) { (void)do_independent_work(my_pointer); my_pointer = my_pointer-\u0026gt;next ; } // End of while loop 上述代码在 OpenMP 2.0 中想要并行化会较为困难，但是在 3.0 增加了对 task 的支持之后便容易了许多。\n#pragma omp parallel { #pragma omp single nowait { while (my_pointer) { #pragma omp task firstprivate(my_pointer) // task 在此处并行执行 { (void)do_independent_work(my_pointer) } my_pointer = my_pointer-\u0026gt;next; } } // End of single - no implied barrier (nowait) } // End of parallel region - implied barrier 参考资料 OpenMP Tutorials An Overview of OpenMP - Ruud van der Pas - Sun Microsystems Tim Matton\u0026rsquo;s \u0026ldquo;Introduction fo OpenMP\u0026rdquo; ","permalink":"https://vaaandark.top/posts/openmp-introduction/","summary":"\u003cp\u003e写 OpenMP 的时候总是感觉怪怪的，不知道什么时候该用什么，所以最近系统化地看一遍 OpenMP 的使用，主体为 OpenMP 2.0 和 3.0。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"what-is-openmp\"\u003eWhat is OpenMP?\u003c/h2\u003e\n\u003ch3 id=\"openmp-model\"\u003eOpenMP Model\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e每个线程都有可以访问全局的共享内存。\u003c/li\u003e\n\u003cli\u003e数据可以是共享的也可以是私有的。\u003c/li\u003e\n\u003cli\u003e共享的数据可以被所有线程访问。\u003c/li\u003e\n\u003cli\u003e私有数据只能被拥有它的线程访问。\u003c/li\u003e\n\u003cli\u003e数据的传递对于编程者是透明的。\u003c/li\u003e\n\u003cli\u003e同步会发生，但是它大部分时候是隐式的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"OpenMP Model\" loading=\"lazy\" src=\"/image/openmp-model.png\"\u003e\u003c/p\u003e","title":"OpenMP入门"},{"content":"突然发现自己从高二以来基本没有读过“闲书”，意识到这可能正是现在诸多烦恼的原因之一吧……\n其实从初中以来，我所阅读书籍的文学性都是在下降的，我看过的大部分文学名著都是在初中及之前看的，在之后就是科幻和一些功能性的书了，再就是各种评论性的文章，抑或是看不懂也要看的哲学或者诗歌。\n以散文为例，在高中就买了的一些我较为喜欢作家的文集被我带到了华科，但到现在都还只翻动了几页。而高中语文老师送给我的《月亮与六便士》、《罗生门》也被我连带着包装平移到了宿舍吃灰。\n作为一个“中土”迷，我的《精灵宝钻》也是尚未拆封，也没有再花时间重温电影。联想到最近在看的《哈利波特》，也是被我囫囵吞枣般看了三部，期间夹杂着快放以及xx讲电影的剧透。\n我好像失去了欣赏文学艺术的能力，以前那个把小学同学书都看完了的我好像不见了，取而代之的是一个阅读只注重效果的工具、一个时时刻刻想看“锐评”或者发表“锐评”的“大评论家”“大阴阳师”、一个只想“开天眼”到结局的“快餐食客”。我的短视、暴戾、尖酸刻薄、无知和浅薄好像就派生于此。\n希望能少看一些看似能涨知识的视频，多看点书吧，就从这几本开始吧……\n在这之后打算去读读一直想读的卡尔维诺、卡夫卡。\n","permalink":"https://vaaandark.top/posts/essay-in-july/","summary":"\u003cp\u003e突然发现自己从高二以来基本没有读过“闲书”，意识到这可能正是现在诸多烦恼的原因之一吧……\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003cp\u003e其实从初中以来，我所阅读书籍的文学性都是在下降的，我看过的大部分文学名著都是在初中及之前看的，在之后就是科幻和一些功能性的书了，再就是各种评论性的文章，抑或是看不懂也要看的哲学或者诗歌。\u003c/p\u003e","title":"七月随笔"},{"content":"Lua 的一大特色就是协程的使用，在解释型语言中，如果不考虑嵌入到较为低级的语言（如 C 语言）中，就只需要操作调用栈并保存好上下文状态即可。但是 Lua 并不是一门纯粹依靠字节码的解释型语言，它常常与 C 语言反复嵌套，甚至出现 C 中调用 Lua ，Lua 中再调用 C 代码，，，的情况。一旦 Lua 调用的 C 库企图中断线程，再想恢复，就会是一个难题。好在 Lua 巧妙地解决了这些问题。\nLua 虚拟机重要结构体 global_State global_State 由所有线程共享，其中包含字符串内部化保存的哈希表、垃圾回收、异常处理等信息。\nlua_State lua_State 表示一个 Lua 线程的执行状态，它有着自己独立的数据栈和函数调用栈。每个 lua_State 都有一个指向 global_State 的指针。\n/* ** \u0026#39;per thread\u0026#39; state */ struct lua_State { CommonHeader; lu_byte status; lu_byte allowhook; unsigned short nci; /* number of items in \u0026#39;ci\u0026#39; list */ StkId top; /* first free slot in the stack */ global_State *l_G; CallInfo *ci; /* call info for current function */ StkId stack_last; /* end of stack (last element + 1) */ StkId stack; /* stack base */ UpVal *openupval; /* list of open upvalues in this stack */ StkId tbclist; /* list of to-be-closed variables */ GCObject *gclist; struct lua_State *twups; /* list of threads with open upvalues */ struct lua_longjmp *errorJmp; /* current error recover point */ CallInfo base_ci; /* CallInfo for first level (C calling Lua) */ volatile lua_Hook hook; ptrdiff_t errfunc; /* current error handling function (stack index) */ l_uint32 nCcalls; /* number of nested (non-yieldable | C) calls */ int oldpc; /* last pc traced */ int basehookcount; int hookcount; volatile l_signalT hookmask; }; 数据栈 对数据栈初始化和释放分别调用 stack_init 和 free_stack 函数：\nstatic void stack_init (lua_State *L1, lua_State *L); static void freestack (lua_State *L); 数据栈初始大小是 Lua 内置栈结构的两倍，随着数据的增多需要调用 growstack 进行栈的扩展。因为有些数据包含了对栈中元素的引用，在栈中元素移位之后，在扩展之中要对栈进行修正。\n#define BASIC_STACK_SIZE (2*LUA_MINSTACK) static void correctstack (lua_State *L, StkId oldstack, StkId newstack); int luaD_reallocstack (lua_State *L, int newsize, int raiseerror); int luaD_growstack (lua_State *L, int n, int raiseerror); 通过源代码中的注释可以很清晰知晓这些函数的作用，再结合源码，可以发现这三个函数的调用关系为：\nluaD_growstack ---\u0026gt; luaD_reallocstack ---\u0026gt; correctstack 调用栈 函数调用栈使用的是一个双向链表结构体 CallInfo ：\ntypedef struct CallInfo { StkId func; /* function index in the stack */ StkId\ttop; /* top for this function */ struct CallInfo *previous, *next; /* dynamic call link */ union { struct { /* only for Lua functions */ const Instruction *savedpc; volatile l_signalT trap; int nextraargs; /* # of extra arguments in vararg functions */ } l; struct { /* only for C functions */ lua_KFunction k; /* continuation in case of yields */ ptrdiff_t old_errfunc; lua_KContext ctx; /* context info. in case of yields */ } c; } u; union { // ... } u2; short nresults; /* expected number of results from this function */ unsigned short callstatus; } CallInfo; 在联合体 u 中：字段 l 用于调用 Lua 函数，字段 c 用于调用 C 函数，callstatus 用于标志是 Lua 函数还是 c 函数；联合体 u2 和保护模式、钩子函数等有关，暂不考虑。\n需要注意到的是，既有 func 又有 base 的原因是，Lua 传入一个函数的参数个数可能不定，通过函数位置和栈底位置相减可以计算出参数个数。\nLua 线程 创建线程 在 Lua 中也有线程的概念，但它并不是系统线程，而且由于所有的 lua_State 都共享了 global_State ，因此多线程操作较难。在 Lua 中，协程才是最强大的武器。\nLua 给 C/C++ 保留了很多 API ，其中关于创建线程的 API 很有意思：\nLUA_API lua_State *lua_newthread (lua_State *L) { // ... /* create new thread */ L1 = \u0026amp;cast(LX *, luaM_newobject(L, LUA_TTHREAD, sizeof(LX)))-\u0026gt;l; //... } 创建线程结构体时分配空间的大小不是 Lua_State 的大小，而是 LX 的大小，而且将 Lua_State 放在了 LX 所在内存的后一部分，这既是给自定义 Lua 代码留下了空间，也是为了防止向用户暴露 Lua_State 的大小。\n举个例子，在多线程操作中，访问 lua_State 结构中注册表是线程不安全的，但是如果你将一些信息放在 lua_State 的前面，就可以既方便访问又在数据竞争中保持安全（不够这也增加了代码的复杂度）。\n线程中断及异常处理 Lua 全部源码都由标准 C 写成而且只使用了标准库，因此它的线程中断和错误处理都使用的是标准库中的 setjmp.h 来实现的。\n异常 我在之前的一篇博文中讲到过 C语言接口与实现 中实现 C 语言异常处理的方法，也是通过 setjmp.h 来实现的。而 Lua 源码更进一步，通过宏定义将异常处理和 C++ 中的原生异常处理 try/catch 联系起来，也方便了开发者使用 C++ 开发 Lua 程序。\nLua 中的异常是一个单向链表（链栈），它的行为也很好理解：出现异常，将异常串到链表上并抛出，在处理完后再使用 longjmp 跳回来。\n/* chain list of long jump buffers */ struct lua_longjmp { struct lua_longjmp *previous; luai_jmpbuf b; volatile int status; /* error code */ }; 函数 Lua 的函数调用过程分为 precall 和 poscall 两个部分：对于 C 语言函数来说，precall 调用了它；而对于 Lua 函数来说，precall 是为了它的调用做准备，只是改变了 Lua 虚拟机（lua_State）的状态而已，并没有真正调用。poscall 处理了它的返回，对数据栈进行了调整。\nCallInfo *luaD_precall (lua_State *L, StkId func, int nresults) { retry: switch (ttypetag(s2v(func))) { case LUA_VCCL: /* C closure */ // ... case LUA_VLCF: /* light C function */ // ... case LUA_VLCL: { /* Lua function */ // ... } default: { /* not a function */ func = luaD_tryfuncTM(L, func); /* try to get \u0026#39;__call\u0026#39; metamethod */ /* return luaD_precall(L, func, nresults); */ goto retry; /* try again with metamethod */ } } } void luaD_poscall (lua_State *L, CallInfo *ci, int nres); StkId luaD_tryfuncTM (lua_State *L, StkId func); 可以看到 precall 里面 switch/case 中的 default 分支，里面调用了 luaD_tryfuncTM 函数，这涉及了 Lua 中的元表（Meta Table），简单来说就是，当在表中找不到元素时就会尝试在表对应的元表中寻找。Lua 就是利用元表实现了类似于 Java 中的接口、C++ 中的虚函数、Rust 中的 Trait，以及重载运算符等操作。\n当我们使用 C 语言开发并将 Lua 代码嵌入其中时，可以使用 API luaD_call ，它是 ccall 的一个包装。\nvoid luaD_call (lua_State *L, StkId func, int nResults) { ccall(L, func, nResults, 1); } l_sinline void ccall (lua_State *L, StkId func, int nResults, int inc) { CallInfo *ci; L-\u0026gt;nCcalls += inc; if (l_unlikely(getCcalls(L) \u0026gt;= LUAI_MAXCCALLS)) luaE_checkcstack(L); if ((ci = luaD_precall(L, func, nResults)) != NULL) { /* Lua function? */ ci-\u0026gt;callstatus = CIST_FRESH; /* mark that it is a \u0026#34;fresh\u0026#34; execute */ luaV_execute(L, ci); /* call it */ } L-\u0026gt;nCcalls -= inc; } 参数 inc 代表的是在 C 函数栈中递归函数的个数，而 lua_State 实例 L 中的 nCcalls 代表的是在调用过程中被中断后就不能恢复的 C 函数（non-yielded，在老版本中名字叫做 nny)。\n从中断中恢复 终于到了如何解决从中断中恢复这个问题了。Lua 给出的解决方案其实也不难，就是让编写 C 程序的开发者辛苦一点而已，也就是让他们自己提供一个延续函数 k 。\n我们可以回顾一下 CallInfo 结构体中的 c 字段：\n// ... struct { /* only for C functions */ lua_KFunction k; /* continuation in case of yields */ ptrdiff_t old_errfunc; lua_KContext ctx; /* context info. in case of yields */ } c; // ... k 就是延续函数，而 ctx 就保存有 yield 时的上下文。\n在使用 k 时，只需要把它当作回调函数，将它和虚拟机实例 L 一起传入 API lua_callk 中即可。\n在 C 线程需要挂起时就要调用 lua_yieldk 来保存恢复时需要的上下文等信息：\nLUA_API int lua_yieldk (lua_State *L, int nresults, lua_KContext ctx, lua_KFunction k); 在 lua_yieldk 中保存信息前要进行 lua_lock(L)，之后要 lua_unlock(L) 释放锁，但是在源码中 这两个宏都是不完整的，都被拓展为(void (0))，在需要同步的时候要注意对它们进行补充。\nLua 协程让出时也需要调用 lua_yieldk ，这放在协程部分讨论。\n在恢复时 Lua 内部调用的函数是 resume 函数：\nstatic void resume (lua_State *L, void *ud) { // ... if (isLua(ci)) { /* yielded inside a hook? */ L-\u0026gt;top = firstArg; /* discard arguments */ luaV_execute(L, ci); /* just continue running Lua code */ } else { /* \u0026#39;common\u0026#39; yield */ if (ci-\u0026gt;u.c.k != NULL) { /* does it have a continuation function? */ lua_unlock(L); n = (*ci-\u0026gt;u.c.k)(L, LUA_YIELD, ci-\u0026gt;u.c.ctx); /* call continuation */ lua_lock(L); api_checknelems(L, n); } luaD_poscall(L, ci, n); /* finish \u0026#39;luaD_call\u0026#39; */ } unroll(L, NULL); /* run continuation */ // ... } 可以看到如果是要恢复一个 Lua 函数就直接继续执行就可以了，如果是一个 C 函数则需要调用延续函数，再使用 poscall 处理返回值。\n与 resume 相关的 API 有 lua_resume，只是对 resume 的包装而已，较为简单。\nLua 协程 讨论完了上面的线程问题，现在需要讲的协程就是小菜一碟了。Lua 的协程实际上就是 Lua 线程间的切换（而非系统线程，故性能损失较少），需要考虑的只有错误信息的 move 以及新切换到的线程的 resume 问题，而 resume 的实现在前文已经讨论过了。\n协程的创建 对应 Lua 语句： lua coroutine.create()\n由于 Lua 协程是不对称的，故创建协程时有一个参数会是创建协程的协程 L ，并从 L 中 move 函数信息到新创建的 NL 中：\nstatic int luaB_cocreate (lua_State *L) { lua_State *NL; luaL_checktype(L, 1, LUA_TFUNCTION); NL = lua_newthread(L); lua_pushvalue(L, 1); /* move function to top */ lua_xmove(L, NL, 1); /* move function from L to NL */ return 1; } luaB_cowrap 是对函数 luaB_coreate 的一层封装：\nstatic int luaB_cowrap (lua_State *L) { luaB_cocreate(L); lua_pushcclosure(L, luaB_auxwrap, 1); return 1; } 协程的让出 对应 Lua 语句： lua coroutine.yield()\n#define lua_yield(L,n)\tlua_yieldk(L, (n), 0, NULL) static int luaB_yield (lua_State *L) { return lua_yield(L, lua_gettop(L)); } 协程的恢复 对应 Lua 语句：lua coroutine.resume()\n启动协程和协程的恢复类似，都离不开以下两个函数：\nstatic int luaB_coresume (lua_State *L); static int auxresume (lua_State *L, lua_State *co, int narg); 函数调用链如下：\nluaB_coresume ---\u0026gt; auxresume ---\u0026gt; lua_resume(API) ---\u0026gt; resume 总结 Lua 的异常处理和线程机制为了和 C 语言互相嵌入经过了反复的权衡，代码的复杂度较大，最后使用延续函数的设计其实只能算是一个妥协的结果，但是这其中的设计还是很值得我们去学习。\n但 Lua 的协程库的代码非常之短小，总共两百行出头，而核心部分只有接近百行，原因之一就是它只需要调用 ldo.h 中提供的 API ，线程中断和恢复部分的代码已经给协程实现打下了良好的基础。\n参考资料 Lua 5.4.4 源码\nLua-Users-Wiki\n云风的 BLOG\nvaaandark\u0026rsquo;s blog\nNotes on the Implementation of Lua 5.3\n","permalink":"https://vaaandark.top/posts/lua-coroutine/","summary":"\u003cp\u003eLua 的一大特色就是协程的使用，在解释型语言中，如果不考虑嵌入到较为低级的语言（如 C 语言）中，就只需要操作调用栈并保存好上下文状态即可。但是 Lua 并不是一门纯粹依靠字节码的解释型语言，它常常与 C 语言反复嵌套，甚至出现 C 中调用 Lua ，Lua 中再调用 C 代码，，，的情况。一旦 Lua 调用的 C 库企图中断线程，再想恢复，就会是一个难题。好在 Lua 巧妙地解决了这些问题。\u003c/p\u003e","title":"Lua Coroutine"},{"content":"之前学习 Lua 的时候就对它的 Table 很感兴趣，最近在看 Lua 解释器的源码，因此就想研究一下具体是怎么实现这个 Lua 之中最为重要的数据结构的。\nLua Table 简介 在 Lua 语言之中，数组是 table ，字典是 table ，就连对象、模块、包也是通过 table 实现的：\n数组是键值为正整数的表；\n由于键值也可以是其他类型，故表也可以实现字典这种数据结构；\n由于函数也是 Lua 的第一公民，所以成员函数也可以通过表来实现；\n模块和包之间的从属关系也是通过 table 来表示的。\nLua 中的 table 使用十分广泛，这也导致了 Lua 使用起来有着 纯真的、野性的 简洁的美。\n这种数组和字典杂糅的数据结构有是如何实现的呢？这种数据结构又是否高效呢？我们将会在下文进行探究。\nLua 解释器中的哈希函数 传入参数中的 seed 是通过 lua_newstate 函数地址、lua_State 实例的地址和当前时间共同计算得到的，因此具有较强的随机性：\nunsigned int luaS_hash (const char *str, size_t l, unsigned int seed) { unsigned int h = seed ^ cast_uint(l); for (; l \u0026gt; 0; l--) h ^= ((h\u0026lt;\u0026lt;5) + (h\u0026gt;\u0026gt;2) + cast_byte(str[l - 1])); return h; } 在老版本的 Lua 中 luaS_hash 函数比现在的复杂，是因为新版中只对短字符串使用该函数，而老版本对所有字符串都使用该函数，为了保证求哈希时的效率，所以对字符串大于 32 字节的部分进行跳过至少一个字节的哈希运算（注意 step 变量）：\nunsigned int luaS_hash(struct lua_State* L, const char* str, unsigned int l, unsigned int h) { h = h ^ l; unsigned int step = (l \u0026gt;\u0026gt; 5) + 1; for (int i = 0; i \u0026lt; l; i = i + step) { h ^= (h \u0026lt;\u0026lt; 5) + (h \u0026gt;\u0026gt; 2) + cast(lu_byte, str[i]); } return h; } 通过 hash 值来得到索引的方法如下：\nindex = hash_value \u0026amp; ((1U \u0026lt;\u0026lt; lsizenode) - 1) 其中 lsizenode 是 node 长度关于 2 的对数，这种方法类似于取模。\nLua 解释器中的重要类型 联合体 Value 能表示 Lua 所有的基本数据结构：\n/* ** Union of all Lua values */ typedef union Value { struct GCObject *gc; /* collectable objects */ void *p; /* light userdata */ lua_CFunction f; /* light C functions */ lua_Integer i; /* integer numbers */ lua_Number n; /* float numbers */ } Value; 结构体 TValuefields 的两个字段分别表示 value 和 value 的类型：\n#define TValuefields\tValue value_; lu_byte tt_ typedef struct TValue { TValuefields; } TValue; TValue 长度为 12 个字节，可以使用 NaN Trick 节约空间。\n联合体 Node 有两个字段，一个是结构体 NodeKey 依次包含了这个节点的值、键的类型、下一个节点的位置、键的值与类型，另一个字段是 TValue 类型的 i_val ，因为是联合体，所以可以通过直接访问 i_val 得到值的类型和类型：\ntypedef union Node { struct NodeKey { TValuefields; /* fields for value */ lu_byte key_tt; /* key type */ int next; /* for chaining */ Value key_val; /* key value */ } u; TValue i_val; /* direct access to node\u0026#39;s value as a proper \u0026#39;TValue\u0026#39; */ } Node; 结构体 Table 中 CommonHeader 和 GCObject 与垃圾回收有关，metatable 和元表有关，flags 和元方法有关，都暂时不考虑。lsizenode 是哈希部分长度关于 2 的对数，alimit 是数组部分的长度的下限（不一定是真实大小，是一个估计），array 和 node 分别指向数组部分和哈希部分，lastfree 指向哈希部分存在空槽的末尾位置：\ntypedef struct Table { CommonHeader; lu_byte flags; /* 1\u0026lt;\u0026lt;p means tagmethod(p) is not present */ lu_byte lsizenode; /* log2 of size of \u0026#39;node\u0026#39; array */ unsigned int alimit; /* \u0026#34;limit\u0026#34; of \u0026#39;array\u0026#39; array */ TValue *array; /* array part */ Node *node; Node *lastfree; /* any free position is before this position */ struct Table *metatable; GCObject *gclist; } Table; Table 相关操作 前面已经说到了 Lua 中的 Table 是一个既包含数组部分又包含哈希部分的数据结构，也对 Lua 源码中关于 Table 的类型进行了探究，现在就可以对 Table 的相关操作进行讨论。\n在讨论之前有一些前置知识需要了解：首先就是 Lua 的哈希部分应对哈希冲突使用的是链接法，但是它不会单独拉出链表来，依然是一个 Node 数组的形式。它所有的节点都在 Node 数组之中，通过 next 字段串起来，这就导致 Lua 哈希表对内存的利用十分紧凑。\n在源码中，作者将键值通过哈希计算直接得到的位置叫做 mainpostion ，下文中称之为主位置。\n初始化操作 初始化 Table 较为简单，基本上就是给字段赋值为 0 或者 NULL，但需注意 node 字段并不初始化为 NULL 而是初始化为一个全局变量 dummynode ，这种做法可以减少很多次判空操作。\nget 操作 当 key 为一个整数 i_key 时，首先判断 i_key 与 alimit 的关系，如果小于 alimit 说明在数组部分，直接返回下标位置的值；如果大于 alimit 但 alimit 并不是真实的数组大小，就先更新 alimit 再返回下标位置；上述条件都不满足，说明在哈希部分，并在哈希部分查找。\nconst TValue *luaH_getint (Table *t, lua_Integer key) { if (l_castS2U(key) - 1u \u0026lt; t-\u0026gt;alimit) /* \u0026#39;key\u0026#39; in [1, t-\u0026gt;alimit]? */ return \u0026amp;t-\u0026gt;array[key - 1]; else if (!limitequalsasize(t) \u0026amp;\u0026amp; /* key still may be in the array part? */ (l_castS2U(key) == t-\u0026gt;alimit + 1 || l_castS2U(key) - 1u \u0026lt; luaH_realasize(t))) { t-\u0026gt;alimit = cast_uint(key); /* probably \u0026#39;#t\u0026#39; is here now */ return \u0026amp;t-\u0026gt;array[key - 1]; } else { Node *n = hashint(t, key); for (;;) { /* check whether \u0026#39;key\u0026#39; is somewhere in the chain */ if (keyisinteger(n) \u0026amp;\u0026amp; keyival(n) == key) return gval(n); /* that\u0026#39;s it */ else { int nx = gnext(n); if (nx == 0) break; n += nx; } } return \u0026amp;absentkey; } } 如果 key 不是一个整数，处理方法就较为简单，直接去哈希部分寻找。\nset 操作 首先介绍插入键值为一个整数时的情况，此时调用函数 luaH_setint 。插入键值时，先通过上文介绍过的函数 luaH_getint 在 Table 中进行查找，如果不为空则直接 set ，为空则调用函数 luaH_newkey ：\nvoid luaH_setint (lua_State *L, Table *t, lua_Integer key, TValue *value) { const TValue *p = luaH_getint(t, key); if (isabstkey(p)) { TValue k; setivalue(\u0026amp;k, key); luaH_newkey(L, t, \u0026amp;k, value); } else setobj2t(L, cast(TValue *, p), value); } luaH_newkey 是一个很重要的函数，它的主要逻辑和函数原型如下：\n/* ** inserts a new key into a hash table; first, check whether key\u0026#39;s main ** position is free. If not, check whether colliding node is in its main ** position or not: if it is not, move colliding node to an empty place and ** put new key in its main position; otherwise (colliding node is in its main ** position), new key goes to an empty position. */ void luaH_newkey (lua_State *L, Table *t, const TValue *key, TValue *value); 插入一个键值到哈希表中时，首先检查这个键值对应的主位置是不是空的。如果不是空的，就检查那个冲突节点是不是在它自身的主位置上：如果不是，那就调整这个冲突节点到空位置然后将待插入节点放入腾出来的位置；否则（冲突节点在自己的主位置），待插入键值就要去空位置了。\n冲突节点在自己主位置的情况： 冲突节点在自己主位置的情况： 调整不在主位置的冲突节点位置时要把它的前驱的 next 字段进行修改，对冲突节点的 next 字段也要修正。\n由于使用链接法时使用的是单向链表，因此想要获取冲突节点的前驱需要将冲突节点的键取出来求哈希，首先得到主位置，再通过一步一步地 next ，找到冲突节点之前的位置。\nlastfree 的移动：初始化时指向 node 数组的最后一位。在这之后，一般情况下只会使用自减操作向左移动。\nresize 操作 当表空间不足时就会进行 resize 操作。\n第一步是对 Key 为整数的部分进行统计，统计的是在区间 $(2^i, 2^{i+1}]$ 不为空的元素的个数，方便之后的 resize ，代码如下：\n/* ** Count keys in array part of table \u0026#39;t\u0026#39;: Fill \u0026#39;nums[i]\u0026#39; with ** number of keys that will go into corresponding slice and return ** total number of non-nil keys. */ static unsigned int numusearray (const Table *t, unsigned int *nums) { int lg; unsigned int ttlg; /* 2^lg */ unsigned int ause = 0; /* summation of \u0026#39;nums\u0026#39; */ unsigned int i = 1; /* count to traverse all array keys */ unsigned int asize = limitasasize(t); /* real array size */ /* traverse each slice */ for (lg = 0, ttlg = 1; lg \u0026lt;= MAXABITS; lg++, ttlg *= 2) { unsigned int lc = 0; /* counter */ unsigned int lim = ttlg; if (lim \u0026gt; asize) { lim = asize; /* adjust upper limit */ if (i \u0026gt; lim) break; /* no more elements to count */ } /* count elements in range (2^(lg - 1), 2^lg] */ for (; i \u0026lt;= lim; i++) { if (!isempty(\u0026amp;t-\u0026gt;array[i-1])) lc++; } nums[lg] += lc; ause += lc; } return ause; } 重新确定数组大小的一个原则就是，数组中不为空的元素要超过数组长度的一半，Lua 的设计者使用这种方法保证效率和内存使用的平衡。函数 computesizes 用于计算新数组的大小，代码如下：\nstatic unsigned int computesizes (unsigned int nums[], unsigned int *pna) { int i; unsigned int twotoi; /* 2^i (candidate for optimal size) */ unsigned int a = 0; /* number of elements smaller than 2^i */ unsigned int na = 0; /* number of elements to go to array part */ unsigned int optimal = 0; /* optimal size for array part */ /* loop while keys can fill more than half of total size */ for (i = 0, twotoi = 1; twotoi \u0026gt; 0 \u0026amp;\u0026amp; *pna \u0026gt; twotoi / 2; i++, twotoi *= 2) { a += nums[i]; if (a \u0026gt; twotoi/2) { /* more than half elements present? */ optimal = twotoi; /* optimal size (till now) */ na = a; /* all elements up to \u0026#39;optimal\u0026#39; will go to array part */ } } lua_assert((optimal == 0 || optimal / 2 \u0026lt; na) \u0026amp;\u0026amp; na \u0026lt;= optimal); *pna = na; return optimal; } 如果计算出来的 newsize 大于原来的大小，则将 Node 数组（哈希部分）中的一部分移到数组之中；如果小于，则将数组的一部分移到 Node 数组中。但无论如何都要对 Node 部分进行 rehash 操作。\n上文中的 numusearray 和 computesizes 计算都是在函数 rehash 中调用的：\n/* ** nums[i] = number of keys \u0026#39;k\u0026#39; where 2^(i - 1) \u0026lt; k \u0026lt;= 2^i */ static void rehash (lua_State *L, Table *t, const TValue *ek) { unsigned int asize; /* optimal size for array part */ unsigned int na; /* number of keys in the array part */ unsigned int nums[MAXABITS + 1]; int i; int totaluse; for (i = 0; i \u0026lt;= MAXABITS; i++) nums[i] = 0; /* reset counts */ setlimittosize(t); na = numusearray(t, nums); /* count keys in array part */ totaluse = na; /* all those keys are integer keys */ totaluse += numusehash(t, nums, \u0026amp;na); /* count keys in hash part */ /* count extra key */ if (ttisinteger(ek)) na += countint(ivalue(ek), nums); totaluse++; /* compute new size for array part */ asize = computesizes(nums, \u0026amp;na); /* resize the table to new computed sizes */ luaH_resize(L, t, asize, totaluse - na); } next 操作 在 Lua 解释器中没有实现一个数据结构可以维护对 Table 的迭代信息，但是有一个函数 LuaH_next 可以通过传入一个键值，返回下一个键值对（实际上是将键值对压入 Lua 的栈中）：\nint luaH_next (lua_State *L, Table *t, StkId key) { unsigned int asize = luaH_realasize(t); unsigned int i = findindex(L, t, s2v(key), asize); /* find original key */ for (; i \u0026lt; asize; i++) { /* try first array part */ if (!isempty(\u0026amp;t-\u0026gt;array[i])) { /* a non-empty entry? */ setivalue(s2v(key), i + 1); setobj2s(L, key + 1, \u0026amp;t-\u0026gt;array[i]); return 1; } } for (i -= asize; cast_int(i) \u0026lt; sizenode(t); i++) { /* hash part */ if (!isempty(gval(gnode(t, i)))) { /* a non-empty entry? */ Node *n = gnode(t, i); getnodekey(L, s2v(key), n); setobj2s(L, key + 1, gval(n)); return 1; } } return 0; /* no more elements */ } 上述代码的基本思路为对传入 Key 之后的位置进行遍历，找到第一个非空的元素，将其键值对压入栈中，遍历依然是数组部分优先。\n总结 通过对 Lua Table 的学习，发现它真的是一门很适合用于教学的语言：首先它的设计理念很统一，而且蕴含了 Less is more 等简洁哲学；其次，它的代码短小规范，结构清晰，可读性极强，技巧使用也不多，看 Lua 代码有一种坐在教室看幻灯片的感觉。\n但做到了简洁，代价又是什么呢？\n我认为 Table 反而丧失了数组的高效，也让字典的内部实现变得复杂了起来。不过作为一门广泛用于配置文件的胶水语言，效率也许并没有那么重要。\n参考资料 Lua 5.4.4 源码\nLua-Users-Wiki\nThe Implementation of Lua 5.0\n云风的 BLOG\n","permalink":"https://vaaandark.top/posts/lua-table/","summary":"\u003cp\u003e之前学习 Lua 的时候就对它的 Table 很感兴趣，最近在看 Lua 解释器的源码，因此就想研究一下具体是怎么实现这个 Lua 之中最为重要的数据结构的。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"lua-table-简介\"\u003eLua Table 简介\u003c/h2\u003e\n\u003cp\u003e在 Lua 语言之中，数组是 table ，字典是 table ，就连对象、模块、包也是通过 table 实现的：\u003c/p\u003e","title":"Lua Table"},{"content":"C 语言没有原生支持异常处理，但是可以使用setjmp和longjmp函数实现类似try ... except的功能。\n本文主要参考：\nC Interfaces and Implementation\nImplementing exceptions in C\nsetjmp.h setjmp.h是 C 标准函数库中提供“非本地跳转”的头文件：控制流偏离了通常的子程序调用与返回序列。互补的两个函数setjmp与longjmp提供了这种功能。\nsetjmp和longjmp的典型用途是异常处理机制的实现：利用longjmp恢复程序或线程的状态，甚至可以跳过栈中多层的函数调用。\n重要函数 int setjmp(jmp_buf env)：建立本地的jmp_buf缓冲区并且初始化，用于将来跳转回此处。这个子程序保存程序的调用环境于env参数所指的缓冲区，env将被longjmp使用。如果是从setjmp直接调用返回，setjmp返回值为 0 。如果是从longjmp恢复的程序调用环境返回，setjmp返回非零值。\nvoid longjmp(jmp_buf env, int value)：恢复env所指的缓冲区中的程序调用环境上下文，env所指缓冲区的内容是由setjmp子程序调用所保存。value的值从longjmp传递给setjmp。longjmp完成后，程序从对应的setjmp调用处继续执行，如同setjmp调用刚刚完成。如果value传递给longjmp零值，setjmp的返回值为 1 ；否则，setjmp的返回值为value。\n重要类型 jmp_buf：用于保存恢复调用环境所需要的信息。 浅探异常处理 下面一段代码给出了使用setjmp和longjmp处理异常的基本思路：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;setjmp.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int Allocation_handled = 0; jmp_buf Allocate_Failed; void *allocate(unsigned n) { void *new = malloc(n); if (new) return new; if (Allocation_handled) longjmp(Allocate_Failed, 1); assert(0); } int main(void) { char *buf; Allocation_handled = 1; if (setjmp(Allocate_Failed)) { fprintf(stderr, \u0026#34;couldn\u0026#39;t allocate the buffer\\n\u0026#34;); exit(1); } buf = allocate(4096); Allocation_handled = 0; return 0; } 在上面的程序中，第一次调用setjmp时函数返回 0 ，因此不进入if后的分支而是继续执行后续操作，在调用函数allocate时，如果内存分配失败，将会调用longjmp函数，这会导致setjmp函数第二次返回，此时的返回值是longjmp函数第二个参数 1 。\n因此我们可以这样理解，setjmp函数一般会返回两次，第一次调用是为了给之后的跳转标记位置和保存上文的环境，第二次返回是由调用longjmp函数引起的，此时的返回值不是 0 ，因此可以进入if分支中处理异常。\n流程如下：\n\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; ________return_a_non-zero_number ---\u0026gt; exception_handling ---\u0026gt; ... / / normal_control_flow ---\u0026gt; setjmp --- first_called --- return_0 ---\u0026gt; do_something ---\u0026gt; longjmp ---\u0026gt; normal_control_flow \\ / \\__________________call_second_time_______________________/ \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; 利用宏实现类似try ... except的功能 实现效果 TRY S EXCEPT(E1) S1 EXCEPT(E2) S2 ... EXCEPT(En) Sn ELSE S0 ENDTRY // or TRY S FINALLY S1 ENDTRY 代码实现 GitHub 仓库\n重要结构体 except结构体表示异常类型 struct except { const char *reason; }; except_frame是一个链表的节点，包含了异常所在位置的程序环境、代码文件和行数，以及异常类型。 struct except_frame { struct except_frame *prev; jmp_buf env; const char *file; int line; const struct except *exception; }; 重要全局变量 except_stack是一个异常栈，每次处理栈顶的异常，直至栈空。因此这个结构是实现异常嵌套处理的关键。 struct except_frame *except_stack; 重要函数 except_raise：用于抛出一个异常并跳转到setjump，然后进入到异常处理分支。 void except_raise(const struct except *e, const char *file ,int line) 重要的宏 其实根据except_raise函数和全局变量就可以实现所有的功能了，但下文中的宏也并不是多此一举，正是它们让我们可以实现TRY ... EXCEPT ... ELSE ... END_TRY或者TRY ... FINAL ... END_TRY这样的语法。\n#define TRY do { \\ volatile int except_flag; \\ struct except_frame except_frame; \\ except_frame.prev = except_stack; \\ except_stack = \u0026amp;except_frame; \\ except_flag = setjmp(except_frame.env); \\ if (except_flag == EXCEPT_ENTERED) { #define EXCEPT(e) \\ if (except_flag == EXCEPT_ENTERED) \\ except_stack = except_stack-\u0026gt;prev; \\ } else if (except_frame.exception == \u0026amp;(e)) { \\ except_flag = EXCEPT_HANDLED; #define ELSE \\ if (except_flag == EXCEPT_ENTERED) \\ except_stack = except_stack-\u0026gt;prev; \\ } else { \\ except_flag = EXCEPT_HANDLED; #define FINALLY \\ if (except_flag == EXCEPT_ENTERED) \\ except_stack = except_stack-\u0026gt;prev; \\ } { \\ if (except_flag == EXCEPT_ENTERED) \\ except_flag = EXCEPT_FINALIZED; #define END_TRY \\ if (except_flag == EXCEPT_ENTERED) \\ except_stack = except_stack-\u0026gt;prev; \\ } if (except_flag == EXCEPT_RAISEED) RERAISE; \\ } while (0) #define RAISE(e) except_raise(\u0026amp;(e), __FILE__, __LINE__) #define RERAISE except_raise(except_frame.exception, except_frame.file, except_frame.line) #define RETURN switch (except_stack = except_stack-\u0026gt;prev , 0) default: return 使用 先全局定义几种异常类型，可以如下定义：\nstruct except allocate_fail = {\u0026#34;Allocate failed\u0026#34;}; struct except div_by_zero = {\u0026#34;divided by 0\u0026#34;}; struct except unknown_exception = {\u0026#34;unknown exception\u0026#34;}; 抛出异常：\nif (something_happened) RAISE(a_except); else (another_thing_happened) RAISE(another_except); else RAISE(unknown_exception); 捕捉异常：\nTRY do_something(); EXCEPT(allocate_fail) printf(\u0026#34;catch a exception of %s\\n\u0026#34;, allocate_fail.reason); EXCEPT(div_by_zero) printf(\u0026#34;catch a exception of %s\\n\u0026#34;, div_by_zero.reason); ELSE printf(\u0026#34;catch a exception of %s\\n\u0026#34;, unknown_exception.reason); RERAISE; END_TRY; 总结 在 C 语言中很多时候对异常的处理其实没有这么麻烦，直接使用 if else 几个分支就搞定了，而且也不会有因为跳转导致资源无法释放的问题。\n但是通过setjmp.h和一些宏实现try ... exception同样是有价值的，除了锻炼思维和写宏读宏的能力外，它还有很多用处，尤其是在一些由 C 编写的其他语言中，它就能提供异常处理甚至是协程的功能（例如 Lua ）。\n因此研究setjmp.h实现异常对我们设计架构乃至编程语言都大有裨益。\n","permalink":"https://vaaandark.top/posts/c-exception/","summary":"\u003cp\u003eC 语言没有原生支持异常处理，但是可以使用\u003ccode\u003esetjmp\u003c/code\u003e和\u003ccode\u003elongjmp\u003c/code\u003e函数实现类似\u003ccode\u003etry ... except\u003c/code\u003e的功能。\u003c/p\u003e\n\u003cp\u003e本文主要参考：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eC Interfaces and Implementation\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-40.pdf\"\u003eImplementing exceptions in C\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"setjmph\"\u003esetjmp.h\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esetjmp.h\u003c/code\u003e是 C 标准函数库中提供“非本地跳转”的头文件：控制流偏离了通常的子程序调用与返回序列。互补的两个函数\u003ccode\u003esetjmp\u003c/code\u003e与\u003ccode\u003elongjmp\u003c/code\u003e提供了这种功能。\u003c/p\u003e","title":"C语言异常处理"},{"content":"Rust 支持函数式编程，因此高阶函数、闭包等特性都不可或缺。\n本文主要参考了 Rust Course 和 Rust 标准库文档。\n什么是闭包 闭包是在支持头等函数的编程语言中实现词法绑定的一种技术，与函数不同的是，它可以捕捉自由变量，这意味着即使脱离了闭包创建时的上下文也能正常运行。\n闭包的用途：\n闭包实现了类似环境变量的功能，多个函数使用相同的环境。\n闭包可以定义自己的控制流程。\n闭包可以实现对象系统。\n在 Rust 中，可以像如下方式创建一个最简单的闭包：\nlet add1 = |x: i32| x + 1; assert_eq!(add1(1), 2); 上面这段代码创建了一个匿名函数add1并在之后调用。\nRust 中闭包的特点：\n参数列表中使用||代替()。\n如果只有一个语句可以省略掉{}。\n可以捕捉自由变量。\n可以利用闭包的类型自动推导，以下几种方法是等效的：\nfn add_one_v1 (x: u32) -\u0026gt; u32 { x + 1 } let add_one_v2 = |x: u32| -\u0026gt; u32 { x + 1 }; let add_one_v3 = |x| { x + 1 }; let add_one_v4 = |x| x + 1 ; 需要注意的是，Rust 虽然有类型的自动推导，但是它只是一种语法糖，而不是泛型，当编译器推导出一种类型的闭包之后，它会一直使用该类型。\n闭包本质上是一种词法绑定，故当闭包从环境中捕获一个值时，会分配内存去存储这些值。对于有些场景来说，这种额外的内存分配会成为一种负担。与之相比，函数就不会去捕获这些环境值，因此定义和使用函数不会拥有这种内存负担。\n三种Fn特征 闭包有三种方式捕获自由变量，分别是：转移所有权、可变借用和不可变借用：\nFnOnce，顾名思义，这种闭包只能使用一次，因为它会夺取捕获到的变量的所有权。 pub trait Fn\u0026lt;Args\u0026gt; : FnMut\u0026lt;Args\u0026gt; { extern \u0026#34;rust-call\u0026#34; fn call(\u0026amp;self, args: Args) -\u0026gt; Self::Output; } FnMut，使用可变引用捕获了环境中的值，因此可以对其进行修改。 pub trait FnMut\u0026lt;Args\u0026gt; : FnOnce\u0026lt;Args\u0026gt; { extern \u0026#34;rust-call\u0026#34; fn call_mut(\u0026amp;mut self, args: Args) -\u0026gt; Self::Output; } Fn，使用不可变引用捕获了环境中的值。 pub trait FnOnce\u0026lt;Args\u0026gt; { type Output; extern \u0026#34;rust-call\u0026#34; fn call_once(self, args: Args) -\u0026gt; Self::Output; } 当闭包的生命周期大于需要捕获的自由变量的生命周期时，可以使用move关键字将自由变量的所有权移入闭包中：\nlet v = vec![1, 2, 3]; let print_vec = move || println!(\u0026#34;{:?}\u0026#34;, v); 除了FnMut需要在创建变量时使用mut，创建闭包时并不需要显式地指定它实现的特征，因此闭包的类型实际上是编译器推导出来的，只有将闭包当作参数传递需要类型标注时才需要显式标记类型。\n一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们。\n所有的闭包都自动实现了FnOnce特征，因此任何一个闭包都至少可以被调用一次 没有移出所捕获变量的所有权的闭包自动实现了FnMut特征 不需要对捕获变量进行改变的闭包自动实现了Fn特征 下面是 Rust Course 中的一个例子，说明了闭包实现的特征取决于使用自由变量的方法，而且因为只使用了不可变引用，三种特征都可以实现。\nfn main() { let s = String::new(); let update_string = || println!(\u0026#34;{}\u0026#34;,s); exec(update_string); exec1(update_string); exec2(update_string); } fn exec\u0026lt;F: FnOnce()\u0026gt;(f: F) { f() } fn exec1\u0026lt;F: FnMut()\u0026gt;(mut f: F) { f() } fn exec2\u0026lt;F: Fn()\u0026gt;(f: F) { f() } 在编程中需要我们善于利用编译器的报错，可以先使用 Fn 特征，然后编译器会告诉你正误以及该如何选择。\n闭包作为返回值 闭包作为函数返回值时不要忘了使用impl关键字，可以理解为实现了Fn(xxx) -\u0026gt; yyy特征。\nfn add_num(n: i32) -\u0026gt; impl Fn(i32) -\u0026gt; i32 { move |x| x + n } fn main() { let add1 = add_num(1); assert_eq!(add1(0), 1); } 使用这种方式有一个局限性就是只能返回一种闭包，因为即使是相同函数签名的闭包也是不同类型的，这时就需要使用特征对象：\nfn factory(x:i32) -\u0026gt; Box\u0026lt;dyn Fn(i32) -\u0026gt; i32\u0026gt; { let num = 5; // 要注意闭包中只捕获了 num 而没有捕获 x，x是闭包的参数，而不是上文中的 x if x \u0026gt; 1{ Box::new(move |x| x + num) } else { Box::new(move |x| x - num) } } fn main() { let add5 = factory(2); let sub5 = factory(1); assert_eq!(add5(0), 5); assert_eq!(sub5(0), -5); } 闭包的生命周期 Rust 中函数和闭包有不同的生命周期省略原则（Lifetime Elision），故两段几乎相同的代码在函数中能编译通过，在闭包中不能通过：\nfn fn_elision(x: \u0026amp;i32) -\u0026gt; \u0026amp;i32 { x } let closure_slision = |x: \u0026amp;i32| -\u0026gt; \u0026amp;i32 { x }; 会报错：\nerror: lifetime may not live long enough --\u0026gt; d.rs:2:47 | 2 | let closure_slision = |x: \u0026amp;i32| -\u0026gt; \u0026amp;i32 { x }; | - - ^^ returning this value requires that `\u0026#39;1` must outlive `\u0026#39;2` | | | | | let\u0026#39;s call the lifetime of this reference `\u0026#39;2` | let\u0026#39;s call the lifetime of this reference `\u0026#39;1` 如果函数参数中只有一个引用类型，那该引用的生命周期会被自动分配给所有的返回引用。但是闭包不会这样，这点值得我们注意。\n结构体中使用闭包 如下代码是官方示例的升级版，Cacher结构体只有在需要获取值且尚未重复计算时执行闭包，在执行后将计算结构缓存到一个HashMap之中，这种模式被叫做惰性求值。\nuse std::collections::HashMap; struct Cacher\u0026lt;F\u0026gt; where F: Fn(i32) -\u0026gt; i32 { val_map: HashMap\u0026lt;i32, i32\u0026gt;, calculation: F } impl \u0026lt;F\u0026gt; Cacher\u0026lt;F\u0026gt; where F: Fn(i32) -\u0026gt; i32 { fn new(calculation: F) -\u0026gt; Cacher\u0026lt;F\u0026gt; { Cacher { val_map: HashMap::new(), calculation } } fn value(\u0026amp;mut self, arg: i32) -\u0026gt; i32 { if let Some(v) = self.val_map.get(\u0026amp;arg) { *v } else { let v = (self.calculation)(arg); self.val_map.insert(arg, v); v } } } fn main() { let mut c = Cacher::new(|x| x); let v1 = c.value(1); let v2 = c.value(2); assert_eq!(v1, 1); assert_eq!(v2, 2); } ","permalink":"https://vaaandark.top/posts/rust-closure/","summary":"\u003cp\u003eRust 支持函数式编程，因此高阶函数、闭包等特性都不可或缺。\u003c/p\u003e\n\u003cp\u003e本文主要参考了 \u003cem\u003e\u003cstrong\u003eRust Course\u003c/strong\u003e\u003c/em\u003e 和 Rust 标准库文档。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"什么是闭包\"\u003e什么是闭包\u003c/h2\u003e\n\u003cp\u003e闭包是在支持头等函数的编程语言中实现词法绑定的一种技术，与函数不同的是，它可以捕捉自由变量，这意味着即使脱离了闭包创建时的上下文也能正常运行。\u003c/p\u003e","title":"Rust闭包"},{"content":"最近一直在学习 Rust 语言，深感它的学习曲线很陡峭，因此会写几篇博客记录一下学习进度。\n本文主要参考了 Rust Course 和 Rust 标准库文档。\n什么是迭代器 迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，设计人员使用此接口无需关心容器对象的内存分配的实现细节。\n在 Rust 中的例子：\n使用for的隐式迭代器 let v = vec![1, 2, 3]; for i in \u0026amp;v { println!(\u0026#34;{}\u0026#34;, i); } for语句中显式使用迭代器 let v = vec![1, 2, 3]; for i in v.into_iter() { println!(\u0026#34;{}\u0026#34;, i); } 使用Iterator特征的next方法 let v = vec![1, 2, 3]; let mut v = v.into_iter(); assert_eq!(arr_iter.next(), Some(1)); assert_eq!(arr_iter.next(), Some(2)); assert_eq!(arr_iter.next(), Some(3)); assert_eq!(arr_iter.next(), None); 当使用for a in b语句遍历时，如果对象 b 实现了IntoIterator特性，我们便可以利用 Rust 给我们提供的语法糖，不必显式使用迭代器。\n迭代器是消耗性的，每遍历到一个元素就会消耗掉一个元素，最终迭代器中没有任何元素，只能返回None。\n要注意两个特征Iterator和IntoIterator的区别，一个是实现了迭代器的基本功能，一个是可以转化为迭代器。\n有趣的是，每个实现了Iterator的类型都实现了IntoIterator，调用into_iter时会返回自身。\n对Iterator更进一步 Iterator的路径为std::iter::Iterator，拥有一个关联类型Item，和迭代的元素类型相同。\n该特性有 72 个方法，下面着重介绍几种常用方法：\nnext方法 fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; 返回Some(Item)或者None，同时更新自己到下一个位置。\nsize_hint方法 fn size_hint(\u0026amp;self) -\u0026gt; (usize, Option\u0026lt;usize\u0026gt;); 返回一个元组(lower, upper)，lower为当前迭代器剩余元素个数的下界，\tupper为其上界。\n如果上界很大，超过了usize的最大值，就会是None，因此size_hint\t的默认实现返回的就是(0, None)，这满足任意一个迭代器。\n这个方法的主要作用是优化代码性能，可以通过该方法为迭代器的元素保留空间。在std的官方文档中提到，该实现应当提供正确的估计，不能因为实现不正确导致内存安全性原则。\nenumerate方法 fn enumerate(self) -\u0026gt; Enumerate\u0026lt;Self\u0026gt;; 返回一个迭代器，迭代器的元素为一个元组(i, val)，i为当前元素的索引，val为当前元素。\nmap方法 fn map\u0026lt;B, F\u0026gt;(self, f: F) -\u0026gt; Map\u0026lt;Self, F\u0026gt;ⓘ where F: FnMut(Self::Item) -\u0026gt; B, { ... } F是一个闭包，通过对每个元素调用该闭包，map将一个迭代器转换为另一个迭代器。\n值得注意的是，map是一个非常“函数式”的方法，如果使用map方法调用一些有副作用的闭包，由于懒惰执行，它可能根本不会起作用：\n(0..5).map(|x| println!(\u0026#34;{}\u0026#34;, x)); for_each方法 fn map\u0026lt;B, F\u0026gt;(self, f: F) where F: FnMut(Self::Item) 效果上类似与for语句，但是不能使用break和continue，适用于很长的迭代器链。\nfilter方法 fn filter\u0026lt;P\u0026gt;(self, predicate: P) -\u0026gt; Filter\u0026lt;Self, P\u0026gt; where P: FnMut(\u0026amp;Self::Item) -\u0026gt; bool 创建一个迭代器，该迭代器使用闭包确定是否应产生元素。\nfilter_map方法 fn filter_map\u0026lt;B, F\u0026gt;(self, f: F) -\u0026gt; FilterMap\u0026lt;Self, F\u0026gt; where F: FnMut(Self::Item) -\u0026gt; Option\u0026lt;B\u0026gt; 既过滤又映射，可以用于简化迭代器链。\nzip方法 fn zip\u0026lt;U\u0026gt;(self, other: U) -\u0026gt; Zip\u0026lt;Self, \u0026lt;U as IntoIterator\u0026gt;::IntoIter\u0026gt; where U: IntoIterator 将两个迭代器压缩为成对的单个迭代器。\n如果任一迭代器返回None，则zipped迭代器中的next将返回None。如果第一个迭代器返回None，则zip将短路，并且不会在第二个迭代器上调用next。\nfold方法 fn fold\u0026lt;B, F\u0026gt;(self, init: B, f: F) -\u0026gt; B where F: FnMut(B, Self::Item) -\u0026gt; B F被称为累加器，通过应用操作将每个元素 fold 到一个累加器中，返回最终结果。\n看一个例子：\nlet a = [1, 2, 3]; let sum = a.iter().fold(0, |acc, x| acc + x); assert_eq!(sum, 6); collect方法 fn collect\u0026lt;B\u0026gt;(self) -\u0026gt; B where B: FromIterator\u0026lt;Self::Item\u0026gt; 将迭代器转换为集合。\ncollect需要上下文让其知道按照什么方式收集，一种是通过直接显式地表明类型，一种是显式地指定collect调用时的类型。\nlet v: vec\u0026lt;_\u0026gt; = (1..5).collect(); // or v = (1..5).collect::\u0026lt;vec\u0026lt;_\u0026gt;\u0026gt;(); skip方法和take方法 take(n)的作用是取前 n 个元素，而skip(n)正好相反，跳过前 n 个元素。\n\u0026hellip;\u0026hellip; 迭代器的方法很多，不一而足\n迭代器适配器和消费者适配器 顾名思义，迭代器适配器就是产生迭代器，消费者适配器就是消耗迭代器。在之前讲map和for_each时可以看到，map创建了一个迭代器，而且是懒惰的，在使用之前不产生任何行为，如果map在调用链的最后一个编译器就会报警，因此我们需要一个消费者适配器来收尾。\nwarning: unused `Map` that must be used --\u0026gt; c.rs:2:5 | 2 | (0..5).map(|x| println!(\u0026#34;{}\u0026#34;, x)); | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ | = note: `#[warn(unused_must_use)]` on by default = note: iterators are lazy and do nothing unless consumed 正确的例子：\nlet v: Vec\u0026lt;_\u0026gt; = (1..5).map(|x| x * 2).collect(); 自己动手实现Iterator特征 主要是要实现Iterator中的next方法，这个方法是其余方法的基础，实现了next方法后，其余都可以默认实现。\nstruct Range { cnt: i32, end: i32 } impl Range { fn new(cnt: i32, end: i32) -\u0026gt; Range { Range { cnt, end } } } impl Iterator for Range { type Item = i32; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { self.cnt += 1; if self.cnt == self.end { None } else { Some(self.cnt) } } } fn main() { let mut r = Range::new(0, 10); assert_eq!(r.next(), Some(1)); assert_eq!(r.next(), Some(2)); assert_eq!(r.next(), Some(3)); assert_eq!(r.next(), Some(4)); let sum: i32 = Range::new(0, 10).sum(); assert_eq!(sum, 45); let sum: i32 = Range::new(0, 10).map(|x| x * 2).filter(|x| x \u0026lt; \u0026amp;10).sum(); assert_eq!(sum, 20); } 总结 迭代器是 Rust 的零成本抽象之一，抽象时不会引起运行时开销，所以迭代器有着极高的运行效率。\n在编写代码时，使用迭代器也能带来良好的函数式编程的体验，使用迭代器链并与闭包结合时体验更是超过了 Lisp 。\n","permalink":"https://vaaandark.top/posts/rust-iterator/","summary":"\u003cp\u003e最近一直在学习 Rust 语言，深感它的学习曲线很陡峭，因此会写几篇博客记录一下学习进度。\u003c/p\u003e\n\u003cp\u003e本文主要参考了 \u003cem\u003e\u003cstrong\u003eRust Course\u003c/strong\u003e\u003c/em\u003e 和 Rust 标准库文档。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"什么是迭代器\"\u003e什么是迭代器\u003c/h2\u003e\n\u003cp\u003e迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，设计人员使用此接口无需关心容器对象的内存分配的实现细节。\u003c/p\u003e","title":"Rust迭代器"},{"content":"华科宿舍的大门门禁用学生卡开，而每个寝室的门却只能使用钥匙打开。这就导致了每次出门都要带上学生卡和钥匙，每次回来都要先掏出卡，再掏出钥匙。这样实在是麻烦，因此我有了用校园卡就能打开宿舍门的想法。\n本项目地址 Github 仓库\n准备工作 参考资料 MFRC522 官方手册 doc\n李乾文的博客 RFID-RC522读IC卡\n同宿舍楼上一位学长的 博文 及 GitHub 仓库\n他博客中引用的链接 文章 及 GitHub 仓库\n材料准备 名称 用途 预算(RMB) USB 延长线（公对母） 供电 6 USB 带开关延长线 开关 10 Arduino UNO R3 开发板 控制 12 MG996R 舵机 开门 13 RC522 IC 卡感应模块 读卡 5 杜邦线 接线 0 （白嫖） 合计：46 RMB\n工具准备 名称 用途 预算(RMB) 热熔胶枪和若干胶棒 固定 20 焊台 焊接 0 （白嫖） 合计：20 RMB\n开发环境 arduino-cli 0.21.1\ncore : arduino:avr 1.8.5 lib : MFRC522 1.4.10 Fritzing 0.9.9 beta\n连线及原理图 RC522 模块的库是网上找的，在连线图上标识不够清晰，可以参考原理图来布线。\n连线 原理图 配置及使用 编译烧录运行./src/get-id/get-id.ino以获得卡的 UID。\n创建文件./src/access-control/card-group.hpp，添加如下代码：\n#define CARD_NUM {卡的数量} #define UID_SIZE 4 static const byte card_group[CARD_NUM][UID_SIZE] = { { 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x00, 0x00 }, // ... }; 编译烧录./src/access-control/access-control.ino则可以使用这个简易门禁了！\n效果图 连线完成效果 安装完成效果 使用效果 ","permalink":"https://vaaandark.top/posts/simple-entrance-guard-in-hust/","summary":"\u003cp\u003e华科宿舍的大门门禁用学生卡开，而每个寝室的门却只能使用钥匙打开。这就导致了每次出门都要带上学生卡和钥匙，每次回来都要先掏出卡，再掏出钥匙。这样实在是麻烦，因此我有了用校园卡就能打开宿舍门的想法。\u003c/p\u003e","title":"华科寝室简易门禁"},{"content":"最近对脚本语言 Lua 很感兴趣，其一是因为它可以很方便地调用 C 语言库，其二是因为它是很多现代化工具的配置语言（比如 NeoVim ），另外 Lua 的源代码不是很长，因此研究学习难度会比其他语言更低。\n基本语法 注释 单行注释以双减号开始-- 多行注释为： --[[ comment --]] 标识符 与C语言规定相同\n保留字 Lua 语言中保留字有 22 个：\nand break do else elseif end false for function if in local nil not or repeat return then true until while goto\n一般约定，以下划线开头连接一串大写字母的名字（比如 VERSION ）被保留用于 Lua 内部全局变量。\n全局变量 Lua 中变量默认为全局变量，使用全局变量前不需要声明，赋值之后即创建了这个变量。\n如果访问了一个不存在的全局变量不会报错，只是它的值是nil。同样地，删除一个变量就可以通过给它赋值为nil来实现。\n数据类型 Lua 是动态类型语言，有八个基本类型，而且其中的一些较为特殊：\n数据类型 描述 nil 只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。 boolean false和true。 number 数字类型 string 字符串 function 由 C 或 Lua 编写的函数 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路，用于执行协同程序 table Lua 中表是一种\u0026quot;关联数组\u0026quot;，数组的索引可以是数字、字符串或表类型。 我们可以使用 type 函数测试给定变量或者值的类型：\nprint(type(\u0026#34;Hello\u0026#34;)) -- \u0026gt; string print(type(114514)) -- \u0026gt; number print(type(print)) -- \u0026gt; function print(type(true)) -- \u0026gt; boolean print(type(nil)) -- \u0026gt; nil print(type(type(nil))) -- \u0026gt; string -- type() 函数返回值为字符串 number Lua 默认只有一种 number 类型，为 double 双精度类型。\nstring 可以使用一对双引号或者单引号来表示，也可以使用[[]]来表示一块字符串。\n如果对字符串进行数字运算，会尝试将字符串转换为一个数字再进行运算；在 Lua 中，真正的字符串拼接是..\n类似于一些脚本语言， Lua 使用#来计算字符串的长度。\ntable 通过构造表达式来创建一个table：\n-- 创建一个空表 table1 = {} -- 在创建时进行初始化 table2 = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;} 向表中添加元素：\na = {} a[\u0026#34;key\u0026#34;] = \u0026#34;value\u0026#34; a[1] = 1 当表的索引为字符串时，可以使用.来像结构体一样访问：\nt = {} t.key = \u0026#39;value\u0026#39; -- 以下两种方法等价 print(t.key) print(t[\u0026#34;key\u0026#34;]) 一种遍历表中元素的方法：\nfor k, v in pairs(a) do print(k .. \u0026#34; : \u0026#34; .. v) end Lua 中表的默认初始索引为1\nfunction 在 Lua 中，function 是第一类值，可以作为对象传递，也可以作为函数返回的值，可以存在变量之中。\nfunction 可以使用匿名函数，也可以使用闭包。\n事实上，Lua 全部的函数都是匿名函数，函数名是对其的引用。\nthread Lua 中主要的线程是协程。\nuserdata 可以将 C/C++ 中的类型数据存在 Lua 变量中调用。\n变量与赋值 Lua 变量有三种类型：全局变量、局部变量、表中的域。变量默认为全局变量\n在多值赋值时，出现变量的个数和值的个数不一致情况：\n如果值更多，则忽略掉多余的值 如果变量更多，则多出来的变量赋值为 nil 多值赋值经常用来交换变量，或将函数调用返回给变量：\na, b = func() a, b = b, a 流程控制 循环 while 循环 while (test_expression) do do_something end for 循环 var 的值从 exp1 到 exp2 （闭区间），exp3 可选，默认为 1 ：\nfor var=exp1, exp2, exp3 do do_something end Lua 中也有泛型 for 循环for .. in ...，与 python 类似。\nrepeat \u0026hellip; until 循环 类似 C 语言中的 do \u0026hellip; while ：\nrepeat do_something until(test_expression) 循环控制语句 break goto 与 C 语言类似\n分支判断 if 使用与 shell 中类似：\nif ( test_expression1 ) then do_something elseif ( test_expression2 ) then do_something else do_something end 函数 optional_func_scope: 默认为全局，使用 local 将函数设置为局部。 ret: Lua 语言中函数返回值可以是多个，用逗号隔开。 optional_func_scope function func_name(arg1, arg2, ... , argn) function_body return ret_val end 函数可以作为参数传递\nLua 支持可变参数，使用时在参数列表中用...表示：\nfunction average(...) local res = 0 local arg = {...} for i, v in ipairs(arg) do res = res + v end res = res / #arg return res end 函数 select(\u0026quot;#\u0026quot;, \u0026hellip;) 可以返回可变参数的数量\nselect(n, \u0026hellip;) 可以返回从起点 n 开始到结束位置的所有参数列表\n运算符 与 C 语言基本相同，逻辑运算为and or not，此外还有乘幂运算^和整除运算//，关系运算符中不等于为~=。\nLua5.3 之后才支持整除运算\n字符串 在 string 模块中有很多方法可以操作字符串，以下函数原型可以望文生义：\nstring.upper(str) string.lower(str) string.gsub(str, find, rep) -- 返回子串的开始和结束索引，[] 表示可选参数 string.find(str, sub [, beg [, end]]) string.reverse(str) -- 返回类似 printf 的格式化字符串 string.format(...) -- 将整型数字转为字符串并连接 string.char(...) -- 转换字符为整数值，默认第一个字符 string.byte(str [, n]) string.len(str) -- 返回 str 的 n 个拷贝 string.rep(str, n) -- 返回一个迭代器函数，init 可选，是搜索的起点 string.gmatch(str, pattern [, init]) -- 字符串截取 string.sub(str, beg [, end]) 匹配模式：Lua 中的匹配模式是一种特殊的正则表达式，详见以下链接\nhttp://lua-users.org/wiki/PatternsTutorial\nhttps://riptutorial.com/lua/example/20315/lua-pattern-matching\n数组 Lua 中的数组实际上就是下标为整数的 table 。\n迭代器 通用形式的 for 通过一个叫作 迭代器 的函数工作。 每次迭代，迭代器函数都会被调用以产生一个新的值， 当这个值为 nil 时，循环停止。 通用形式的 for 循环的语法如下：\nfor namelist in explist do block end 这样的 for 语句\nfor var_1, ···, var_n in explist do block end 它等价于这样一段代码：\ndo local f, s, var = explist while true do local var_1, ···, var_n = f(s, var) if var_1 == nil then break end var = var_1 block end explist 只会被计算一次。它返回三个值，一个迭代器函数 f ，一个状态 s ，一个迭代器的初始值 var 。\n参考：http://cloudwu.github.io/lua53doc/manual.html#3.3.5\n无状态的迭代器 function _square_iter(ending, current) if current \u0026lt; ending then current = current + 1 return current, current * current end end -- 此处相当于对 _square_iter 进行了一个包装 function square_iter(ending, start) return square_iter_, ending, start end for i, n in square_iter(3, 0) do print(i .. \u0026#39;*\u0026#39; .. i .. \u0026#39;=\u0026#39; .. n) end 输出：\n1*1=1 2*2=4 3*3=9 有状态的迭代器 上面代码的等价形式：\nfunction square_iter(a) idx = 0 len = #a -- 迭代函数需要的信息被外层函数传递给了内层函数 return function() idx = idx + 1 if idx \u0026lt;= len then return idx, a[idx] * a[idx] end end end for i, n in square_iter({1, 2, 3}) do print(i .. \u0026#39;*\u0026#39; .. i .. \u0026#39;=\u0026#39; .. n) end 表 移除一个表的引用可以通过赋值为 nil 来完成，如果没有引用指向该表，该表占用的内存就会被释放。\n在 table 模块中有很多方法可以操作表：\n-- 列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开 table.concat (table [, sep [, start [, end]]]): -- 默认插入到数组尾部 table.insert (table, [pos,] value) -- 指定table中所有正数key值中最大的key值。如果不存在key值为正数的元素, 则返回0。(Lua5.2之后该方法已经不存在了) table.maxn (table) -- 默认删除最后一个元素 table.remove (table [, pos]) -- 默认升序 table.sort(table [, comp]) 手动实现 maxn ：\nfunction maxn(t) if (t) then local max_key = t[1] for k, v in pairs(t) do if k \u0026gt; max_key then max_key = k end end return max_key end end 注意：\n当我们使用#时，如果索引不是连续的，则不会返回真正的表长度，因此我们可以自己实现一个函数：\nfunction table.len(t) local len = 0 for k, v in pairs(t) do len = len + 1 end return len end 模块与包 Lua 包 Lua 中的模块是一个由变量、函数等已知元素组成的表，只需要最后将这个 table 返回即可创建一个模块。\n文件格式：\n# filename module.lua module = {} module.const_var = 114514 function module.func() do_something end -- private function local function local_func() do_something end return module 可以使用 require 函数来加载模块：\nrequire(\u0026#34;module_name\u0026#34;) -- or require \u0026#34;module_name\u0026#34; 可以给加载的模块定义一个别名，方便调用（本质是又创建了一个引用）：\n-- 使用局部变量避免污染命名 local m = require(\u0026#34;module\u0026#34;) 函数 require 有自己的文件路径加载策略，会尝试从 Lua 文件或者 C 程序库中加载模块。\n可以搜到的 Lua 文件的路径存放于全局变量 package.path 之中，Lua 解释器启动时会使用系统环境变量 LUA_PATH 来初始化。\n可以像这样将路径加入环境变量：\n#LUA_PATH export LUA_PATH=\u0026#34;~/lua/?.lua;;\u0026#34; C 包 C 包在使用之前一定要加载并且链接：\nlocal path = \u0026#39;/usr/local/lua/lib/libluasocket.so\u0026#39; local f = loadlib(path, \u0026#39;luaopen_socket\u0026#39;) local path = \u0026#34;/usr/local/lua/lib/libluasocket.so\u0026#34; local f = assert(loadlib(path, \u0026#34;luaopen_socket\u0026#34;)) f() -- 真正打开库 ","permalink":"https://vaaandark.top/posts/lua-introduction/","summary":"\u003cp\u003e最近对脚本语言 Lua 很感兴趣，其一是因为它可以很方便地调用 C 语言库，其二是因为它是很多现代化工具的配置语言（比如 NeoVim ），另外 Lua 的源代码不是很长，因此研究学习难度会比其他语言更低。\u003c/p\u003e","title":"Lua入门"},{"content":"最近翻看了一下 《Vim使用技巧》 这本书，然后就发现我对 Vim 快捷键的了解很不深入。不过即使如此，我日常使用 Vim 写代码的效率也高于使用其他编辑器了，足见 Vim 模式之奇。\n实用的命令 普通模式 通过g加移动命令可以在屏幕行而不是实际行中移动。 \u0026lt;C-a\u0026gt;和\u0026lt;C-x\u0026gt;可以对数字进行加减，如果数字开头是0则会被认为是八进制。 该命令和大部分命令一样可以用数字在前修饰表示重复，比如加100是100\u0026lt;C-a\u0026gt;。\ndaw和diw效果类似，但是daw使用更多（caw等同理），因为可以去除多余的空格。但在使用的时候还是看情况是否包括两边。 行内查找既可以用t也可以用f，目的只是查找时明显使用f更加符合直觉，但是在删除到指定位置的使用场景时，dt保留查找字符的特点可以让我们输入一些在文本中多用于分割的字符用于定位，而不是费劲去看分号前面时什么字母。 %可以跳转到成对匹配的符号。 插入模式 有趣但是没啥大用的技巧，\u0026lt;C-v\u0026gt;后接数字可以通过编码输入字符，如果数字以u打头，就是十六进制，\u0026lt;C-k\u0026gt;后接两个字符可以得到二合字母表示的字符。这个技巧在命令行模式中也存在。 可以使用\u0026lt;C-h\u0026gt; \u0026lt;C-w\u0026gt; \u0026lt;C-u\u0026gt;在插入模式中像终端一样删除，该技巧在命令行模式也成立。 使用\u0026lt;C-r\u0026gt;加寄存器名实现在插入模式下快速粘贴。 特殊的插入-普通模式（\u0026lt;C-o\u0026gt;）：即执行一次普通模式命令然后马上进入插入模式。\n可视模式 在按v进入可视模式之后，通过a或i加上' \u0026quot; )等成对匹配的符号，可以直接选中那对符号之间的部分（如果是a则包括那对符号）。 在普通模式下按下gv可以选中上次高亮的部分。 在可视模式下按下o可以将光标切换到另外一段（比较常见的技巧，只是我之前不知道）。 在块可视模式中可以对多行进行插入操作，这样可以不依赖插件实现快速注释和快速取消注释。 命令行模式 命令行命令的格式一般为[range]+[command]+[args]([address])，作用范围和参数可选。 !后的命令由外部shell执行，可以结合读入到缓冲区（read r），从缓冲区写入（write w）达到一些很好的效果，如得到当前工作目录中的所有文件r !ls ./。 当!前有一个范围时，情况就会有所不同，shell执行的外部命令的输出会被写回到缓冲区。可以利用这个特性实现对文本的排序%!sort -n。 %表示当前编辑的文件路径，%:h可以去掉当前文件路径的文件名，非常适合编辑同时编辑多个相对工作目录层级很深的文件时使用。当然，这个也是可以映射的（这里更像宏展开，我也不是很懂vimscript）： cnoremap \u0026lt;expr\u0026gt; %% getcmdtype() == \u0026#39;:\u0026#39; ? expand(\u0026#39;%:h\u0026#39;).\u0026#39;/\u0026#39; : \u0026#39;%%\u0026#39; 在表示范围时，%表示整个文件。 :加行号实现跳转，这个方法其实实用性不高，不如在普通模式下使用行号加\u0026rsquo;G\u0026rsquo;。 一些特殊标记：'m '\u0026lt; '\u0026gt;分别表示位置标记为m的行，高亮选区的起始行和结束行。 在命令行中用复制（copy t）、移动（move m）很多时候会更快。 normal命令可以实现在指定范围执行普通模式命令，在每次执行完之后自动退出插入模式。 Vim 的命令行与shell不同，上下翻历史用的不是\u0026lt;M-p\u0026gt; \u0026lt;M-n\u0026gt;而是\u0026lt;C-p\u0026gt; \u0026lt;C-n\u0026gt;（老版本没有该特性需要自己绑定cnoremap \u0026lt;C-p\u0026gt; \u0026lt;Up\u0026gt; cnoremap \u0026lt;C-n\u0026gt; \u0026lt;Down\u0026gt;） 配置了路径之后可以使用 Vim 内建的find命令，如： :set path+={dirname/**} :find {filename} 其他技巧 清屏\n在 Vim 中也可以利用\u0026lt;C-l\u0026gt;进行清屏，这个技巧在通过查找跳转时相当有用，因为高亮有时十分烦人。也有一劳永逸的方法，就是set nohlsearch直接关闭查找高亮。 启动时\n在配置文件中加入如下代码可以在打开文件时光标处于上次的更新位置： autocmd BufReadPost * if line(\u0026#34;\u0026#39;\\\u0026#34;\u0026#39;\u0026#34;) \u0026gt; 1 \u0026amp;\u0026amp; line(\u0026#34;\u0026#39;\\\u0026#39;\u0026#34;) \u0026lt;= line(\u0026#34;$\u0026#34;) | exe \u0026#34;normal! g\u0026#39;\\\u0026#34;\u0026#34; | endif 代码保存\n如果使用的是 Vim ，想要以超级用户权限保存文件，可以在使用命令w !sudo tee % \u0026gt; /dev/null，即将缓冲区通过tee命令输入到当前文件中，并将标准输出抛弃。可以绑定为：cmap w!! w !sudo tee % \u0026gt; /dev/null。如果使用的是 NeoVim ，则很遗憾不能使用这个小技巧，可以使用插件 Suda.vim。 如果想要保存到一个不存在的目录，可以利用外部命令加上%:h的特性，如： :!mkdir -p %:h :w 缓冲区\n多缓冲区编辑时用:bprevious :bnext命令切换文件比较麻烦可以绑定为： nnoremap \u0026lt;silent\u0026gt; [b :bprevious\u0026lt;CR\u0026gt; nnoremap \u0026lt;silent\u0026gt; ]b :bnext\u0026lt;CR\u0026gt; nnoremap \u0026lt;silent\u0026gt; [B :bfirst\u0026lt;CR\u0026gt; nnoremap \u0026lt;silent\u0026gt; ]B :blast\u0026lt;CR\u0026gt; 在缓冲区进入轮换，即:ls时文件名前有井号时，才可以使用\u0026lt;C-^\u0026gt;快速切换。 :argdo和:bufdo命令可以对多缓冲区进行操作。 标签页和窗口\n相比与使用多缓冲区，使用标签页和窗口更加直观且易于操作，可以达到类似于使用虚拟桌面的效果。 :sp[lit] {file}水平分隔窗口，:vs[plit] {file}垂直分割，这两个用的比较多；而对于同一个文件的分屏\u0026lt;C-w\u0026gt;s和\u0026lt;C-w\u0026gt;v就可能用得比较少了。 在窗口间切换的命令，前缀全部为\u0026lt;C-w\u0026gt;，加上方向hjkl就是按方向的切换，加上w就是循环切换。 :tabe[dit] {filename}在新标签页打开，\u0026lt;C-w\u0026gt;T把当前窗口移到新标签页，tabc[lose]关闭当前标签页及其全部窗口，tabo[nly]只保持当前标签页。 普通模式下{N}gt切换到标号为N的标签页，如果没有N则是切换到上一个，gT是切换到下一个。 设置标记\n可以通过m{a-zA-Z}标记光标所在位置，小写是当前缓冲区可见，大写是全局可见。 通过'{mark}跳转到标记的那一行第一个非空白字符， `{mark}跳转到标记的准确位置。 提高编辑效率的思路 注意一些成对的命令的使用选择，如正向还是反向、到目标位置还是到目标位置之前，虽然每次不会节约太多时间，但毕竟积少成多。 多构造能够通过.来重复的编辑，这需要我们注意每次编辑后光标的位置，如果使用宏也是相同的道理。 能够重复就别用次数（为了撤销时能够当作整体）:例如d3w和2dw。 在适当的时候回到普通模式，让每一次的编辑更在逻辑上更连贯（同样是方便撤销和重复）。 ","permalink":"https://vaaandark.top/posts/vim-practice/","summary":"\u003cp\u003e最近翻看了一下 \u003cstrong\u003e《Vim使用技巧》\u003c/strong\u003e 这本书，然后就发现我对 \u003cstrong\u003eVim\u003c/strong\u003e 快捷键的了解很不深入。不过即使如此，我日常使用 \u003cstrong\u003eVim\u003c/strong\u003e 写代码的效率也高于使用其他编辑器了，足见 \u003cstrong\u003eVim\u003c/strong\u003e 模式之奇。\u003c/p\u003e","title":"一些Vim使用技巧（持续更新）"},{"content":"之前使用git基本只是把它当作提交到 GitHub 上的工具，最多使用到的功能就是恢复误删的文件而已。\n在我之前的git命令使用之中，基本上用的就是git clone、git add .、git commit -m以及git commit push。由于基本上是无脑add，因此.gitigore的文件书写比较重要。\n最近想复习并实践一下git的操作，在翻看git的文档时，发现.gitigore文件并没有我想象的那么简单。\n可以先设想几个情景：\n每个子目录里面的tmp文件夹都不加入到git的版本控制中 只有根目录下的tmp文件夹不加入 所有的tmp文件夹，除了a/b/tmp 忽略a目录下所有的pdf文件 忽略a目录下及其子目录下所有的pdf文件 忽略指定文件之外的文件 在解决这些问题之前，我先了解了一下gitignore的语法设计。它被称为 glob 模式，也就是shell中使用到的简化了的正则表达式，因此掌握它是没有什么难度的。\n# 忽略所有的 .a 文件 *.a # 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件 !lib.a # 只忽略当前目录下的 tmp 文件夹，而不忽略子目录中的 tmp /tmp/ # 忽略任何目录下名为 tmp 的文件夹 tmp/ # 忽略 doc 目录下的 pdf 文件，但不忽略 doc 子目录中的 pdf 文件 doc/*.pdf # 忽略 doc/ 目录及其所有子目录下的 .pdf 文件 doc/**/*.pdf ","permalink":"https://vaaandark.top/posts/how-to-write-gitignore/","summary":"\u003cp\u003e之前使用\u003ccode\u003egit\u003c/code\u003e基本只是把它当作提交到 \u003cstrong\u003eGitHub\u003c/strong\u003e 上的工具，最多使用到的功能就是恢复误删的文件而已。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003cp\u003e在我之前的\u003ccode\u003egit\u003c/code\u003e命令使用之中，基本上用的就是\u003ccode\u003egit clone\u003c/code\u003e、\u003ccode\u003egit add .\u003c/code\u003e、\u003ccode\u003egit commit -m\u003c/code\u003e以及\u003ccode\u003egit commit push\u003c/code\u003e。由于基本上是无脑\u003ccode\u003eadd\u003c/code\u003e，因此\u003ccode\u003e.gitigore\u003c/code\u003e的文件书写比较重要。\u003c/p\u003e","title":"gitignore文件如何书写"},{"content":"最近本来在看 CSAPP 后面的内容，但突然发现自己前面可能还有一些知识掌握不完全，因此做一下 Lab 检验一下。\n准备工作 在 CSAPP 的官网上找到 Lab，下载 Self-Study Handout。 在下载目录下解压文件 tar -xf datalab-handout.tar 尝试执行自动测评脚本driver.pl结果发现没有32位环境，于是用dnf安装需要的库，折腾了一会发现还是不太行。请教了大佬 jyi2ya，他告诉我可以直接在makefile里面把编译条件改为-m64。 题目与题解 int 部分 bitXor 只用~和\u0026amp;实现^\n可以使用德摩根定理秒杀。\nint bitXor(int x, int y) { return ~(~(~x \u0026amp; y) \u0026amp; ~(x \u0026amp; ~y)); } tmin 使用位运算获取补码的最小值\n由于题目已经告诉了我们机器环境，我们可以认为int类型是占八个字节。\nint tmin(void) { return 1 \u0026lt;\u0026lt; 31; } isTmax 使用位运算获取判断是否是补码的最大值\n这题相较上题有一定的技巧。主要思路为把补码的每一位变为1，这样就可以很方便地得到0或非0的值。在转换的过程中要注意到-1同样适用，所以要对-1进行特判。\nint isTmax(int x) { // 如果是0b111...111或者0b011...111就能变为0b000...000 int check = ~(x + 1 + x); // 如果是-1则结果为1，排除掉 int except = !(x + 1); return !(check | except); } allOddBits 判断所有奇数位是否都为1\n一开始的想法是直接暴力判断每个奇数位是否为1（先移位然后进行逻辑与运算），但是这样应该得不到性能分。于是我想到了类似于二分法的思想，每次对半比较，最后只需要七次操作捏。\nint allOddBits(int x) { x \u0026amp;= (x \u0026gt;\u0026gt; 16); x \u0026amp;= (x \u0026gt;\u0026gt; 8); return !(x \u0026amp; 0xaa ^ 0xaa); } negate 不使用-操作符，求-x\n运用补码的基础知识得到答案。\nint negate(int x) { return (~x + 1); } isAsciiDigit 计算输入值是否是数字0-9的 ASCII 值。\n一开始打算先判断前多少多少位是不是0，后面是否满足0x30 \u0026lt;= x \u0026lt;= 0x39，后来一想发现这样好复杂，可以直接通过范围判断。\n可以使用一个小技巧，这个技巧也可以优化分支预测。\nif (x \u0026gt;= a \u0026amp;\u0026amp; x \u0026lt;= b) { do_something(); } // 等价于 if ((x - a) | (b - x) \u0026gt;= ) { do_something(); } 这里不能使用-，但是可以利用前面题目的结论，通过取反和加法代替减法。\n于是我们得到了答案：\nint isAsciiDigit(int x) { return !(((x + (~0x30 + 1)) | ((~x + 1) + 0x39)) \u0026amp; (1 \u0026lt;\u0026lt; 31)); } conditional 通过位运算模拟三目运算\n不难想到：一个数和0x0进行逻辑与操作的结果是0x0，一个数和~0x0进行逻辑与操作的结果是本身。因此我们可以构造一个与x有关的掩码，当x为真时就是0xffffffff，否则为0x0。\nint conditional(int x, int y, int z) { int mask = !x + (~1 + 1); y \u0026amp;= mask; z \u0026amp;= ~mask; return y | z; } isLessOrEqual 通过位运算模拟小于等于\n将两个数移到一边变为减法运算，再把减法运算变为加上绝对值的加法运算，最后判断最高位是否为0即可。\nint isLessOrEqual(int x, int y) { return !(y + (~x + 1) \u0026amp; (1 \u0026lt;\u0026lt; 31)); } 结果这个代码被朋友叉掉了，因为我没有考虑到溢出的情况，所以要加上对一个是正数一个是负数的特判。\nint isLessOrEqual(int x, int y) { return (((x \u0026gt;\u0026gt; 31) \u0026amp; 1) | (!(y \u0026gt;\u0026gt; 31))) \u0026amp; !(y + (~x + 1) \u0026amp; (1 \u0026lt;\u0026lt; 31)); } logicalNeg 通过位运算模拟逻辑非\n我很自然地想到了这样的代码，结果发现没有拿到性能分，刚好比要求多一个操作。\nint logicalNeg(int x) { x ^= ~0; x \u0026amp;= (x \u0026gt;\u0026gt; 16); x \u0026amp;= (x \u0026gt;\u0026gt; 8); x \u0026amp;= (x \u0026gt;\u0026gt; 4); x \u0026amp;= (x \u0026gt;\u0026gt; 2); x \u0026amp;= (x \u0026gt;\u0026gt; 1); return x \u0026amp; 1; } 于是我分析这段垃圾代码，发现x ^= ~0就占用了两步操作，而且有更好的替代方法。\n依然使用类似二分法的思想，同时以使用或操作为主，就能节约操作了。代码如下：\nint logicalNeg(int x) { x |= (x \u0026gt;\u0026gt; 16); x |= (x \u0026gt;\u0026gt; 8); x |= (x \u0026gt;\u0026gt; 4); x |= (x \u0026gt;\u0026gt; 2); x |= (x \u0026gt;\u0026gt; 1); return x \u0026amp; 1 ^ 1; } howManyBits 求最少用多少个位可以表示出给定数字\n刚开始做这题时，我看着题目的例子搞不懂为啥-1只需要一位。最后我的理解就是，题目想问的是“最少用多少个位可以表示从0到给定的数字”，因此如果给出负数我们就不需要考虑正数，反之同理。\n所以这道题转化为了求 $log_2x$ 。\n还是可以将用类似二分的思想解题。首先判断前16位是否有1，如果有就要加上16，同时下一次的移位要多移动16位，依此类推。每次加上的权不同，代表这次判断的一共有n位（16、8、4、2、1）\nint howManyBits(int x) { int mask, b16, b8, b4, b2, b1, b0; mask = x \u0026gt;\u0026gt; 31; x = (mask \u0026amp; ~x) | (~mask \u0026amp; x); b16 = !!(x \u0026gt;\u0026gt; 16) \u0026lt;\u0026lt; 4; x = x \u0026gt;\u0026gt; b16; b8 = !!(x \u0026gt;\u0026gt; 8) \u0026lt;\u0026lt; 3; x = x \u0026gt;\u0026gt; b8; b4 = !!(x \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 2; x = x \u0026gt;\u0026gt; b4; b2 = !!(x \u0026gt;\u0026gt; 2) \u0026lt;\u0026lt; 1; x = x \u0026gt;\u0026gt; b2; b1 = !!(x \u0026gt;\u0026gt; 1); x = x \u0026gt;\u0026gt; b1; b0 = x; return b16 + b8 + b4 + b2 + b1 + b0 + 1; } float 部分 浮点数的题目比较简单，只考察其结构而不是运算。\n为了位运算方便，题目中给出的函数参数和返回值都是与float长度相同的unsigned int或者int\nfloatScale2 求一个浮点数乘2\n首先取出符号sign、尾数frac、阶码exp。 如果阶码是0，说明是一个非规格化的浮点数，由于浮点数的分规格化到规格化的过渡是连续的，因此尾数向左移动一位变成规格化浮点数不是特殊情况。 如果阶码全为1，说明是无穷大，直接原样返回即可。 给阶码加上1，即是给变量exp加上0x800000。 如果溢出了变为无穷大，就要将尾数变为0，否则就是NaN了。 将三部分拼接后返回。 unsigned floatScale2(unsigned uf) { unsigned sign = uf \u0026amp; 0x80000000; unsigned exp = uf \u0026amp; 0x7f800000; unsigned frac = uf \u0026amp; 0x007fffff; if (exp == 0) return sign | uf \u0026lt;\u0026lt; 1; if (exp == 0x7f800000) return uf; exp += 0x00800000; if (exp == 0x7f800000) frac = 0; return sign | exp | frac; } floatFloat2Int 将一个浮点数转换为整型数\n在 CSAPP 中介绍过几种舍入的方法，在计算中向偶数（奇数）位舍入会减小误差，而在类型转换中，使用向零舍入会比较方便。\n首先将符号、尾数、阶码取出来，为了加减法计算方便，对阶码进行了移位，并加上了127。 尾数的第24位置为1，因为在规格化数中就是1.x的形式。而非规格化数舍入变为0，不需要考虑其尾数。 如果阶小于0，直接返回0。 如果阶大于31，说明是无穷大。 其余情况就是对加上1.x（x为尾数）进行移位，由于尾数长24位，因此有方向和绝对值要注意。 带上符号后返回答案。 int floatFloat2Int(unsigned uf) { int ans; int sign = uf \u0026amp; 0x80000000; int exp = ((uf \u0026gt;\u0026gt; 23) \u0026amp; 0xff) -127; int frac = (uf \u0026amp; 0x007fffff) | 0x00800000; if (exp \u0026lt; 0) return 0; if (exp \u0026gt; 31) return 0x80000000; if (exp \u0026lt; 23) ans = frac \u0026gt;\u0026gt; (23 - exp); else ans = frac \u0026lt;\u0026lt; (exp - 23); return sign ? ~ans + 1 : ans; } floatPower2 求$2.0^x$\n利用一个结论：最小的非规格化数是 $2^{-23}*2^{-126}$ ，最大的非规格化数是 $(1-u)*2^{-126}$ ，最小的规格化数是 $2^{-126}$ ，最大规格化数是 $(2-u)*2^{127}$，其中 $u$ 为无穷小。\nunsigned floatPower2(int x) { if (x \u0026lt; -149) return 0; if (x \u0026lt; -126) return 1 \u0026lt;\u0026lt; x + 149; if (x \u0026lt; 128) return x + 127 \u0026lt;\u0026lt; 23; return 0xff \u0026lt;\u0026lt; 23; } 总结 测评结果\nCorrectness Results\tPerf Results Points\tRating\tErrors\tPoints\tOps\tPuzzle 1\t1\t0\t2\t8\tbitXor 1\t1\t0\t2\t1\ttmin 1\t1\t0\t2\t7\tisTmax 2\t2\t0\t2\t7\tallOddBits 2\t2\t0\t2\t2\tnegate 3\t3\t0\t2\t10\tisAsciiDigit 3\t3\t0\t2\t8\tconditional 3\t3\t0\t2\t6\tisLessOrEqual 4\t4\t0\t2\t12\tlogicalNeg 4\t4\t0\t2\t36\thowManyBits 4\t4\t0\t2\t11\tfloatScale2 4\t4\t0\t2\t15\tfloatFloat2Int 4\t4\t0\t2\t10\tfloatPower2 Score = 62/62 [36/36 Corr + 26/26 Perf] (133 total operators) 做了 CSAPP 的 Data Lab 还是收获良多的：\n发现自己之前学习的位运算和浮点数的知识还有不少漏洞，幸好补起来了。 在做这种限制操作的题目时，一开始还是会感觉很不适应，疯狂地想写分支判断等操作。坚持下来之后就有不小的提高，对抽象能力和写更高性能的代码都有帮助。 Lab 中给出的makefile开的编译选项给我报了很多警告，让我发现我的代码习惯不是很好，还有很大进步空间。 ","permalink":"https://vaaandark.top/posts/csapp-data-lab/","summary":"\u003cp\u003e最近本来在看 \u003cem\u003e\u003cstrong\u003eCSAPP\u003c/strong\u003e\u003c/em\u003e 后面的内容，但突然发现自己前面可能还有一些知识掌握不完全，因此做一下 Lab 检验一下。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch1 id=\"准备工作\"\u003e准备工作\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e在 CSAPP 的官网上找到 Lab，下载 Self-Study Handout。\u003c/li\u003e\n\u003cli\u003e在下载目录下解压文件\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etar -xf datalab-handout.tar\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e尝试执行自动测评脚本\u003ccode\u003edriver.pl\u003c/code\u003e结果发现没有32位环境，于是用\u003ccode\u003ednf\u003c/code\u003e安装需要的库，折腾了一会发现还是不太行。请教了大佬 \u003ca href=\"https://www.cnblogs.com/jyi2ya\"\u003e\u003cstrong\u003ejyi2ya\u003c/strong\u003e\u003c/a\u003e，他告诉我可以直接在\u003ccode\u003emakefile\u003c/code\u003e里面把编译条件改为\u003ccode\u003e-m64\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"题目与题解\"\u003e题目与题解\u003c/h1\u003e\n\u003ch2 id=\"int-部分\"\u003eint 部分\u003c/h2\u003e\n\u003ch3 id=\"bitxor\"\u003ebitXor\u003c/h3\u003e\n\u003cp\u003e只用\u003ccode\u003e~\u003c/code\u003e和\u003ccode\u003e\u0026amp;\u003c/code\u003e实现\u003ccode\u003e^\u003c/code\u003e\u003c/p\u003e","title":"CSAPP Data Lab"},{"content":"联创 Lab 组新人任务第一弹。\n关于斐波那契堆 结构与特点 斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。 斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。 斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。 使用一个指针指向斐波那契堆中最小元素。 斐波那契堆将操作尽可能地延后，它的插入是懒惰的，只有在不得不进行合并操作时才进行合并。在极端情况下，它甚至是一个长度很大的链表。 插入操作 将一个节点直接插入到根链表中，并比较键值的大小，如果新节点的键值小于原有节点的键值，就将斐波那契堆的指向最小节点的指针指向它。\n删除最小节点操作 先将最小节点的儿子插入到根链表中，再删除掉这个目标节点。再遍历根链表，合并所有根节点是相同度数的堆。 由于本次实现不需要实现对节点键值的改变或者根据键值删除节点，因此这里的斐波那契堆可以进行一定程度的简化：不再需要指向父亲节点的指针，也不需要第一个儿子是否被删除的标记。由于不需要维护指向父亲的指针，在将儿子们合并到根链表时的操作也可以简化，直接将两个链表合并即可。 实现斐波那契堆 代码文件 https://github.com/vaaandark/MyPriorityQueue\n文件结构 generator文件夹内有文件generator.c，用于生成测试数据。 STLPriorityQueue文件夹内有文件stl_priority_queue.cpp，用STL中的Priority Queue编写，用于对照实验。 src中为基于Fibonacci Heap的Priority Queue的具体实现。 脚本test.sh用于自动化测试，可以使用可选参数clean，用于清理之前测试出现的非代码文件。 src_cpp为Set的C++实现。 ","permalink":"https://vaaandark.top/posts/fibonacci-heap/","summary":"\u003cp\u003e联创 Lab 组新人任务第一弹。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"关于斐波那契堆\"\u003e关于斐波那契堆\u003c/h2\u003e\n\u003ch3 id=\"结构与特点\"\u003e结构与特点\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。\u003c/li\u003e\n\u003cli\u003e斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。\u003c/li\u003e\n\u003cli\u003e斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。\u003c/li\u003e\n\u003cli\u003e使用一个指针指向斐波那契堆中最小元素。\n斐波那契堆将操作尽可能地延后，它的插入是懒惰的，只有在不得不进行合并操作时才进行合并。在极端情况下，它甚至是一个长度很大的链表。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"插入操作\"\u003e插入操作\u003c/h3\u003e\n\u003cp\u003e将一个节点直接插入到根链表中，并比较键值的大小，如果新节点的键值小于原有节点的键值，就将斐波那契堆的指向最小节点的指针指向它。\u003c/p\u003e","title":"斐波那契堆"},{"content":"联创 Lab 组新人任务第一弹。\n关于LLRB 定义 根节点是黑色的。 红色节点的儿子一定是黑色的。 任意节点到任意叶子的最短路径上都有相同数量的黑色节点。 黑色节点的儿子要么全是黑色，要么只有左儿子是黑色。 前三点与红黑树的性质相同，第四点为左偏红黑树的特殊性质，这导致了它的操作相对红黑树更加简单。 左偏红黑树也可以认为其相邻节点的边是有颜色的。 空节点的颜色认为是黑色。 插入操作 可以先就像向二叉查找树中插入节点一样操作，插入时将其颜色赋为红色。如果插入时是黑色，这会导致破坏了LLRB的平衡性质。 保持住了黑色平衡性质之后再来调整其他结构性质，要对连续两个红色节点、只有右儿子是红色节点进行旋转，对左右儿子都是红色的节点进行颜色翻转（拆分2-3-4树中的4-node）。 其操作可以是递归的，编写代码也将更加容易实现。 优先保持平衡性质的原因有：在一开始插入时保持平衡性质最容易实现（只需要给新节点赋红色），此时若优先考虑其他性质，会导致需要考虑的情况过多，而且在后续进行修补（旋转、颜色翻转）的时候不会破坏其平衡性质。 删除操作 依然优先考虑其平衡性质，删除的节点需要是红色的，因此思路就是先将需要删除的节点变成红色的。 此时需要考虑的是，如何将红色节点向下移动（向左下或右下）。当左右儿子都不是红色时也不用担心，可以通过颜色翻转实现，翻转后需要考虑移动的另一个方向是否会出现不满足左倾红黑树的情况，并对其进行修补。 由于LLRB的左偏特性，因此会出现想要向右下移动时，左儿子是红色而右儿子是黑色，因此需要对该节点进行右旋，让向右下的路径上出现红色。 当找到删除的目标节点后，如果是一个叶子节点，直接删去，如果是一个内部节点，便从它的右儿子的分支中找到最小节点与之替换，再删掉。 在向上返回的途中修补节点。 4 中判断是否为叶子节点不应该用它是否有左儿子来判断，而是用它是否有右儿子来判断，因为在前一步中有右旋操作。\n实现LLRB 代码文件 https://github.com/vaaandark/MySet\n文件结构 generator文件夹内有文件generator.c，用于生成测试数据。 STLSet文件夹内有文件stl_set.cpp，STL中的Set编写，用于对照实验。 src中为基于LLRB Tree的Set的具体实现。 脚本test.sh用于自动化测试，可以使用可选参数clean，用于清理之前测试出现的非代码文件。 src_cpp为Set的C++实现。 ","permalink":"https://vaaandark.top/posts/llrb/","summary":"\u003cp\u003e联创 Lab 组新人任务第一弹。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2 id=\"关于llrb\"\u003e关于LLRB\u003c/h2\u003e\n\u003ch3 id=\"定义\"\u003e定义\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e根节点是黑色的。\u003c/li\u003e\n\u003cli\u003e红色节点的儿子一定是黑色的。\u003c/li\u003e\n\u003cli\u003e任意节点到任意叶子的最短路径上都有相同数量的黑色节点。\u003c/li\u003e\n\u003cli\u003e黑色节点的儿子要么全是黑色，要么只有左儿子是黑色。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e前三点与红黑树的性质相同，第四点为左偏红黑树的特殊性质，这导致了它的操作相对红黑树更加简单。\u003c/li\u003e\n\u003cli\u003e左偏红黑树也可以认为其相邻节点的边是有颜色的。\u003c/li\u003e\n\u003cli\u003e空节点的颜色认为是黑色。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"插入操作\"\u003e插入操作\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e可以先就像向二叉查找树中插入节点一样操作，插入时将其颜色赋为红色。如果插入时是黑色，这会导致破坏了LLRB的平衡性质。\u003c/li\u003e\n\u003cli\u003e保持住了黑色平衡性质之后再来调整其他结构性质，要对连续两个红色节点、只有右儿子是红色节点进行旋转，对左右儿子都是红色的节点进行颜色翻转（拆分2-3-4树中的4-node）。\u003c/li\u003e\n\u003cli\u003e其操作可以是递归的，编写代码也将更加容易实现。\n优先保持平衡性质的原因有：在一开始插入时保持平衡性质最容易实现（只需要给新节点赋红色），此时若优先考虑其他性质，会导致需要考虑的情况过多，而且在后续进行修补（旋转、颜色翻转）的时候不会破坏其平衡性质。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"删除操作\"\u003e删除操作\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e依然优先考虑其平衡性质，删除的节点需要是红色的，因此思路就是先将需要删除的节点变成红色的。\u003c/li\u003e\n\u003cli\u003e此时需要考虑的是，如何将红色节点向下移动（向左下或右下）。当左右儿子都不是红色时也不用担心，可以通过颜色翻转实现，翻转后需要考虑移动的另一个方向是否会出现不满足左倾红黑树的情况，并对其进行修补。\u003c/li\u003e\n\u003cli\u003e由于LLRB的左偏特性，因此会出现想要向右下移动时，左儿子是红色而右儿子是黑色，因此需要对该节点进行右旋，让向右下的路径上出现红色。\u003c/li\u003e\n\u003cli\u003e当找到删除的目标节点后，如果是一个叶子节点，直接删去，如果是一个内部节点，便从它的右儿子的分支中找到最小节点与之替换，再删掉。\u003c/li\u003e\n\u003cli\u003e在向上返回的途中修补节点。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e4\u003c/strong\u003e 中判断是否为叶子节点不应该用它是否有左儿子来判断，而是用它是否有右儿子来判断，因为在前一步中有右旋操作。\u003c/p\u003e","title":"左偏红黑树"}]